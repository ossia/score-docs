{"0": {
    "doc": "Looping",
    "title": "Looping",
    "content": "This chapter deals with structure loops, not Process loops. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html",
    "relUrl": "/common-practices/1-looping.html"
  },"1": {
    "doc": "Looping",
    "title": "Loop with transitions",
    "content": "To enable the repetition of certain parts of a scenario, we use transitions to go “back in time”. Transitions are instantaneous intervals that can connect two states regardless of their chronological relationship. In this case, the loop will go on forever as well as playing and replaying all following intervals. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#loop-with-transitions",
    "relUrl": "/common-practices/1-looping.html#loop-with-transitions"
  },"2": {
    "doc": "Looping",
    "title": "Nested loops",
    "content": "For more control and to avoid perpetual looping and branching, it may be necessary to isolate a repeating structure in a sub-scenario. Triggering the end of the interval containing the sub-scenario will ensure that the loop stops as well as the execution of the following intervals. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#nested-loops",
    "relUrl": "/common-practices/1-looping.html#nested-loops"
  },"3": {
    "doc": "Looping",
    "title": "Repetition amount",
    "content": "Adding a trigger on the last Sync of a loop and setting its maximum duration allows to control the amount of repetition. The trigger left by default to be “never” true will still be validated when the maximum duration of the preceding interval has been reached. With this method, the time spent looping is equal to the loop duration + the maximum duration, and can be fine-tuned by manipulating the closing parenthesis. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#repetition-amount",
    "relUrl": "/common-practices/1-looping.html#repetition-amount"
  },"4": {
    "doc": "Looping",
    "title": "Loop branches",
    "content": "Transitions actually connect to Syncs (vertical doted lines), thus, transitioning to a specific Sync will execute or re-execute all connected branches. When several transitions are connected to the same Sync, the smallest loop will then always restart first and cut short all parallel intervals. Transitions can provide a workaround in this situation. Since transitions are instantaneous intervals, they can also be used to isolate parallel loops without interfering with timing and their original synchronization. ",
    "url": "https://ossia.io/score-docs/common-practices/1-looping.html#loop-branches",
    "relUrl": "/common-practices/1-looping.html#loop-branches"
  },"5": {
    "doc": "Livestreaming",
    "title": "Livestreaming",
    "content": "This page explains how to set-up a livestream in various manners. | Livestreaming | Livestreaming with OBS Studio . | On Windows | On macOS | On Linux . | Streaming video outputs | Streaming audio outputs | . | . | Livestreaming from the command line under Linux . | Livestreaming through RTP with GStreamer | Livestreaming audio and video to Twitch (and other RTMP systems) | . | Configuring Jitsi for high-quality streams | . ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html",
    "relUrl": "/common-practices/10-livestreaming.html"
  },"6": {
    "doc": "Livestreaming",
    "title": "Livestreaming with OBS Studio",
    "content": "OBS Studio is a leading free software streaming solution, which is supported on Linux, Windows and macOS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-with-obs-studio",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-with-obs-studio"
  },"7": {
    "doc": "Livestreaming",
    "title": "On Windows",
    "content": "On Windows, we recommend using Spout (available since score 3.0.4) to stream a video output to OBS. | This requires the following OBS plug-in: Off-World-Live/obs-spout2-plugin. | Once OBS is launched, add a “Spout2 Input” source. | In score, add a Spout2 output, and set it as the output of the video effect chain you are working on. | For streaming audio to OBS, the WASAPI audio output of score should be used, as ASIO drivers may not have loopback capabilities, making OBS unable to record the audio output coming from score. | Add an “Audio output capture” for getting the sound output of score into OBS. | . ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-windows",
    "relUrl": "/common-practices/10-livestreaming.html#on-windows"
  },"8": {
    "doc": "Livestreaming",
    "title": "On macOS",
    "content": "On macOS, we recommend using Syphon (available since score 3.0.4) to stream a video output to OBS. You will need the free Syphon Virtual Webcam to be able to see Syphon video streams in OBS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-macos",
    "relUrl": "/common-practices/10-livestreaming.html#on-macos"
  },"9": {
    "doc": "Livestreaming",
    "title": "On Linux",
    "content": "We recommend using GStreamer with shmdata and V4L2 to stream a video output from score to OBS ; this will create a virtual camera that can also be used in web browsers, etc. Streaming video outputs . | Install v4l2loopback, gstreamer, obs-studio. They are available in most distributions’ package repositories. | Reboot or load the module: sudo modprobe v4l2loopback card_label=\"Virtual camera\". | Test that a simple pipeline works: | . $ sudo gst-launch-1.0 videotestsrc ! v4l2sink device=/dev/video0 . If it fails, consider reloading the module with the additional option max_buffers=16. | Install Shmdata and add it to the GStreamer plug-ins. | . This generally means copying libgstshmdata.so in /usr/lib/gstreamer-1.0/. | In score, add a Shmdata output device, and set it as the output of the video effect chain you are working on. | Create a GStreamer pipeline which will pipe the Shmdata output of score into a V4L2 virtual camera. Assuming /tmp/score_shm_video as the shmdata socket path, this gives: | . $ sudo gst-launch-1.0 shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=NV12 \\ ! queue \\ ! v4l2sink device=/dev/video0 . Streaming audio outputs . Simply using JACK or PipeWire works ; OBS is able to take such audio input streams through the “JACK input client” source. Then use your favorite routing GUI to route score’s output into OBS. ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#on-linux",
    "relUrl": "/common-practices/10-livestreaming.html#on-linux"
  },"10": {
    "doc": "Livestreaming",
    "title": "Livestreaming from the command line under Linux",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-from-the-command-line-under-linux",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-from-the-command-line-under-linux"
  },"11": {
    "doc": "Livestreaming",
    "title": "Livestreaming through RTP with GStreamer",
    "content": "RTP is the standard low-level network protocol for streaming audio and video data. To stream to RTP as efficiently as possible from score, we are going to leverage the Shmdata plug-in, and GStreamer. We will stream with the classic MJPEG codec for simplicity in this example ; depending on your system other codecs could be more efficient: x264, HEVC, VP8, etc. Refer to the GStreamer documentation to know how to encode in these formats. First, create a Shmdata video output (writing on the /tmp/score_shm_video path) on score and some video content to stream, then hit play. Then run GStreamer (the shmdata plug-in is needed): . $ gst-launch-1.0 \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=I420 \\ ! queue \\ ! jpegenc \\ ! rtpjpegpay \\ ! udpsink host=127.0.0.1 port=5000 . Create the following file (mjpeg.sdp for instance) which represents the stream: . v=0 m=video 5000 RTP/AVP 26 a=rtpmap:26 JPEG/90000; a=decode_buf=300; c=IN IP4 127.0.0.1 . You can now read the stream, for instance with ffplay, vlc, mpv… . $ ffplay mjpeg.sdp . Note: the format of SDP is: . v=&lt;version&gt; o= &lt;owner&gt; IN IP4 &lt;IP4 ADDRESS&gt; c=IN IP4 &lt;IP4 ADDRESS&gt; s=&lt;STREAM \"HUMAN\" DESCRIPTION&gt; m=&lt;media&gt; &lt;udp port&gt; RTP/AVP &lt;payload&gt; a=rtpmap:&lt;payload&gt; &lt;encoding-name&gt;/&lt;clock-rate&gt;[/&lt;encoding-params&gt;] a=fmtp:&lt;payload&gt; &lt;param&gt;=&lt;value&gt;;... ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-through-rtp-with-gstreamer",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-through-rtp-with-gstreamer"
  },"12": {
    "doc": "Livestreaming",
    "title": "Livestreaming audio and video to Twitch (and other RTMP systems)",
    "content": "Here is an example pipeline, which assumes PipeWire for audio: . $ export STREAM_URL=\"rtmp://mrs02.contribute.live-video.net/app/&lt;YOUR_TWITCH_KEY&gt;\" $ export FPS=30 $ export CHANNELS=2 $ export BITRATE=6000 $ gst-launch-1.0 shmdatasrc socket-path=/tmp/score_shm_video \\ ! videoconvert \\ ! video/x-raw, format=NV12 \\ ! queue \\ ! x264enc bitrate=$BITRATE tune=zerolatency key-int-max=30 \\ ! flvmux streamable=true name=flvmux \\ ! rtmpsink location=\"$STREAM_URL\" \\ pipewiresrc client-name=my-stream \\ ! audio/x-raw,format=F32LE,channels=$CHANNELS \\ ! audioconvert \\ ! faac \\ ! flvmux. Use the following link to choose a correct stream url: https://stream.twitch.tv/ingests. If you are using Jack, use jackaudiosrc instead of pipewiresrc, and do not forget to connect the score audio outputs to the PipeWire / JACK object’s inputs (called my-stream in this example). ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#livestreaming-audio-and-video-to-twitch-and-other-rtmp-systems",
    "relUrl": "/common-practices/10-livestreaming.html#livestreaming-audio-and-video-to-twitch-and-other-rtmp-systems"
  },"13": {
    "doc": "Livestreaming",
    "title": "Configuring Jitsi for high-quality streams",
    "content": "If you use Jitsi, by default the sound and video quality may be low and optimized for talking rather than music. You can open your Jitsi room with the following set of parameters after the room name to increase the available video and audio quality, and enable stereo sound (if the browsers used support it): . https://meet.jit.si/&lt;JITSI_ROOM_NAME&gt;#config.disableAP=true&amp;config.disableAEC=true&amp;config.disableNS=true&amp;config.disableAGC=true&amp;config.disableHPF=true&amp;config.stereo=true&amp;config.enableLipSync=false&amp;config.p2p.enabled=false&amp;config.prejoinPageEnabled=false&amp;config.resolution=1080 . Note that for these parameters to be taken into account, the room must not have been created yet (that is, no one must have joined https://meet.jit.si/&lt;JITSI_ROOM_NAME&gt; already). ",
    "url": "https://ossia.io/score-docs/common-practices/10-livestreaming.html#configuring-jitsi-for-high-quality-streams",
    "relUrl": "/common-practices/10-livestreaming.html#configuring-jitsi-for-high-quality-streams"
  },"14": {
    "doc": "Video mixing and mapping",
    "title": "Video mixing",
    "content": "The user library provides an eight-channel video mixing object. It is available in the process library in the section: . Visuals &gt; ISF Shader &gt; Utility &gt; Video Mixer . It allows to choose opacity and blend mode for the eight input sources. Any improvement is welcome ! . ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html#video-mixing",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html#video-mixing"
  },"15": {
    "doc": "Video mixing and mapping",
    "title": "Video mapping",
    "content": "Likewise, the library provides a simple 4-point video mapping object (nothing advanced such as smooth edge, etc). ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html#video-mapping",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html#video-mapping"
  },"16": {
    "doc": "Video mixing and mapping",
    "title": "Video mixing and mapping",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/11-video-mixing-and-mapping.html",
    "relUrl": "/common-practices/11-video-mixing-and-mapping.html"
  },"17": {
    "doc": "Data processing and filtering",
    "title": "Data processing",
    "content": "score provides a set of facilities to process, filter and route sensor data, through various objects implementing useful behaviours. ",
    "url": "https://ossia.io/score-docs/common-practices/12-data-processing.html#data-processing",
    "relUrl": "/common-practices/12-data-processing.html#data-processing"
  },"18": {
    "doc": "Data processing and filtering",
    "title": "List of useful objects",
    "content": "Most of the objects useful for data mapping are in the process library, in the Control &gt; Mappings and Control &gt; Data Processing categories. | [[Mapping (float) | Mapping curve]] | . | Range Filter | Calibrator | Math expressions | Rate limiter | Object filter | Smooth | Pattern applier | Pattern combiner | Sweeper | . ",
    "url": "https://ossia.io/score-docs/common-practices/12-data-processing.html#list-of-useful-objects",
    "relUrl": "/common-practices/12-data-processing.html#list-of-useful-objects"
  },"19": {
    "doc": "Data processing and filtering",
    "title": "Creating a data processing pipeline from a sensor to an object.",
    "content": "The architecture of such projects generally involve: . | Input sensors. | Outputs (sound, video, or various embedded or electronical devices) | A score which defines how the inputs map to the outputs over time. | . The inputs and outputs will be represented as devices in the Device explorer: . The score can then map inputs to outputs, for instance through a [[Mapping (float)|Mapping curve]] which can be dropped inside the score. Do not forget to hit “Play” for the mapping to start! And remember: the box has to be connected to the start of the score for the mapping to run. To have mappings that run permanently, add a trigger to the end of the box which contains the mappings. The inputs and outputs of the mapping curve can be adjusted by dropping the addresses on the ports from the explorer: . ",
    "url": "https://ossia.io/score-docs/common-practices/12-data-processing.html#creating-a-data-processing-pipeline-from-a-sensor-to-an-object",
    "relUrl": "/common-practices/12-data-processing.html#creating-a-data-processing-pipeline-from-a-sensor-to-an-object"
  },"20": {
    "doc": "Data processing and filtering",
    "title": "Data processing and filtering",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/12-data-processing.html",
    "relUrl": "/common-practices/12-data-processing.html"
  },"21": {
    "doc": "LED design",
    "title": "LED design",
    "content": "score provides a set of facilities to create content for LED shows: . | Compatibility with LED hardware either through DMX or directly through SPI. | Authoring tools to create and visualize RGB data. | . ",
    "url": "https://ossia.io/score-docs/common-practices/13-led-design.html",
    "relUrl": "/common-practices/13-led-design.html"
  },"22": {
    "doc": "LED design",
    "title": "Tools of the trade",
    "content": "List of useful devices . | Art-Net Device: when created without any fixture, the raw DMX channels will be available, as well as the ability to send raw messages to the whole device. | . List of useful objects . Most of the objects useful for LED shows are in the process library, in the Control &gt; Mappings and Control &gt; Generators categories. | Array tool | Array combiner | Array recombiner | Array flattener | Arraygen | Arraymap | . To generate LED content from shaders, one can use the Lightness Computer object which will convert an input texture into a series of pixels. To visualize LED output, one can use the LED View process. ",
    "url": "https://ossia.io/score-docs/common-practices/13-led-design.html#tools-of-the-trade",
    "relUrl": "/common-practices/13-led-design.html#tools-of-the-trade"
  },"23": {
    "doc": "LED design",
    "title": "Controlling LEDs from a shader",
    "content": ". Download the example score here. An easy way to get great visual results is by leveraging existing ISF Shaders from the shader library (or create custom ones!). The Lightness Computer object will convert the texture generated by a shader node into RGB or RGBW pixels ready to be sent to LEDs. ",
    "url": "https://ossia.io/score-docs/common-practices/13-led-design.html#controlling-leds-from-a-shader",
    "relUrl": "/common-practices/13-led-design.html#controlling-leds-from-a-shader"
  },"24": {
    "doc": "LED design",
    "title": "Creating LEDs from generative array computations",
    "content": ". Download the example score here. To create more generative patterns, or for instance reuse an existing data source, it may be useful to leverage the various array generation tools. The general workflow would be: . | Generate each R, G, B (optionnally W), channel through whatever means. For instance, the Arraygen object can easily generate an array with N elements. | Combine these channels through the Array combiner object. It sports different modes – for LED design the most useful would be Intersperse as it would take each element of the input array and lay them out one by one, that is given three arrays representing the R, G, B values such as [ R, R, R, R ] [ G, G, G, G ] [ B, B, B, B ] this object will output [ R G B R G B R G B R G B ]. | The Array tool object can be used as a processing step, for instance to easily adjust gain and brightness, add padding to each of the arrays or individual arrays. | . ",
    "url": "https://ossia.io/score-docs/common-practices/13-led-design.html#creating-leds-from-generative-array-computations",
    "relUrl": "/common-practices/13-led-design.html#creating-leds-from-generative-array-computations"
  },"25": {
    "doc": "LED design",
    "title": "Combining multiple LED strips in one array",
    "content": ". Download the example score here. Here again the Array tool and Array combiner can be used. For instance one can pipe the output of each shader to an Array Tool in order to add pre- or post- padding if necessary, or directly to an Array Combiner in Append mode to put each input one after each other. ",
    "url": "https://ossia.io/score-docs/common-practices/13-led-design.html#combining-multiple-led-strips-in-one-array",
    "relUrl": "/common-practices/13-led-design.html#combining-multiple-led-strips-in-one-array"
  },"26": {
    "doc": "Spatial audio techniques",
    "title": "Spatial audio techniques",
    "content": "score comes packed with tools for creating immersive spatial audio experiences: from simple stereo panning to complex 3D installations with dozens of speakers. Whether you’re working on a concert hall piece, an art installation, or experimental spatial audio, this guide will get you up and running. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html",
    "relUrl": "/common-practices/14-spatial-audio.html"
  },"27": {
    "doc": "Spatial audio techniques",
    "title": "The basics: what is spatialization?",
    "content": "Spatial audio is about placing sounds in 3D space around your audience. Instead of just “left” and “right”, you can position sounds anywhere: behind, above, moving in circles, or scattered across a field of speakers. score gives you several approaches to achieve this, and also integrates with multiple industry-standard tools and protocols for spatial audio. You can either generate object-based spatial audio scenes completely within score, leverage industry-standard sound spatialization plug-ins, or act purely as a controller for separate sound spatialization servers such as SpatGRIS. Some of the main features are: . | DBAP - Works with any speaker layout, handles irregular arrangements. | GBAP - Grid-based spatialization for regular speaker arrays. | Faust spatialization - Including professional libraries like abclib for VBAP and ambisonics as well as simpler circular spatializers. | Matrix Spatialization for routing - Applying a spatialization matrix to the actual speakers. | SpatGRIS control - built-in support for the SpatGRIS OSC API. | Channel-based spatialization - many audio effects will scale to the number of input channels and will allow polyphonic controls. | . In addition, score supports loading many kinds of audio plug-ins: VST, JSFX, etc. For instance, the SPARTA and IEM suites of audio plug-ins are well-suited to sound spatialization ; likewise, it is possible to use the Reaper Ambitools inside ossia, and even combine all these tools together. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#the-basics-what-is-spatialization",
    "relUrl": "/common-practices/14-spatial-audio.html#the-basics-what-is-spatialization"
  },"28": {
    "doc": "Spatial audio techniques",
    "title": "Quick start: a first spatial audio scene",
    "content": ". A few tools are required to properly spatialize an audio object: . | A sound source: generally a mono sound file, synthesizer, etc. | A loudspeaker layout: 2D or 3D data representing how loudspeakers are physically located in the space you wish to spatialize audio in. | . Note: it is also possible to simulate sound spatialization with headphones thanks to HRTF plug-ins and objects. | A spatialization trajectory: 2D or 3D position changes that will move the source over time. | A spatialization algorithm: given trajectories and loudspeakers, computes how much of the signal spreads to each loudspeaker. This can be for instance DBAP, GBAP, VBAP or even a custom algorithm tailored to the use-case at hand. | . This can come from instance from pre-written trajectories with the 2D Spline object, or from tools such as Path generator. Finally, the Matrix Spatialization object will take the sound source and the loudspeaker weights output by the spatialization algorithm, and output the resulting audio signal. Let’s create a simple moving sound that travels in a circle around a 4-speaker (classic quadriphonic) setup. 1. Set up your speakers . First, tell score about your speaker arrangement: . | For this example we will operate mainly in patch mode. Switch to patch mode with the relevant toggle. | Add a Multi-Cursor Manager object and add four points: these will represent our loudspeakers. Remember that it is possible to visualize the loudspeakers with the Point2D View object. Alternatively, you can use Arraygen or Expression Value Generator to generate position through simple math expressions: for Arraygen, return [ cos(2pi i / n), sin(2pi i / n) ]; would for instance lay out points on a circle. Expression Value Generator is the easiest way to directly return coordinates: return [ 0, 0, 1, -1, 2, -2 ]; | Add a sound file from your collection by dropping it in the interface, and make it loop from the inspector. | . 2. Add movement . Now let’s make the sound move: . | Add a Path generator object and draw a simple line. The trajectory will loop over that line. Other modes are for circular and spiral motion, with more to be added over time. | Add a DBAP process. | Add a Matrix Spatialization process. Set the appropriate number of outputs for your layout. | Now, let’s connect everything: | . | The multi-cursor or expression defining the loudspeaker layout’s output goes to the first DBAP inlet. | The path generator output goes to the “Source” DBAP inlet as it is what defines the movement of our spatialized audio source. | The DBAP output goes into the Matrix’s data inlet. | The sound file output goes into the Matrix’s audio inlet. | . Press play, and you should hear the sound move. Congratulations! You’re tipping your toes into spatial audio creation. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#quick-start-a-first-spatial-audio-scene",
    "relUrl": "/common-practices/14-spatial-audio.html#quick-start-a-first-spatial-audio-scene"
  },"29": {
    "doc": "Spatial audio techniques",
    "title": "Spatial audio file playback",
    "content": "There are two main cases of spatial audio files: classic multi-channel audio (e.g. 5.1, 7.1) and ambisonics. For traditional sound files, score natively supports arbitrary number of channels (as many as your computer can handle). Simply route them to the correct output. For ambisonics, if you have a file providing spatialized audio in e.g. B-format, you will need an ambisonics decoder. Multiple free decoders are available. The simplest solution in that case is to use one of the Faust ambisonics decoder, provided as part of Alain Bonardi and Paul Goutmann’s abclib library. This library of efficient spatialized sound algorithms is provided in the Package manager: install it. Then, you will be able to use objects such as abc_2d_stereodecoder, etc. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#spatial-audio-file-playback",
    "relUrl": "/common-practices/14-spatial-audio.html#spatial-audio-file-playback"
  },"30": {
    "doc": "Spatial audio techniques",
    "title": "Spatialization algorithms: choosing the right tool",
    "content": "DBAP (Distance-Based Amplitude Panning) . DBAP is your go-to for most spatial audio work. It calculates speaker levels based on distance, making sounds feel naturally positioned in space. When to use DBAP: . | Irregular speaker layouts (L-shaped rooms, scattered speakers) | 3D installations with speakers at different heights | When you want natural distance attenuation | Small to large speaker arrays (2 to 100+ speakers) | . GBAP (Grid-Based Amplitude Panning) . GBAP works with regular grids of speakers or virtual sources. It’s perfect when you want precise control over speaker arrays, or want to control your system through a hierarchical organization of spatialization with multiple GBAP processes in cascade. It is a useful tool to “weigh” an input across a generic grid. For instance, a first GBAP process could handle spatialization at the building level, with then individual GBAP objects for each room. When to use GBAP: . | Regular speaker grids (4x4, 6x2, 8x8 arrays) | Installations with matrix-arranged speakers | Hierarchical sound installations and management | . VBAP . Ambisonics . ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#spatialization-algorithms-choosing-the-right-tool",
    "relUrl": "/common-practices/14-spatial-audio.html#spatialization-algorithms-choosing-the-right-tool"
  },"31": {
    "doc": "Spatial audio techniques",
    "title": "Faust spatialization: professional algorithms",
    "content": "score integrates with professional spatial audio libraries through Faust, giving you access to industry-standard digital signal processing algorithms. Faust is especially interesting in the context of sound spatialization due to its ability to optimize code for the current CPU you are running, and take advantage of its advanced vector instruction set (AVX2, NEON, etc.) which yields much greater performance than traditional C++ implementations. Built-in spat algorithms . The Faust standard library includes sp.spat - a professional circular spatialization algorithm developed by Laurent Pottier: it assumes that the listening point is surrounded by a circle of speakers. // 8-channel circular spatialization process = vgroup(\"Spatializer\", sp.spat(8, angle, distance)); . To use it: . | Drop the spat Faust preset from the user library | Connect angle and distance controls from your spatial controllers | Customize for your speaker count by editing the Faust code | . abclib: advanced spatial audio library . The abclib package provides professional spatial audio tools: . Ambisonics processing: . | 2D ambisonics up to order 7 (supporting 3-15 channels) | Encoders and decoders for different speaker layouts | Rotation and optimization tools for perfect speaker alignment | . Geometry objects: . | Trajectory generators for complex movement patterns | Maps and mirrors for spatial transformations | Decorrelators and granulators for spatial texture | . A lot of spatial audio effects and synthesizers are available, which makes this toolkit a fairly interesting creative tool. To access abclib: . | Check the Faust user library for abclib presets. You may need to download them from the package manager. | Browse the available objects | Drag’n’drop presets into your score | . Comprehensive Faust spatialization objects . The Faust standard library (spat.lib) provides a rich collection of spatial audio algorithms. Most of them are available directly as built-in presets in the score library and can just be dropped into the score. Here’s what is available: . Core spatialization functions . sp.spat - Multi-channel spatialization with configurable speaker arrays: . // Basic usage process = sp.spat(N, angle, distance); // With custom speaker positions (angles in radians) speakers_angles = (0, 45, 90, 135, 180, 225, 270, 315); process = sp.spat(8, angle, distance, speakers_angles); . sp.stereoize - Enhanced stereo spatialization: . // Creates natural stereo width with distance simulation process = sp.stereoize(angle) : sp.wide; . Panning algorithms . sp.panner - Linear panning between speakers: . // N-channel panner with angle control (0-1) process = sp.panner(N, angle); . sp.constantPowerPan - Equal-power panning for consistent loudness: . // Maintains perceived loudness during panning process = sp.constantPowerPan(angle); . sp.pannerMono - Optimized mono-to-multichannel panning: . // Efficient single-source spatialization process = sp.pannerMono(N, angle); . Advanced spatial processors . sp.encoder3D - 3D ambisonics encoding: . // Encodes to 3D ambisonics (requires x, y, z coordinates) process = sp.encoder3D(order, azimuth, elevation, radius); . sp.decoder - Ambisonics decoding to speaker arrays: . // Decode ambisonics to your speaker configuration process = sp.decoder(order, mode); // mode: \"regular\", \"maxre\", \"inphase\" . sp.wider - Stereo width enhancement: . // Adjustable stereo widening (0 = mono, 1 = normal, &gt;1 = wider) process = sp.wider(width); . Practical Faust spatial examples . TOREVIEW . Moving source with reverb zones: . import(\"stdfaust.lib\"); angle = hslider(\"angle\", 0, 0, 1, 0.01); distance = hslider(\"distance\", 0.5, 0, 1, 0.01); reverb_mix = 1 - distance : smooth(0.99); // More reverb when distant process = sp.spat(8, angle, distance) : par(i, 8, _ &lt;: _, *(reverb_mix) : _, re.mono_freeverb : +); . Frequency-dependent spatialization: . // High frequencies focused, low frequencies omnidirectional splitfreq = 500; process = fi.filterbank(3, (splitfreq)) : sp.spat(8, angle * 0.3, distance), // Bass: less directional sp.spat(8, angle, distance); // Treble: fully directional . Multi-layer ambisonics with decorrelation: . // 2nd order ambisonics with decorrelation for diffuse field process = sp.encoder3D(2, azimuth, elevation, 1) : par(i, 9, de.delay(ma.SR/1000, i*2+1)) // Decorrelate channels : sp.decoder(2, \"maxre\"); . Ambix VST integration . TODO . IEM VST integration . TODO . SPARTA VST integration . The SPARTA (Spatial Audio Real-time Applications) suite provides professional VST plugins for advanced spatial audio processing. These work seamlessly within score’s plugin hosting capabilities. Available SPARTA plugins . TOREVIEW . AmbiENC - Ambisonic encoder: . | Multi-source encoding up to 64 simultaneous sources | Up to 7th order ambisonics (64 channels) | Real-time automation of source positions via VST parameters | . AmbiDEC - Ambisonic decoder: . | Flexible speaker layouts including irregular arrays | Multiple decoding methods: AllRAD, EPAD, MMD | Built-in test signals for speaker alignment | . COMPASS - Binaural rendering: . | Direct binaural synthesis from ambisonics | Multiple HRTF datasets included | Head-tracking support via OSC | . PowerMap - Spatial analysis: . | Real-time visualization of spatial sound field | Activity maps showing sound source directions | Perfect for monitoring spatial mixes | . Using SPARTA in score . | Load as VST in your score | Connect to spatial control data via parameter automation | Chain with score processes for hybrid workflows | . Example workflow: . [Multi-source audio] → [SPARTA AmbiENC] → [Ambisonic mix] → [SPARTA AmbiDEC] → [Speaker array] ↑ [Position automation from score] . Integration benefits: . | Professional algorithms tested in research and production | Scientific accuracy for precise spatial reproduction | CPU efficiency through optimized C++ implementation | Standard VST automation for all spatial parameters | . Pro tip: Combine SPARTA’s scientific precision with score’s creative control - use DBAP for artistic spatialization, then encode to ambisonics with SPARTA for archival or binaural rendering. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#faust-spatialization-professional-algorithms",
    "relUrl": "/common-practices/14-spatial-audio.html#faust-spatialization-professional-algorithms"
  },"32": {
    "doc": "Spatial audio techniques",
    "title": "Advanced spatial workflows",
    "content": "Multi-source spatialization . Create complex soundscapes with multiple moving sources: . | Use Multi-Cursor to control several XY positions graphically | Connect to multiple DBAP processes for independent spatial processing | Or use a single DBAP with multiple position inputs via Combine | Route through Matrix for flexible speaker assignment | . Creative applications: . | Swarm effects: Many small sounds moving independently | Call and response: Sources moving in relation to each other | Spatial counterpoint: Different musical lines in different spatial areas | . Automated spatial trajectories . Go beyond simple circular movement with Path Generator combinations: . Linear sweeps: . | Cross-fades: Sound moving from left to right | Fly-bys: Sound approaching from distance and receding | . Complex patterns: . | Chain multiple Path Generators for figure-8 patterns | Use different speeds for polyrhythmic spatial patterns | Combine with LFO for organic, breathing movement | . Interactive control: . | Map sensors to path parameters using Mapping Tool | Use MIDI controllers to adjust trajectory in real-time | Connect OSC devices for gestural control of spatial movement | . Polyphonic spatial effects . Many audio effects in score automatically become polyphonic when you feed them multichannel audio, which opens another possibility for spatial processing. How it works: . | Single effect, multiple channels: The Audio Effects automatically process each channel independently | List-based control: Instead of single float values, send lists to control each channel separately | Perfect for spatial audio: Apply different reverb to each speaker, or chorus effects that vary by position | . Example workflow: . [Spatial Audio Source] → [DBAP 8-channel] → [Polyphonic Reverb] → [Speakers] ↑ [List of 8 different reverb amounts] . Creative uses: . | Position-dependent effects: More reverb for distant speakers | Spatial coloration: Different EQ for each spatial zone | Dynamic spatial processing: Effects that change as sounds move | . Note that for Faust effects, it is important to make sure that the effect is mono (one input / one output). Many effects in the Faust library come with the stereo assumption: they may require slight change in their code to switch to polyphonic mode. For instance: consider the smoothDelay.dsp file: . import(\"stdfaust.lib\"); process = par(i, 2, voice) with { voice = (+ : de.sdelay(N, interp, dtime)) ~ *(fback); N = int(2^19); interp = hslider(\"interpolation[unit:ms][style:knob]\",10,1,100,0.1)*ma.SR/1000.0; dtime = hslider(\"delay[unit:ms][style:knob]\", 0, 0, 5000, 0.1)*ma.SR/1000.0; fback = hslider(\"feedback[style:knob]\",0,0,100,0.1)/100.0; }; . The par(i, 2, voice) command instantiates the effect for two channels for stereo processing. To put it in mono mode, change 2 to 1 in that line. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#advanced-spatial-workflows",
    "relUrl": "/common-practices/14-spatial-audio.html#advanced-spatial-workflows"
  },"33": {
    "doc": "Spatial audio techniques",
    "title": "Integration with external tools",
    "content": "SpatGris connection . score can control external spatialization software via the SpatGris Device: . | Add SpatGris device in the Device explorer | Configure OSC connection to your SpatGris instance | Control spatial parameters from score while using SpatGRIS algorithms | Best of both worlds: score’s temporal control with SpatGRIS’ spatial processing | . You can use for instance JACK on Windows and Linux, PipeWire on Linux, and BlackHole on Mac to share different tracks between score and SpatGRIS. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#integration-with-external-tools",
    "relUrl": "/common-practices/14-spatial-audio.html#integration-with-external-tools"
  },"34": {
    "doc": "Spatial audio techniques",
    "title": "Troubleshooting spatial audio",
    "content": "Common issues and solutions . “I don’t hear spatialization”: . | Check Matrix routing - are outputs connected to correct speakers? | Verify speaker positions - coordinates should match physical layout | Test with simple content - try sine waves before complex audio | . “Movement sounds choppy”: . | Check audio buffer settings - larger buffers reduce glitches | Use Rate Limiter if to the contrary spatial updates are too frequent and overload for instance SpatGRIS. | . “Spatial effect is too subtle”: . | Increase rolloff in DBAP for more dramatic distance effects | Check speaker calibration - all speakers at equal levels? | Verify room acoustics - reflections can mask spatial effects | . Performance optimization . For large installations: . | Use appropriate rolloff values - higher values = less CPU usage | Consider speaker grouping for very large arrays (50+ speakers) | Monitor CPU usage with multiple spatial processes | . Real-time control: . | Limit update rates using Rate Limiter for smooth performance | Use efficient control mappings with Calibrator or Mapping Tool | Test latency between control input and spatial response | . ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#troubleshooting-spatial-audio",
    "relUrl": "/common-practices/14-spatial-audio.html#troubleshooting-spatial-audio"
  },"35": {
    "doc": "Spatial audio techniques",
    "title": "Next steps: expanding your spatial audio toolkit",
    "content": "Once you’re comfortable with basic spatialization, explore these advanced techniques: . | Combine DBAP and GBAP for frequency-dependent spatialization | Layer multiple spatial algorithms for complex spatial textures | Integrate with Computer Vision Utilities for camera-based spatial control | Connect with Video processing for audiovisual spatial installations | . Spatial audio in score is designed to grow with your artistic vision - start simple and gradually build complexity as you explore the creative possibilities of sound in space. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#next-steps-expanding-your-spatial-audio-toolkit",
    "relUrl": "/common-practices/14-spatial-audio.html#next-steps-expanding-your-spatial-audio-toolkit"
  },"36": {
    "doc": "Spatial audio techniques",
    "title": "Related processes",
    "content": "Essential spatial audio processes: DBAP, GBAP, Matrix, Path Generator, Multi-Cursor, Faust, Audio Utilities, Mapping Tool, and SpatGris Device. ",
    "url": "https://ossia.io/score-docs/common-practices/14-spatial-audio.html#related-processes",
    "relUrl": "/common-practices/14-spatial-audio.html#related-processes"
  },"37": {
    "doc": "Switches",
    "title": "Switches",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html",
    "relUrl": "/common-practices/2-switches.html"
  },"38": {
    "doc": "Switches",
    "title": "Single trigger",
    "content": "Adding a trigger at either end of a looping interval provides control over each repetition. If the trigger is enabled at the beginning of the interval, it controls the start and restarts of the loop. When time reaches the end of the interval, the transition returns to the start Sync where the execution is suspended again until re-triggered. In this case, the interval’s execution must reach its end before it can be restarted. If the trigger is enabled at the end of the loop, it provides flexible time to the interval. As soon as the interval begins executing, it can be interrupted by the validation of the trigger and transition back to the beginning. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#single-trigger",
    "relUrl": "/common-practices/2-switches.html#single-trigger"
  },"39": {
    "doc": "Switches",
    "title": "On / Off",
    "content": "Combining both the above options, an interval can be toggled on and off at will. This method, like the previous, can also be directly mapped to various devices featuring buttons, keys, hardware switches or any kind of discrete value streams. In this case we will use the first button of a game controller accessed through the Joystick Device. When the button is pressed, the first trigger is validated (as by default, it is set to “pulse”) and will respond to any value received at the provided address. When the button is released, the end trigger is validated in the same way, before the transition returns to the initial Sync. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#on--off",
    "relUrl": "/common-practices/2-switches.html#on--off"
  },"40": {
    "doc": "Switches",
    "title": "Consecutive toggles",
    "content": "The section inside the loop can contain more than one interval. Expanding on the prior example, switching between an idle state and an interval, a similar structure could enclose two intervals. This switch also requires an extra trigger. With the default “Pulse” operators to validate each trigger, this structure will return to the idle state after each transition. To avoid this extra step and make sure that the first interval executes every time the button’s value is true and that the second executes every time it is false, the expression for the trigger has to be modified. By setting both the start and end triggers to only respond when the value is true, they can be validated in a row, skipping the idle state after the transition.  . A better way of achieving the same result would be to rely on a sub-scenario to isolate the loop. Since the first trigger is only needed to control the very first execution of the loop, it can be validated once to enter the sub-scenario and omitted in the actual toggle structure. The trigger at the end of the sub-scenario is left “never” valid to allow as many repetitions as needed. It may be preferable to switch at every press of the button, instead of having to hold for the first interval and let go for the second. Adding a minimum duration on each of the toggled intervals ensures that the value of the button can go back to false without validating the next trigger. This method also protects the switch from accidental “double taps”. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#consecutive-toggles",
    "relUrl": "/common-practices/2-switches.html#consecutive-toggles"
  },"41": {
    "doc": "Switches",
    "title": "Parallel switches",
    "content": "Consecutive switches shown above can sequence an arbitrary number of intervals, but only in the same order every time. To enable switching as well as reordering, we can rely on conditional branches. Let’s first create another device for control. For this example we will add a mapper device by copying and pasting the script below. We will name it “Structure”. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"Branch\", type: Ossia.Type.Int, write: function(v) { return v.value; } } ]; } } . Parallel branches start from the same Sync. Syncing them at the end too will also make them responsive to the same trigger and allow us to only set up one transition to loop the entire structure. To add conditions for each start state of parallel intervals, they have to be split into individual events with the “Split condition” function. The state connecting the transition back to the initial Sync does not require a condition. Finally, a trigger on the end Sync can reset the loop with every new value set in the mapper. It is now possible to switch between parallel intervals when setting a value to the “Branch” parameter. To control the start of the structure when played the first time, we have to avoid adding a trigger to the start sync of the loop. It would add an idle state as we experienced before and skip the evaluation of every other value. Instead we can isolate this switch from its initial trigger with another transition, similar to our solution to looping parallel branches. ",
    "url": "https://ossia.io/score-docs/common-practices/2-switches.html#parallel-switches",
    "relUrl": "/common-practices/2-switches.html#parallel-switches"
  },"42": {
    "doc": "2D Spline",
    "title": "2D Spline (X-Y automation)",
    "content": ". The 2D spline is a process which allows to control a 2D position in time, by modifying a curve in the user interface. ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#2d-spline-x-y-automation",
    "relUrl": "/processes/2Dspline.html#2d-spline-x-y-automation"
  },"43": {
    "doc": "2D Spline",
    "title": "Modifying the spline",
    "content": "Points can be dragged with the mouse. | To create a new control point, double-click on the curve. | To remove a point, double-click on it. | Due to the way cubic splines work, there cannot be less than four points. | . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#modifying-the-spline",
    "relUrl": "/processes/2Dspline.html#modifying-the-spline"
  },"44": {
    "doc": "2D Spline",
    "title": "Generating a curve",
    "content": "It is possible to use math formulas to generate a specific spline. To do so, right-click on a spline, and select Generate curve in the menu. The available variable is t. It is evaluated between 0 and 1. The syntax uses ExprTK (see ExprTK support reference page). Here are some useful examples: . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#generating-a-curve",
    "relUrl": "/processes/2Dspline.html#generating-a-curve"
  },"45": {
    "doc": "2D Spline",
    "title": "Circle",
    "content": "var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#circle",
    "relUrl": "/processes/2Dspline.html#circle"
  },"46": {
    "doc": "2D Spline",
    "title": "Spiral",
    "content": "var tp := 2 * PI * t; x := tp * cos(tp); y := tp * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#spiral",
    "relUrl": "/processes/2Dspline.html#spiral"
  },"47": {
    "doc": "2D Spline",
    "title": "Expanding spiral",
    "content": "var tp := 2 * PI * t; x := 0.04 * exp(0.3 * tp) * cos(tp); y := 0.04 * exp(0.3 * tp) * sin(tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#expanding-spiral",
    "relUrl": "/processes/2Dspline.html#expanding-spiral"
  },"48": {
    "doc": "2D Spline",
    "title": "Lissajoux",
    "content": "var tp := 2 * PI * t; x := cos(3 * tp); y := sin(2 * tp); . var tp := 2 * PI * t; x := cos(5 * tp); y := sin(3 * tp); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#lissajoux",
    "relUrl": "/processes/2Dspline.html#lissajoux"
  },"49": {
    "doc": "2D Spline",
    "title": "Hypotrochroids",
    "content": "Star 1 . var tp := 6 * PI * t; var a := 5; var b := 3; var d := 3; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); . Star 2 . var tp := 6 * PI * t; var a := 5; var b := 3; var d := 5; x := (a - b) * cos(tp) + d * cos(tp * (a - b) / b); y := (a - b) * sin(tp) - d * sin(tp * (a - b) / b); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#hypotrochroids",
    "relUrl": "/processes/2Dspline.html#hypotrochroids"
  },"50": {
    "doc": "2D Spline",
    "title": "Others",
    "content": "See https://en.wikipedia.org/wiki/Parametric_equation for inspiration. var tp := 2 * PI * t; var a := 4; var b := 1; var c := 4; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); . var tp := 2 * PI * t; var a := 80; var b := 1; var c := 80; var d := 1; var j := 3; var k := 3; x := cos(a * tp) - pow(cos(b * tp), j); y := sin(c * tp) - pow(sin(d * tp), k); . ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html#others",
    "relUrl": "/processes/2Dspline.html#others"
  },"51": {
    "doc": "2D Spline",
    "title": "2D Spline",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/2Dspline.html",
    "relUrl": "/processes/2Dspline.html"
  },"52": {
    "doc": "Out-of-time triggering",
    "title": "Out-of-time triggering",
    "content": "By default, score works as a time-line: time flows from the start to the end of the score. As mentioned by the quick start guide, the time-line can be made non-linear by adding triggers and graph connections. It is possible to go one step further, by entirely removing parts of the score from the “main” timeline and triggering them at any point in time: for instance in response to an OSC message, by clicking, … . ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html",
    "relUrl": "/common-practices/3-out-of-time.html"
  },"53": {
    "doc": "Out-of-time triggering",
    "title": "Creating an out-of-time score",
    "content": "To remove a part of the score from the time-line, simply make sure that it isn’t connected to the start of the time-line: . When playing the score, this interval now won’t run anymore: . Some score users use that mechanism as a sand-box to try various behaviours. Now, to play this part of the score, we have to tell score what is going to trigger it. Thus, we have to add a trigger to the start of the interval: . Then, select the trigger, go to the inspector and enable the “Start on play” which will make the trigger available for triggering when the score starts, with the right button: . ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#creating-an-out-of-time-score",
    "relUrl": "/common-practices/3-out-of-time.html#creating-an-out-of-time-score"
  },"54": {
    "doc": "Out-of-time triggering",
    "title": "Re-triggering",
    "content": "The left button in the inspector is used to control the re-triggering behaviour. If left unchecked, re-triggering the trigger will stop the sub-score that follows it. It will need another event to start again. If checked, it will restart automatically from the beginning every time the trigger is triggered. ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#re-triggering",
    "relUrl": "/common-practices/3-out-of-time.html#re-triggering"
  },"55": {
    "doc": "Out-of-time triggering",
    "title": "Triggering intervals",
    "content": "When the main score is playing, play / stop buttons will appear on top of intervals when hovered. These allow to stop or start an interval while entirely discarding any semantics that may have been set in the score. This will respect the quantization settings by default. ",
    "url": "https://ossia.io/score-docs/common-practices/3-out-of-time.html#triggering-intervals",
    "relUrl": "/common-practices/3-out-of-time.html#triggering-intervals"
  },"56": {
    "doc": "Audio techniques",
    "title": "Audio techniques",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html",
    "relUrl": "/common-practices/4-audio.html"
  },"57": {
    "doc": "Audio techniques",
    "title": "Playing a sound file",
    "content": "To play a sound file, drag’n’drop it in the score, from the library, or from your operating system. If you don’t hear a sound, check that : . | The time cursor is increasing (if not, that means that the sound card is not properly configured). | The sound file is linked to the beginning of the score via an interval. | . It should look like this: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#playing-a-sound-file",
    "relUrl": "/common-practices/4-audio.html#playing-a-sound-file"
  },"58": {
    "doc": "Audio techniques",
    "title": "Applying an effect",
    "content": "To apply an effect to a sound file: . | Drop it from the process library to the sound file interval. | Connect a cable from the audio file output to the effect input. Now the sound will be routed entirely through the effect. | Add more effects in the same manner, by connecting the output of the previous effects to the input of the following ones ! | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-an-effect",
    "relUrl": "/common-practices/4-audio.html#applying-an-effect"
  },"59": {
    "doc": "Audio techniques",
    "title": "Applying an effect to multiple audio files",
    "content": "To apply an effect to multiple files, it would be possible but unwieldy to connect a cable from each file to the audio effect. Instead, we can group them in a single scenario, and rout the scenario’s output to the audio effects: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-an-effect-to-multiple-audio-files",
    "relUrl": "/common-practices/4-audio.html#applying-an-effect-to-multiple-audio-files"
  },"60": {
    "doc": "Audio techniques",
    "title": "Fade-ins and fade-outs",
    "content": "Every audio outlet has a “gain” sub-outlet which can be used to perform fades. | Press the audio outlet. | Right-click on the “gain” port. | Select “Create automation”. | . The created automation can then be used to adjust the volume of that output in time. ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#fade-ins-and-fade-outs",
    "relUrl": "/common-practices/4-audio.html#fade-ins-and-fade-outs"
  },"61": {
    "doc": "Audio techniques",
    "title": "Analysing an audio signal",
    "content": "score provides a simple envelope analyzer. Combined with the signal display process, this allows to visualize a signal in the time-line. | Add an envelope process (Audio &gt; Envelope). | Add a signal display process (Monitoring &gt; Signal display) | Route the audio output to the input of the envelope process. This means that the entire audio is routed to the envelope process, and thus won’t be heard anymore. To prevent this, check “Propagate” in the audio outlet inspector. | Route the envelope output to the signal display input. The first output measures RMS, the second measures peak values. | If the signal is too low, add a Custom Mapping process between the envelope and the signal display, in order to multiply it by some factor meaningful for your signal. | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#analysing-an-audio-signal",
    "relUrl": "/common-practices/4-audio.html#analysing-an-audio-signal"
  },"62": {
    "doc": "Audio techniques",
    "title": "Sound spatialization",
    "content": "score allows arbitrary numbers of audio channels to go through its ports. This makes it possible to use it for instance with large speaker arrays, domes, etc. A simple and efficient 2D spatialization algorithm is provided with the Faust spat preset (which uses the spatialization method devised by Laurent Pottier). By default, it will spatialize a mono source on a 8-channel circular loudspeaker array. It is possible to edit the Faust script, to change the number of loudspeakers: . | Press the “Window” icon next to the Faust process name, to open its editor. | Edit the following line with the number of wanted loudspeakers instead of 8: . process = vgroup(\"Spatializer 1x8\", sp.spat(8, angle, distance)); . | Press “Compile”. The Faust process will be compiled and updated automatically. | . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#sound-spatialization",
    "relUrl": "/common-practices/4-audio.html#sound-spatialization"
  },"63": {
    "doc": "Audio techniques",
    "title": "Using live audio input",
    "content": "To use a live audio input in a part of the score, follow these steps: . | Set-up the audio device in the device explorer. | Drag’n’drop the input address to use as an input of a sound effect. | . In the following example, a stereo bus receiving a stereo guitar signal has been created. It is sent to a reverb. ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#using-live-audio-input",
    "relUrl": "/common-practices/4-audio.html#using-live-audio-input"
  },"64": {
    "doc": "Audio techniques",
    "title": "Applying global audio effects",
    "content": "As mentioned in audio-routing, mixing is by default hierarchical: objects mix their output in their parent object. In general, most scores will be built around a top-level scenario, which will contain all the structures: . This scenario is no exception to the rule: if you scroll at the bottom of the score, you’ll notice it comes with an output audio port, too. In this example, we reduce its slots’s height so that it is visible: . It is then possible to connect the output of this scenario to another process, to apply a global audio filter: . If complex filtering is necessary, it is of course possible to switch into the nodal view to create advanced effect routings: . ",
    "url": "https://ossia.io/score-docs/common-practices/4-audio.html#applying-global-audio-effects",
    "relUrl": "/common-practices/4-audio.html#applying-global-audio-effects"
  },"65": {
    "doc": "Video techniques",
    "title": "Video techniques",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html",
    "relUrl": "/common-practices/5-video.html"
  },"66": {
    "doc": "Video techniques",
    "title": "Playing videos",
    "content": "See the quick start guide: Working with video. ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#playing-videos",
    "relUrl": "/common-practices/5-video.html#playing-videos"
  },"67": {
    "doc": "Video techniques",
    "title": "Fades",
    "content": "To perform a fade, a simple way is to use the Set Alpha shader filter, provided as part of the user library. | Add the video file. | Add the filter. | Connect one to another. | Connect the filter output to the viewport. | Add an automation to control the opacity. | . Here is a complete example: . ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#fades",
    "relUrl": "/common-practices/5-video.html#fades"
  },"68": {
    "doc": "Video techniques",
    "title": "Making audio-reactive visuals",
    "content": "The core idea is to extract a parameter from the sound, and use it to modify a parameter of a video filter. The Envelope process can be used to extract the average volume of an audio source. The volume is often small and needs to be adjusted to fit the control values ; the Micromap process allows to do that very easily. Here is a video example: . ",
    "url": "https://ossia.io/score-docs/common-practices/5-video.html#making-audio-reactive-visuals",
    "relUrl": "/common-practices/5-video.html#making-audio-reactive-visuals"
  },"69": {
    "doc": "Scenes",
    "title": "Scenes",
    "content": "Scenes are a common pattern in intermedia creation: you want to split a show for instance in a sequence of acts, chapters, etc. To achieve this in score, the general principle is to have sequences of intervals, each containing a sub-scenario. ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html",
    "relUrl": "/common-practices/6-scenes.html"
  },"70": {
    "doc": "Scenes",
    "title": "Structuring a score for dynamic scenes",
    "content": "To go from one scene to the next dynamically by responding to an interaction, it is sufficient to add triggers. It is also possible to use the Play from here tool to transport the timeline to a specific point. Don’t forget to label your scenes in the inspector to make the score easier to read: . ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html#structuring-a-score-for-dynamic-scenes",
    "relUrl": "/common-practices/6-scenes.html#structuring-a-score-for-dynamic-scenes"
  },"71": {
    "doc": "Scenes",
    "title": "Working with scenes",
    "content": "To work on a specific scene, simply go in “full view”. That is, either double-click on the interval header, or press the full view button in the interval inspector. If you have a lot of scenes, you can use the object finder (at the top-right) to find your scene by name or label: . ",
    "url": "https://ossia.io/score-docs/common-practices/6-scenes.html#working-with-scenes",
    "relUrl": "/common-practices/6-scenes.html#working-with-scenes"
  },"72": {
    "doc": "Start/stop cues",
    "title": "Start and stop cues",
    "content": "We want to send a cue whenever the score starts playing, and whenever it is stopped. To do so: . | Dropping a cue from the Device explorer on the first state at the top left of the score, in timeline view, will make that state being played: | Whenever the score is started (for instance when pressing the Global Play button). | Whenever the score is reinitialized (for instance when pressing the Reinitialize button). | Dropping a cue on the last state at the top right of the score, in timeline view, will make that state being played: | Whenever the score is stopped (for instance when pressing the Stop button). | . Remember that the transport bar’s button are in the following order: . | Local play | Global play | Stop | Reinitialize | . ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html#start-and-stop-cues",
    "relUrl": "/common-practices/7-start-stop-cues.html#start-and-stop-cues"
  },"73": {
    "doc": "Start/stop cues",
    "title": "Example",
    "content": ". Consider the above score. When pressing “Global Play”: . | test:/lights 1 is sent. | The score plays. | . Then, when pressing “Stop”: . | The playback is stopped. | test:/sound 0 is sent. | . If instead of pressing “Stop”, “Reinitialize” had been pressed: . | The playback is stopped. | test:/sound 0 is sent. | test:/lights 1 is sent. | . If “Reinitialize” is pressed while the score isn’t playing: . | test:/lights 1 is sent. | . ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html#example",
    "relUrl": "/common-practices/7-start-stop-cues.html#example"
  },"74": {
    "doc": "Start/stop cues",
    "title": "Start/stop cues",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/7-start-stop-cues.html",
    "relUrl": "/common-practices/7-start-stop-cues.html"
  },"75": {
    "doc": "Live coding",
    "title": "Live coding",
    "content": "The timeline nature of ossia score may make it look like it is not very amenable to live coding ; that could not be farther from the truth ! . ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html",
    "relUrl": "/common-practices/8-live-coding.html"
  },"76": {
    "doc": "Live coding",
    "title": "Editing the score during playback",
    "content": "It is possible to edit every part of the score while it plays, and most importantly, start or restart those parts. Most places in a score should be editable during playback ; if you encounter issues, please file a bug report ! In particular, processes, sounds, shaders, etc. can all be added, removed, altered during playback. There is one important exception, that we have not lifted yet: it is not possible to add a new device during playback ; you must prepare the devices to be used before hitting play. For instance, it is not possible as of ossia score 3.0.0-b1 to open a new window for visuals or plug a new MIDI keyboard in the middle of a performance. A very simple trick is then to use triggers to keep the parts running forever: this way, the intervals that are running that way will keep running their processes forever, like for instance would a Max or Pure Data patch. Here is a small example: . ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#editing-the-score-during-playback",
    "relUrl": "/common-practices/8-live-coding.html#editing-the-score-during-playback"
  },"77": {
    "doc": "Live coding",
    "title": "Code-based processes",
    "content": "A few processes in score use textual scripts: . | Javascript | Shaders | Bytebeat | Texture generator | Faust | [[C++ JIT]] | . In all cases, the script can be edited with the small “Window” button on the header of each of the corresponding nodes (the second button). ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#code-based-processes",
    "relUrl": "/common-practices/8-live-coding.html#code-based-processes"
  },"78": {
    "doc": "Live coding",
    "title": "Editing scripts",
    "content": "When that button is pressed, this opens the script editor, which can be used to change the code. When you are done editing, press “Compile” ; this will update the code for the execution engine. Invalid code won’t change the current state to prevent unwanted loud noises and flashes :-) . It is possible to use the Ctrl+Enter(Win / Linux) or⌘+Enter(Mac) shortcut to update the execution engine with the current code. The pane at the bottom of the window will display the error log: here, we have some slightly invalid code on line 9 for instance. ",
    "url": "https://ossia.io/score-docs/common-practices/8-live-coding.html#editing-scripts",
    "relUrl": "/common-practices/8-live-coding.html#editing-scripts"
  },"79": {
    "doc": "Seek and transport",
    "title": "Seek and transport",
    "content": "This page explains all the possible ways to control the transport in score. There are three ways to control transport: . | Manually, with the “play from here” feature which allows to seek at a given point explicitly. | In a pre-determined or processed way with a specific process which allows to control the speed of its parent interval. | Through an external transport system. For now only JACK transport is supported. | . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html",
    "relUrl": "/common-practices/9-seek-and-transport.html"
  },"80": {
    "doc": "Seek and transport",
    "title": "Semantics of transport",
    "content": "Before explaining how to use the actual feature, it is important to explain the semantics of transport in score, as due to the interactive nature of scores, behaviour of transport can be somewhat surprising. Consider the following score: . Thanks to the various interactive features of score such as interactive triggers and interval speed control the three following executions are possible: . This of course begs the question of: what should happen when asking score to transport at any given point when the score has not started playing ? . The policy taken by score is to follow the visual duration set for intervals. That is, that visual duration even for a fully interactive interval is not entirely devoid of semantic meaning: it can be taken as to mean: . The duration that I expect this part of the score to last. In particular, this means that any interactive point before the point to which the transport is performed will be triggered. All intervals that are visually at that point will be positioned accordingly. That is, here are successive transports done in the above score. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#semantics-of-transport",
    "relUrl": "/common-practices/9-seek-and-transport.html#semantics-of-transport"
  },"81": {
    "doc": "Seek and transport",
    "title": "Value compilation",
    "content": "Consider a score where a sound is being played through an external sound player, controlled through OSC. This sound player’s API is: . player:/play &lt;bool&gt; player:/volume &lt;float&gt; . The score is: . Now, if we want to play our score from the middle of the automation, if nothing else was done other than positioning the playhead and starting playback, the player:/play true OSC message would never be sent and the remote software would not start playing, thus making the feature somewhat useless. Thankfully, score takes this into account: by default, when running a transport action if the score is not playing, every state leading to the transported point is computed from the beginning of the score. If multiple states send different values, then the last one is taken into account: that is, if making a transport after the end of the example score shown above, the player will receive the messages: . player:/play false player:/volume 0 . The software settings contain two options to control this behaviour, one for the first time a transport is done, and one for subsequent transports when execution is already running: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#value-compilation",
    "relUrl": "/common-practices/9-seek-and-transport.html#value-compilation"
  },"82": {
    "doc": "Seek and transport",
    "title": "Offset behaviour",
    "content": "A more complex case is related to conditions. In this case, a choice must be made when processing the conditions. However, sometime we may need to explore the different outcomes of a score when doing transport: for instance, if a condition requires a performer to be at a specific place on the stage, we may want to be able to perform a transport without having to ask the performer to go to the designed place for the transport to take place as expected. Thus, the condition inspector provides the “offset behaviour” setting which allows to toggle whether the condition will be true, false, or evaluated with the live value in the device tree, when it is evaluated during a transport operation: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#offset-behaviour",
    "relUrl": "/common-practices/9-seek-and-transport.html#offset-behaviour"
  },"83": {
    "doc": "Seek and transport",
    "title": "Using transport",
    "content": " ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#using-transport",
    "relUrl": "/common-practices/9-seek-and-transport.html#using-transport"
  },"84": {
    "doc": "Seek and transport",
    "title": "Play from here",
    "content": "This feature allows to move the global time bar. To use it, right-click on a scenario and hit “Play from here”: . You can also use the “Play” tool: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#play-from-here",
    "relUrl": "/common-practices/9-seek-and-transport.html#play-from-here"
  },"85": {
    "doc": "Seek and transport",
    "title": "Playing a single state",
    "content": "Either the play tool or a right-click menu allow to launch the content of a single state at any point. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#playing-a-single-state",
    "relUrl": "/common-practices/9-seek-and-transport.html#playing-a-single-state"
  },"86": {
    "doc": "Seek and transport",
    "title": "Controlling speed and transport programmatically",
    "content": "See the documentation of the Tempo process. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#controlling-speed-and-transport-programmatically",
    "relUrl": "/common-practices/9-seek-and-transport.html#controlling-speed-and-transport-programmatically"
  },"87": {
    "doc": "Seek and transport",
    "title": "Controlling global transport through an external API",
    "content": "Right now, only JACK is supported. The plan is to include synchronization with SMTPE, Midi Clock, Ableton Link, etc. over time. The setting is currently in the global software settings: score can act both as a JACK client or master: . ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#controlling-global-transport-through-an-external-api",
    "relUrl": "/common-practices/9-seek-and-transport.html#controlling-global-transport-through-an-external-api"
  },"88": {
    "doc": "Seek and transport",
    "title": "Setting a start marker",
    "content": "It is possible to set a start marker by right-clicking into the musical metrics area, at the top of the score. When a start marker is set, play / pause will always start from this point: this is mainly useful to play a specific part of a score quickly in succession. ",
    "url": "https://ossia.io/score-docs/common-practices/9-seek-and-transport.html#setting-a-start-marker",
    "relUrl": "/common-practices/9-seek-and-transport.html#setting-a-start-marker"
  },"89": {
    "doc": "Release build",
    "title": "Build",
    "content": "This page describes how to build score on various operating systems. Dear packagers: here are specific build instructions to make packages for Linux/BSD/… : Packaging score for Linux. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build",
    "relUrl": "/development/build/release.html#build"
  },"90": {
    "doc": "Release build",
    "title": "Dependencies",
    "content": "To build, you will need the following dependencies (commands for downloading everything automatically are given below): . | Qt 6 (&gt;= 6.4) | CMake (&gt;= 3.26) | Boost (automatically downloaded) | (optional) FFMPEG (&gt;= 5.x) | A recursive clone of the score repository : git clone --recursive https://github.com/ossia/score. | . The easiest way to get most dependencies in a prebuilt form is by downloading our SDK for your platform. Important: do not use the source releases produced by GitHub : they do not have the submodules and compiling with them won’t work. Your compiler need to be recent; supported compilers are: . | gcc &gt;= 12 | clang &gt;= 14 | Xcode &gt;= 14 | Visual Studio 2022 17.6.2 (exactly this version due to many bugs in other versions of the compiler) | . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#dependencies",
    "relUrl": "/development/build/release.html#dependencies"
  },"91": {
    "doc": "Release build",
    "title": "Debian-like systems",
    "content": "Ubuntu, Debian . Dependencies . sudo apt-get update -qq sudo apt-get install wget software-properties-common wget -nv https://github.com/Kitware/CMake/releases/download/v3.19.1/cmake-3.19.1-Linux-x86_64.tar.gz -O cmake-linux.tgz tar xaf cmake-linux.tgz rm cmake-linux.tgz mv cmake* /opt/ echo 'deb http://apt.llvm.org/bionic/ llvm-toolchain-bionic-9 main' | sudo tee /etc/apt/sources.list.d/llvm.list sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 1397BC53640DB551 sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com 15CF4D18AF4F7421 sudo add-apt-repository --yes ppa:ubuntu-toolchain-r/test sudo add-apt-repository --yes ppa:beineri/opt-qt-5.13.2-bionic sudo apt-get update -qq sudo apt-get install -qq --force-yes \\ g++-9 binutils libasound-dev ninja-build \\ gcovr lcov \\ qt513-meta-minimal qt513svg qt513quickcontrols2 qt513websockets qt513serialport \\ qt513base qt513declarative \\ libgl1-mesa-dev \\ libavcodec-dev libavutil-dev libavfilter-dev libavformat-dev libswresample-dev \\ portaudio19-dev clang-9 lld-9 \\ libbluetooth-dev \\ libsdl2-dev libsdl2-2.0-0 libglu1-mesa-dev libglu1-mesa \\ libgles2-mesa-dev \\ libavahi-compat-libdnssd-dev . Build . mkdir -p build_folder cd build_folder /opt/cmake-3.19.1-Linux-x86_64/bin/cmake path/to/score \\ -DCMAKE_C_COMPILER=/usr/bin/gcc-9 \\ -DCMAKE_CXX_COMPILER=/usr/bin/g++-9 \\ -DCMAKE_PREFIX_PATH=/opt/qt513 \\ -DCMAKE_BUILD_TYPE=release \\ -DPORTAUDIO_ONLY_DYNAMIC=1 make all_unity # you can add -j$(nproc) to make it faster . NOTE : if you have installed Qt with Qt installer instead of your distro package manager, then you may need to specify where CMake should look for Qt with, for example : . cmake -GNinja -DCMAKE_PREFIX_PATH=~/Qt/5.13.2/gcc_64 ../score/ . Run ./score . Raspberry Pi . Dependencies . First edit /etc/apt/sources.list. Replace : . deb http://archive.raspbian.org/raspbian jessie main . By : . deb http://archive.raspbian.org/raspbian stretch main . Then : . sudo apt -y install git cmake wget ninja-build libqt5websockets5-dev qtbase5-dev qtdeclarative5-dev qt5-default qtbase5-dev-tools qttools5-dev libqt5svg5-dev g++-7 libportmidi0 libasound-dev mesa-common-dev libboost-dev libavahi-compat-libdnssd-dev . Build . mkdir -p build_folder cd build_folder cmake -GNinja -DCMAKE_C_COMPILER=/usr/bin/gcc-7 -DCMAKE_CXX_COMPILER=/usr/bin/g++-7 path/to/score ninja . Run : . $ ./score . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#debian-like-systems",
    "relUrl": "/development/build/release.html#debian-like-systems"
  },"92": {
    "doc": "Release build",
    "title": "macOS :",
    "content": "There is a build.sh script at the root of the repository, it requires Homebrew . So either : ./build.sh open build/score.app . Or ./build.sh release open build-release/score.app . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#macos-",
    "relUrl": "/development/build/release.html#macos-"
  },"93": {
    "doc": "Release build",
    "title": "Build on Windows with Clang",
    "content": ". | Download and extract the latest MinGW SDK here : https://github.com/ossia/sdk/releases/tag/sdk16 in c:\\score-sdk (so you should have a c:\\score-sdk\\llvm\\ folder for instance). | Install dependencies: CMake and ninja. | . With chocolatey: . cinst -y cmake ninja . | Build from a cmd shell (note: this will take 10-15 minutes on a good machine) | . mkdir build cd build set PATH=%PATH%;c:\\score-sdk\\llvm\\bin cmake -GNinja c:/path/to/score ^ -DCMAKE_C_COMPILER=c:/score-sdk/llvm/bin/clang.exe ^ -DCMAKE_CXX_COMPILER=c:/score-sdk/llvm/bin/clang++.exe ^ -DCMAKE_BUILD_TYPE=Release ^ -DOSSIA_SDK=c:\\score-sdk ^ -DCMAKE_INSTALL_PREFIX=release ^ -DCMAKE_PREFIX_PATH=\"c:/score-sdk/qt5-static;c:/score-sdk/llvm-libs;c:/score-sdk/SDL2;c:/score-sdk\" ^ -DCMAKE_UNITY_BUILD=1 ^ -DOSSIA_STATIC_EXPORT=1 ^ -DSCORE_INSTALL_HEADERS=1 ^ -DDEPLOYMENT_BUILD=1 cmake --build . cmake --build . --target package . This will create an installer for the latest version. Alternatively, replace cmake --build . --target package by cmake --build . --target install to install the executable directly in the release subfolder of your build folder. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build-on-windows-with-clang",
    "relUrl": "/development/build/release.html#build-on-windows-with-clang"
  },"94": {
    "doc": "Release build",
    "title": "Build on Windows with MSVC (currently broken !)",
    "content": "This requires at least Visual Studio 2017 15.9.6, freely available from Microsoft’s website. First, install the dependencies with the mechanism of your choice. Then, on a command shell, run : . mkdir score-build cd score-build cmake -T host=x64 -A x64 ../score -DCMAKE_BUILD_TYPE=release -DCMAKE_PREFIX_PATH=path/to/Qt5Config.cmake cmake --build . --target package . The relevant folders are : . | For boost : the path to the folder contained in the archive downloaded, for instance c:\\Libraries\\boost_1_63_0 ; it should contain boost, libs, doc subfolders. e.g. -DBOOST_ROOT=c:/Libraries/boost_1_63_0. | For Qt : the path to the Qt5Config.cmake, e.g. -DCMAKE_PREFIX_PATH=c:/Libraries/Qt/5.7/msvc2015/lib/cmake/Qt5. | . This creates an installable package, install it and run score from your desktop. Else you have to copy the Qt DLLs and plug-ins to the folder where score.exe was built. ",
    "url": "https://ossia.io/score-docs/development/build/release.html#build-on-windows-with-msvc-currently-broken-",
    "relUrl": "/development/build/release.html#build-on-windows-with-msvc-currently-broken-"
  },"95": {
    "doc": "Release build",
    "title": "Android",
    "content": "Clone qt5 from git : . git clone https://github.com/qt/qt5 cd qt5 git submodule update --init --recursive . Apply the following patch : https://bugreports.qt.io/browse/QTBUG-60455 if it has not been merged, in the folder qt5/qtbase : . cd qt5/qtbase git-apply 0001-Android-....patch . Also add #include &lt;QtMath&gt; in qtbase/src/plugins/platforms/android/androidjniinput.cpp. Configure and build Qt5 : ../qt5/configure -opensource -confirm-license -xplatform 'android-clang-libc++' -nomake tests -nomake examples -android-ndk /opt/android-ndk-r15b -android-sdk /opt/android/sdk -android-arch armeabi-v7a -no-warnings-are-errors -opengl es2 -opengles3 -android-ndk-platform android-22 -prefix /opt/qt-android make -j8 make install . Build the player library : . cd ~/build cmake ~/score -DCMAKE_TOOLCHAIN_FILE=~/score/API/CMake/android_toolchain.cmake -DCMAKE_PREFIX_PATH=/opt/qt-android/lib/cmake/Qt5 -DISCORE_CONFIGURATION=android-debug -DISCORE_PLAYER=1 -Wno-dev -DOSSIA_PROTOCOL_MIDI=0 . Put the library in the correct folder : . mkdir -p /opt/qt-android/qml/Ossia/ ln -s ~/score/API/ossia/ossia-qml/Ossia/*.qml /opt/qt-android/qml/Ossia/ cp ~/score/API/ossia/ossia-qml/Ossia/qmldir /opt/qt-android/qml/Ossia/ ln -s ~/build/libiscore_player_plugin.so /opt/qt-android/qml/Ossia/ . Change the name of the library in the qmldir (iscore_player_plugin instead of ossia) . To run with QtCreator, add the following library in the android build : . /opt/android-ndk-r14b/sources/cxx-stl/llvm-libc++/libs/armeabi-v7a/libc++_shared.so . (adapt the architecture, paths, etc… for your phone / tablet) . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#android",
    "relUrl": "/development/build/release.html#android"
  },"96": {
    "doc": "Release build",
    "title": "Sanitization",
    "content": "clang-tidy -p ~/iscore-tidy/compile_commands.json base/**/*.cpp --header-filter=base/ . ",
    "url": "https://ossia.io/score-docs/development/build/release.html#sanitization",
    "relUrl": "/development/build/release.html#sanitization"
  },"97": {
    "doc": "Release build",
    "title": "Release build",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/release.html",
    "relUrl": "/development/build/release.html"
  },"98": {
    "doc": "Hacking",
    "title": "Very very quickstart",
    "content": "The developer.sh will try to download and install the required dependencies, and compile score in a way suitable for development: . $ git clone --recursive -j16 https://github.com/ossia/score $ cd score $ ./tools/developer.sh . On Windows it is recommended to run this script from an MSYS2 Clang64 shell. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#very-very-quickstart",
    "relUrl": "/development/build/hacking.html#very-very-quickstart"
  },"99": {
    "doc": "Hacking",
    "title": "Quickstart",
    "content": "This page presents how to start developing things on ossia score. We recommend heavily to use QtCreator as IDE to do so, or at least an IDE with native support for CMake. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#quickstart",
    "relUrl": "/development/build/hacking.html#quickstart"
  },"100": {
    "doc": "Hacking",
    "title": "Cloning the project",
    "content": "Make sure to make a recursive clone of the project, or you will encounter build issues: . $ git clone --recursive -j16 https://github.com/ossia/score . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#cloning-the-project",
    "relUrl": "/development/build/hacking.html#cloning-the-project"
  },"101": {
    "doc": "Hacking",
    "title": "Add-ons",
    "content": "The default repository of score does not come with all add-ons of the official release included, as some of them are being developed in other git repositories. To add an add-on to the build, clone its repository into the score/src/addons folder. For instance, to add NDI support: . $ cd score/src/addons $ git clone --recursive https://github.com/ossia/score-addon-ndi . And rerun CMake in the build folder (cd build-folder; cmake .) before rebuilding for the build system to pick-up the new addon. To get all the add-ons of the official distribution, you can run the ./ci/common.deps.sh script, but be aware that some add-ons such as the ONNX one require additional steps when debugging on Windows or Mac ; it is recommended to start with a functioning build of score without the addons if this is the first time you are building it. To add a new feature to ossia, it is recommended to start by making a new addon from one of the various templates. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#add-ons",
    "relUrl": "/development/build/hacking.html#add-ons"
  },"102": {
    "doc": "Hacking",
    "title": "Building ossia score with system packages or a package manager",
    "content": "Building ossia score on Windows . On Windows we recommend using MSYS2 with a Clang64 shell. $ pacman -S pactoys $ pacboy -S --needed \\ cmake:p \\ ninja:p \\ toolchain:p \\ cppwinrt:p \\ qt6-base:p \\ qt6-declarative:p \\ qt6-websockets:p \\ qt6-serialport:p \\ qt6-shadertools:p \\ qt6-scxml:p \\ qt6-tools:p \\ boost:p \\ portaudio:p \\ fftw:p \\ ffmpeg:p \\ SDL2:p \\ git $ git clone --recursive -j16 https://github.com/ossia/score $ cmake -Wno-dev \\ -S score \\ -B build-folder \\ -GNinja \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 \\ -DCMAKE_OPTIMIZE_DEPENDENCIES=1 \\ -DCMAKE_LINK_DEPENDS_NO_SHARED=1 \\ -DSCORE_DYNAMIC_PLUGINS=0 $ cmake --build build-folder . Building ossia score on macOS . On Windows we recommend using Homebrew. $ brew install ninja qt boost cmake ffmpeg fftw portaudio jack sdl lv2 lilv suil freetype $ brew uninstall --ignore-dependencies qt@5 $ git clone --recursive -j16 https://github.com/ossia/score # Generate CMAKE_PREFIX_PATH=\"$(brew --prefix qt@6);$(brew --prefix ffmpeg);...\" # This is not necessary but avoids issues when brew upgrades packages as # CMake will by default point to a specific version, e.g. /opt/homebrew/Cellar/ffmpeg/7.1.1/blah # Which breaks whenever brew updates to e.g. ffmpeg 7.1.2 $ CMAKE_PREFIX_PATH= $ for pkg in \"${BREW_PACKAGES[@]}\"; do $ CMAKE_PREFIX_PATH+=\"$(brew --prefix ${pkg} -q);\" $ done $ CMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH::${#CMAKE_PREFIX_PATH}-1} $ xcrun cmake -Wno-dev \\ -S score \\ -B build-folder \\ -GNinja \\ -DCMAKE_PREFIX_PATH=\"$CMAKE_PREFIX_PATH\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 \\ -DCMAKE_OPTIMIZE_DEPENDENCIES=1 \\ -DCMAKE_LINK_DEPENDS_NO_SHARED=1 $ xcrun cmake --build build-folder . Building ossia score on Linux . It is harder to give a single set of build instructions for Linux, as every distribution differs. Check out the build scripts for your distros here. For instance, for Ubuntu 22.04: . | jammy.deps.sh will install the required dependencies. | jammy.build.sh will build. | . Likewise, for Ubuntu 24.04: . | noble.deps.sh will install the required dependencies. | noble.build.sh will build. | . You should change the CMake invocation a bit, as the one on the CI scripts is optimized for a fast complete rebuild on the CI server, but changing a single file and rebuilding will be excruciatingly slow: . Instead of . $ cmake .. \\ -GNinja \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_INSTALL_PREFIX=install \\ -DSCORE_DYNAMIC_PLUGINS=1 \\ -DCMAKE_UNITY_BUILD=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 . You really want (adapted with the clang version you have): . $ cmake -Wno-dev \\ -S ~/path/to/score -B build-folder \\ -GNinja \\ -DCMAKE_C_COMPILER=\"clang\" \\ -DCMAKE_CXX_COMPILER=\"clang++\" \\ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 $ cmake --build build-folder . which will make individual changes much faster (the difference can be between waiting a couple minutes instead of a couple seconds after each rebuild). If you have an up-to-date distribution, you can also install the mold linker which is even faster than lld, and replace -fuse-ld=lld with -fuse-ld=mold in the lines above. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-ossia-score-with-system-packages-or-a-package-manager",
    "relUrl": "/development/build/hacking.html#building-ossia-score-with-system-packages-or-a-package-manager"
  },"103": {
    "doc": "Hacking",
    "title": "Rebuild the project after an initial build",
    "content": "Once you have a build folder, only the cmake --build . command is necessary. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#rebuild-the-project-after-an-initial-build",
    "relUrl": "/development/build/hacking.html#rebuild-the-project-after-an-initial-build"
  },"104": {
    "doc": "Hacking",
    "title": "Building with the ossia SDK",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-with-the-ossia-sdk",
    "relUrl": "/development/build/hacking.html#building-with-the-ossia-sdk"
  },"105": {
    "doc": "Hacking",
    "title": "Downloading the SDK",
    "content": "This gives you the exact same build configuration than the official releases. Required dependencies and libraries, except CMake and Ninja, can be downloaded from a pre-built SDK. This will give you the exact libraries used for the official ossia score releases. This script will download the latest version of the SDK automatically. Otherwise: . On Windows . | Install git with git bash. | Download the SDK and extract it in c:\\ossia-sdk. | You must also install CMake. | Ninja is extremely recommended for build speed - download it and extract ninja.exe in c:\\ossia-sdk\\llvm\\bin\\. | . On Linux . Download the SDK and extract it in /opt/ossia-sdk. You must also install CMake 3.26 at least, either through your distribution or the official CMake website. On macOS . Building on macOS is only supported from an ARM64 (M1 / M2 / …) host, e.g. a Mac from 2020 onwards. | If using Homebrew, remove most packages as CMake picks up Homebrew dependencies which can be incompatible with the SDK libraries, and cause run-time crashes for instance because the header files of Homebrew’s versions of ffmpeg or Qt were found yet linking occurs with the ossia SDK libraries which may not compatible. If in doubt, remove homebrew entirely and only install cmake, wget, gnu-sed, gnu-tar and ninja. In particular, ffmpeg, fftw, boost, gstreamer, qt, sdl, portaudio must absolutely not be installed through Homebrew. | If you cannot remove them, then use the Homebrew build instructions above. | Download the SDK and extract it in /opt/ossia-sdk-aarch64. You must also install XCode at the latest version (XCode 16) and CMake+Ninja (for instance through Homebrew). | . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#downloading-the-sdk",
    "relUrl": "/development/build/hacking.html#downloading-the-sdk"
  },"106": {
    "doc": "Hacking",
    "title": "Building score with the SDK",
    "content": "Build the project on Windows with the SDK . With git bash: . $ export PATH=/c/ossia-sdk/llvm/bin:$PATH $ cmake -S c:/path/to/score -B build-folder \\ -GNinja \\ -DCMAKE_C_COMPILER=c:/ossia-sdk/llvm/bin/clang \\ -DCMAKE_CXX_COMPILER=c:/ossia-sdk/llvm/bin/clang++ \\ -DOSSIA_SDK=c:/ossia-sdk \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 $ cmake --build build-folder . Or with cmd.exe, the native command shell: . &gt; set PATH=c:\\ossia-sdk\\llvm\\bin;%PATH% &gt; cmake -S c:\\path\\to\\score -B build-folder ^ -GNinja ^ -DCMAKE_C_COMPILER=c:\\ossia-sdk\\llvm\\bin\\clang ^ -DCMAKE_CXX_COMPILER=c:\\ossia-sdk\\llvm\\bin\\clang++ ^ -DOSSIA_SDK=c:\\ossia-sdk ^ -DCMAKE_BUILD_TYPE=Debug ^ -DSCORE_PCH=1 ^ -DCMAKE_COLOR_DIAGNOSTICS=1 &gt; cmake --build build-folder . Note: on Windows, the system antivirus slows build times a lot. Be sure to exclude recursively: . | The ossia-sdk folder | The score source folder | The score build folder | . from antivirus scans if things are slow as it seems that every file access is checked, and compilers do those a lot. Build the project on macOS with the SDK . note : replace aarch64 by x86_64 if you are on an older mac . $ xcrun cmake -S ~/path/to/score \\ -B build-foldere \\ -GNinja \\ -DOSSIA_SDK=/opt/ossia-sdk-aarch64 \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 $ xcrun cmake --build build-folder . Build the project on Linux with the SDK . $ cmake -S ~/path/to/score \\ -B build-folder \\ -GNinja \\ -DOSSIA_SDK=/opt/ossia-sdk \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 \\ -DCMAKE_COLOR_DIAGNOSTICS=1 $ cmake --build build-folder . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-score-with-the-sdk",
    "relUrl": "/development/build/hacking.html#building-score-with-the-sdk"
  },"107": {
    "doc": "Hacking",
    "title": "Installing dependencies manually",
    "content": "Ensure that you have the latest version of Qt, boost, and your C++ compiler installed. Note : to ensure a very fast build time, it is recommended to use clang as compiler and ninja for building, on every platform. Additionally, on Linux and Windows lld can be used as a linker. It is quite faster than GNU ld and gold. On recent Linux, mold can also be used, which is even faster. At the time of this writing, this means : . | Software | Version | . | Compiler | clang 19 or gcc 14 or msvc 2022 | . | Qt | Qt 6.8+ | . | Boost | 1.87 | . | CMake | 3.31 | . However, to get a complete build with support for more features, more is needed : . | Software | Version |   | . | FFMPEG | 7.x | # Required for sound playback | . | LLVM | 19.x | # Required for Faust support. Must be same version than clang used to build. | . | OpenSSL | 3.x | # Required to connect to wss / https | . | Faust | Latest | # Required to load Faust plug-ins | . | suil, lilv | Latest | # Required to load LV2 plug-ins | . | PortAudio | Latest | # Required to playback sound using Coreaudio, ASIO, ALSA, Pulseaudio… | . | PipeWire | Latest | # Required to playback sound using PipeWire… | . | JACK2 | Latest | # Required to playback sound using JACK | . | SDL2 | Latest | # Required to have gamepad support | . | libbluetooth | Latest | # Required to have BLE support on Linux | . | Avahi | Latest | # Required to have Bonjour / Zeroconf support on Linux | . Or you can install them with your package manager of choice - see the packages for each platform at the end of this document. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#installing-dependencies-manually",
    "relUrl": "/development/build/hacking.html#installing-dependencies-manually"
  },"108": {
    "doc": "Hacking",
    "title": "Useful documentation",
    "content": ". | (Using) CMake | (Writing) CMake | Qt | Qt Creator | . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#useful-documentation",
    "relUrl": "/development/build/hacking.html#useful-documentation"
  },"109": {
    "doc": "Hacking",
    "title": "Building on the command line",
    "content": "First get a recursive clone of the repository : . $ git clone --recursive -j16 https://github.com/ossia/score . The preferred way to build when hacking on the software is with cninja: . cninja ~/path/to/score developer . Alternatively, one can build with CMake. Pass the following options to cmake to ensure maximal build speed: (note that the instructions later on this page may not be entirely up-to-date) . -GNinja # Makes the build much faster -DCMAKE_C_COMPILER=/path/to/clang # Makes the build faster (only needed on Linux) -DCMAKE_CXX_COMPILER=/path/to/clang++ # Makes the build faster (only needed on Linux) -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" # Makes the linking faster (only needed on Linux) -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" # Makes the linking faster (only needed on Linux) -DCMAKE_BUILD_TYPE=Debug # For having debug symbols -DSCORE_PCH=1 # Makes the build much much faster -DSCORE_DYNAMIC_PLUGINS=1 # Makes the linking faster (only on Mac / Linux ; on Windows it does not work) -DCMAKE_COLOR_DIAGNOSTICS=1 # Avoids a rebuild if an IDE injects this when opening the project for the first time. Important: Run the cmake command in a separate build folder, especially not in the source directory of score ! . For instance, for generating the build files on Ubuntu, Debian or Linux Mint, that gives : . cmake -S /path/to/score -B /path/to/build \\ -GNinja \\ -DCMAKE_C_COMPILER=/usr/bin/clang \\ -DCMAKE_CXX_COMPILER=/usr/bin/clang++ \\ -DCMAKE_SHARED_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_EXE_LINKER_FLAGS=\"-fuse-ld=lld\" \\ -DCMAKE_BUILD_TYPE=Debug \\ -DSCORE_PCH=1 \\ -DSCORE_DYNAMIC_PLUGINS=1 . If you are using the SDK mentioned above, add: . -DOSSIA_SDK=/path/to/sdk . If you are not using your distribution’s Qt version because it’s too old, pass the path to a recent version with, for instance, . -DCMAKE_PREFIX_PATH=/home/yourname/Qt/6.8.2/gcc_64 . The path must contain a lib folder in which CMake is going to look for Qt. Once CMake has ran successfully, do : . cmake --build . To be safe, you should have at least 8 gigabytes free on your hard drive before starting a build. ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-on-the-command-line",
    "relUrl": "/development/build/hacking.html#building-on-the-command-line"
  },"110": {
    "doc": "Hacking",
    "title": "Building with Qt Creator",
    "content": "Refer to this video : https://www.youtube.com/watch?v=LSifHFbuky0 . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#building-with-qt-creator",
    "relUrl": "/development/build/hacking.html#building-with-qt-creator"
  },"111": {
    "doc": "Hacking",
    "title": "Windows with Visual Studio",
    "content": "Note that building with Visual Studio, while checked in the CI, is not officially supported ; we recommend using MSYS2 with clang64 instead. First install: . | The latest version of Visual Studio 2022 | git | CMake | Python | Take a few seconds to contemplate the easiness of building on the above Unix platforms | Extract https://github.com/ossia/sdk/releases/download/sdk14/win-audio-sdk-msvc.zip in your c:\\ so that the folders once extracted look like c:\\score-sdk-msvc\\portaudio and c:\\score-sdk-msvc\\ffmpeg | . Run a x64 Native Tools Command Prompt for VS 2022: . In the command prompt, install Qt: . (Assuming your development environment is in a c:\\dev folder) . cd c:\\dev # Install dependencies ## Qt pip install aqtinstall aqt install-qt --outputdir c:\\Qt 6.8.2 windows desktop 6.8.2 win64_msvc2022_64 # Build cmake ../score -DCMAKE_PREFIX_PATH=\"c:/Qt/6.8.2/msvc2022_64\" -DOSSIA_SDK=\"c:/score-sdk-msvc\" -DSCORE_PCH=1 -DCMAKE_INSTALL_PREFIX=installed -DCMAKE_BUILD_TYPE=Debug cmake --build . --config Debug cmake --build . --config Debug --target install # Run cd installed score.exe . ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html#windows-with-visual-studio",
    "relUrl": "/development/build/hacking.html#windows-with-visual-studio"
  },"112": {
    "doc": "Hacking",
    "title": "Hacking",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/hacking.html",
    "relUrl": "/development/build/hacking.html"
  },"113": {
    "doc": "Packaging",
    "title": "General information",
    "content": "Score has many build options, modules, etc… but there is one canonical way to build a release tailored for Unix distributions. Please use the package versions provided with score / libossia as much as possible and not the distribution-provided packages, else we get bug reports because the version of TBB / PortAudio / … of $DISTRO has known problems. In particular RtMidi and oscpack have been more or less entirely rewritten. If you don’t want to, then it’s better to let the users use the AppImage because those are known to be working. If your distro has a PortAudio package, please ensure that its PortAudio version is not linking against JACK, because else it can cause hangs (e.g. in Debian, Ubuntu). If it does, then please ensure that score does not link against PortAudio. Examples of existing packages: . | ArchLinux AUR | Nix | MinGW | Flatpak | . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#general-information",
    "relUrl": "/development/build/packaging.html#general-information"
  },"114": {
    "doc": "Packaging",
    "title": "Dependencies",
    "content": ". | CMake (&gt;= 3.24) | Qt (&gt;= 6.4) | Boost (whatever is the latest version, at least 1.83, otherwise ossia will download the latest version by itself) | FFMPEG (libavcodec, etc., at least FFMPEG 5) | . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#dependencies",
    "relUrl": "/development/build/packaging.html#dependencies"
  },"115": {
    "doc": "Packaging",
    "title": "Building a release",
    "content": "The procedure is straightforward: . # Configure step cmake -Wno-dev \\ -DCMAKE_BUILD_TYPE=Release \\ -DCMAKE_UNITY_BUILD=1 \\ -DDEPLOYMENT_BUILD=1 \\ -DCMAKE_SKIP_RPATH=ON \\ -DCMAKE_INSTALL_PREFIX=\"/usr\" \\ \"srcdir\" # Build step # Just running make is possible but will be much slower. cmake --build . # adding -- -j4 at least will greatly increase build speed # Install step # do **not** just run make install, else score will install a lot of unneeded headers (boost, etc). cmake -DCMAKE_INSTALL_DO_STRIP=1 -DCOMPONENT=OssiaScore -P cmake_install.cmake . ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html#building-a-release",
    "relUrl": "/development/build/packaging.html#building-a-release"
  },"116": {
    "doc": "Packaging",
    "title": "Packaging",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/build/packaging.html",
    "relUrl": "/development/build/packaging.html"
  },"117": {
    "doc": "Plug-ins with Avendish",
    "title": "Avendish documentation",
    "content": "Before focusing on writing score plug-ins, read the Avendish documentation to get familiar with what it allows. In short: this plug-in API leverages C++ reflection to define media objects. The inputs and outputs of objects are simply struct members: here is for instance the entire definition of a simple Avendish audio processing object: . #pragma once #include &lt;cmath&gt; struct Distortion { static consteval auto name() { return \"Distortion\"; } static consteval auto c_name() { return \"disto\"; } static consteval auto uuid() { return \"dd4dd880-d525-44fb-9773-325c87b235c0\"; } struct { struct { static consteval auto name() { return \"Preamp\"; } static consteval auto control() { struct { const float min = 0.001; const float max = 1000.; const float init = 1.; } c; return c; } float value{0.5}; } preamp; struct { static consteval auto name() { return \"Volume\"; } float value{1.0}; } volume; } inputs; void operator()(double** in, double** out, int frames) { const double preamp = inputs.preamp.value; const double volume = inputs.volume.value; for (int c = 0; c &lt; channels; c++) for (int i = 0; i &lt; frames; i++) out[c][i] = volume * std::tanh(in[c][i] * preamp); } }; . Note in particular that Avendish objects implementation do not by themselves require any library to be included, not even the standard C++ one. This allows them to be portable to as many platforms as C++ compilers run on, including bare-metal microcontrollers. Note that in order to reduce verbosity, an helper library is provided, and most examples use it: it is however in no way mandatory. ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html#avendish-documentation",
    "relUrl": "/development/plugins/plugins-with-avendish.html#avendish-documentation"
  },"118": {
    "doc": "Plug-ins with Avendish",
    "title": "Plug-in types",
    "content": "Multiple kind of plug-ins can be written with Avendish: . | Audio processing plug-ins. | Message processing plug-ins. | CPU-based image processing plug-ins. | GPU-based plug-ins (compute pipelines or vertex/fragment draw pipelines). | . The reflection-based approach allows various “shapes” of plug-ins to work: for instance, the above sample plug-in passes the audio channels as arguments to the processing function. Another way to write the same plug-in, which would use ports for everything, would be: . #pragma once #include &lt;halp/audio.hpp&gt; #include &lt;halp/controls.hpp&gt; #include &lt;halp/meta.hpp&gt; #include &lt;cmath&gt; class Distortion { public: halp_meta(name, \"Distortion (helpers)\") halp_meta(c_name, \"disto\") halp_meta(uuid, \"82bdb9b5-9cf8-440e-8675-c0caf4fc59b9\") struct { halp::dynamic_audio_bus&lt;\"Input\", double&gt; audio; halp::hslider_f32&lt;\"Preamp\", halp::range{.min = 0.001, .max = 1000., .init = 0.5}&gt; preamp; halp::val_port&lt;\"Volume\", float&gt; volume; } inputs; struct { halp::dynamic_audio_bus&lt;\"Output\", double&gt; audio; } outputs; using tick = halp::tick; void operator()(halp::tick t) { const double volume = inputs.volume; const double preamp = inputs.preamp; for(int c = 0; c &lt; inputs.audio.channels; c++) { auto* in = inputs.audio[c]; auto* out = outputs.audio[c]; for (int i = 0; i &lt; t.frames; i++) outputs.audio[c][i] = volume * std::tanh(inputs.audio[c][i] * preamp); } } }; . ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html#plug-in-types",
    "relUrl": "/development/plugins/plugins-with-avendish.html#plug-in-types"
  },"119": {
    "doc": "Plug-ins with Avendish",
    "title": "Creating a dynamic score plug-in with the template",
    "content": "The recommended way to create a plug-in is by using the template provided on Github. It contains everything needed to automatically create a plug-in. Whenever you push a new commit, Github will automatically compile the plug-in for Mac, Windows and Linux. | Create a repository from the template by clicking on the green “Use this template” button. | . For instance, let’s say your personal repository will be: https://github.com/yourself/foobinator and your plug-in name is Foobinator. | Clone your new repository: | . $ git clone git@github.com:yourself/foobinator . | If your shell is zsh, run ./init.zsh Foobinator, otherwise ./init.sh Foobinator | . This will replace the generic names in the repository by your custom name, Foobinator and auto-generate unique identifiers. | Set-up your plug-in’s name and description inside the addon.json file. | Set-up git again – the script removes the existing local git repo to make sure you can start from a clean state, without the template repo git history. | . $ git remote add origin git@github.com:yourself/foobinator $ git add . $ git commit -m 'First commit' $ git push --set-upstream origin main --force . | After some minutes, you can check the “SDK” action of the plug-in on Github: | . https://github.com/yourself/foobinator/actions/workflows/builds-sdk.yaml . If everything is ok, it should have generated a “plugin” archive which will contain the MacOS, Windows and Linux builds. This can be extracted to Documents/ossia/score/package/foobinator: the object should become visible the next time you launch score. ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html#creating-a-dynamic-score-plug-in-with-the-template",
    "relUrl": "/development/plugins/plugins-with-avendish.html#creating-a-dynamic-score-plug-in-with-the-template"
  },"120": {
    "doc": "Plug-ins with Avendish",
    "title": "Building locally from the command line",
    "content": "For building a plug-in locally, you need: . | If you are on a Mac, XCode must be installed. On all platforms you must also install CMake and Ninja. | The simplest way is to follow the steps that are done on the CI as they are regularly automatically checked, unlike the instructions on this page :-) . | . https://github.com/ossia-templates/score-avnd-simple-template/blob/main/.github/workflows/builds-sdk.yaml . In short: . | Create an empty “development” folder and clone or move your repository in it | . $ mkdir dev $ cd dev $ git clone git@github.com:yourself/foobinator . | Download and run this script: https://github.com/ossia/score/raw/master/tools/fetch-sdk.sh which will download required compilers and libraries. | From score’s package manager, download the SDK which will contain the header files that match this version of score. | . It will be installed in ~/Documents/ossia/score/sdk/&lt;VERSION&gt; . NOTE The 3.1.8 version does not support this yet, you need to download and extract the SDK of the continuous build (and continuous version of score) manually. Starting from 3.1.9 this will be fixed, but until then use this: https://github.com/ossia/score/releases/tag/continuous . For instance on Linux: . $ mkdir -p ~/Documents/ossia/score/sdk $ cd ~/Documents/ossia/score/sdk $ wget https://github.com/ossia/score/releases/download/continuous/linux-sdk.zip $ 7z x linux-sdk.zip -ocontinuous . | Run CMake (this step will only be needed the first time) | . $ cd dev $ export SCORE_SDK=/path/to/Documents/ossia/score/sdk/3.1.x # Or if you downloaded the \"continuous\" SDK as mentioned above: $ export SCORE_SDK=/path/to/Documents/ossia/score/sdk/continuous # If on windows: $ export OSSIA_SDK=c:/ossia-sdk $ export PATH=$OSSIA_SDK/llvm/bin:$PATH $ export CC=clang $ export CXX=clang++ # If on mac: $ export OSSIA_SDK=/opt/ossia-sdk-x86_64 # If on Linux: $ export OSSIA_SDK=/opt/ossia-sdk $ export PATH=$OSSIA_SDK/llvm/bin:$PATH $ export CC=clang $ export CXX=clang++ $ cmake -S foobinator \\ -B foobinator-build-release \\ -GNinja \\ -DCMAKE_BUILD_TYPE=RelWithDebInfo \\ -DCMAKE_MODULE_PATH=\"$SCORE_SDK/usr/lib/cmake/score\" \\ -DSCORE_SDK=\"$SCORE_SDK/usr\" \\ -DOSSIA_SDK=\"$OSSIA_SDK\" \\ -DCMAKE_INSTALL_PREFIX=/path/to/Documents/ossia/score/packages/my_plugin . | Run a build | . $ cmake --build foobinator-build-release $ cmake --install foobinator-build-release . This should copy the plug-in in the ossia/score/packages/&lt;your plugin&gt; folder. If everything is correct, the next time you launch score you should see your plug-in show up in the Process library :-) . Another way for fast iteration is to create a symbolic lijnk from the foobinator-build-release/plugins folder to ossia/score/packages/&lt;your plugin&gt;. This way, every time you run ninja, the binary will be updated. Note that on Windows, you must exit score if you rebuild the DLL as the operating system does not support replacing of currently loaded DLL files. ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html#building-locally-from-the-command-line",
    "relUrl": "/development/plugins/plugins-with-avendish.html#building-locally-from-the-command-line"
  },"121": {
    "doc": "Plug-ins with Avendish",
    "title": "Building locally from Qt Creator",
    "content": "Once you have a local build up-and-running, you can configure an IDE to make the edit/compile/run loop easier. We will use Qt Creator. Here is a video explanation: . In short: . | Open the CMakeLists.txt file of the source folder | Qt Creator should pick up the build folder automatically (it looks for build folders around and inside the source folder) | Set up the “Run” configuration in the project pane to run score automatically after each build | Enjoy :-) | . If you did not use the symlink method, you can easily configure Qt Creator to run the install step as deployment step in the Run pane, at the top: Add the Deployment step &gt; CMake install step. If you followed the recommendations above, this should copy the plug-in files into the score packages folder after each build, to ensure a smooth development experience. ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html#building-locally-from-qt-creator",
    "relUrl": "/development/plugins/plugins-with-avendish.html#building-locally-from-qt-creator"
  },"122": {
    "doc": "Plug-ins with Avendish",
    "title": "Plug-ins with Avendish",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/plugins/plugins-with-avendish.html",
    "relUrl": "/development/plugins/plugins-with-avendish.html"
  },"123": {
    "doc": "ADSR",
    "title": "ADSR",
    "content": ". The ADSR process allows to create an attack-decay-sustain-release envelope when an input happens. Two inputs are possible: “Hold” will sustain for as long as it is pressed. Trigger will only perform the Attack, Decay and Release parts of the curve. ",
    "url": "https://ossia.io/score-docs/processes/adsr.html",
    "relUrl": "/processes/adsr.html"
  },"124": {
    "doc": "AI Prompt Composer",
    "title": "AI Prompt Composer",
    "content": ". Build dynamic AI prompts from multiple text inputs. Perfect for interactive installations where you want prompts to change based on sensor data, user input, or other real-time information. This process takes separate text components and intelligently combines them into well-formed prompts for AI image generators, language models, or other prompt-based systems. ",
    "url": "https://ossia.io/score-docs/processes/ai-prompt-composer.html",
    "relUrl": "/processes/ai-prompt-composer.html"
  },"125": {
    "doc": "AI Prompt Composer",
    "title": "Related processes",
    "content": "Combine with AI Prompt Interpolator for smooth prompt transitions, String utilities for text processing, or Array Utilities when working with multiple modifiers. ",
    "url": "https://ossia.io/score-docs/processes/ai-prompt-composer.html#related-processes",
    "relUrl": "/processes/ai-prompt-composer.html#related-processes"
  },"126": {
    "doc": "AI Prompt Interpolator",
    "title": "AI Prompt Interpolator",
    "content": ". The AI Prompt Interpolator enables smooth transitions between different prompts, creating dynamic and evolving AI-generated content. This is essential for creating fluid, generative experiences where prompts gradually transform over time. ",
    "url": "https://ossia.io/score-docs/processes/ai-prompt-interpolator.html",
    "relUrl": "/processes/ai-prompt-interpolator.html"
  },"127": {
    "doc": "AI Prompt Interpolator",
    "title": "Overview",
    "content": "This process intelligently blends between multiple prompts while maintaining semantic coherence. It’s particularly useful for: . | Generative art installations with evolving themes | Live performances with gradual style transitions | Interactive experiences responding to user input | . It will blend over time to enable controlling prompt-based systems: given the message “castle in the sky” at t=0 and the message “oasis trees” at t=1, the output will be: . (castle in the sky: 1) (castle in the sky: 0.9), (oasis trees: 0.1) ... (castle in the sky: 0.1), (oasis trees: 0.9) (oasis trees: 1) . ",
    "url": "https://ossia.io/score-docs/processes/ai-prompt-interpolator.html#overview",
    "relUrl": "/processes/ai-prompt-interpolator.html#overview"
  },"128": {
    "doc": "AI Prompt Interpolator",
    "title": "Related Processes",
    "content": ". | AI Prompt Composer - Create structured prompts | Interpolator - General value interpolation | Tweener - Advanced easing functions | Nodes - 2D interpolation space | . ",
    "url": "https://ossia.io/score-docs/processes/ai-prompt-interpolator.html#related-processes",
    "relUrl": "/processes/ai-prompt-interpolator.html#related-processes"
  },"129": {
    "doc": "AI Recognition",
    "title": "AI Recognition",
    "content": "How to run ONNX models in score . ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html",
    "relUrl": "/processes/ai-recognition.html"
  },"130": {
    "doc": "AI Recognition",
    "title": "1. Drop an AI model process in your timeline",
    "content": "Let’s try with BlazePose Detector. It can read from a camera or image input texture, run the model, and output results in real-time. ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#1-drop-an-ai-model-process-in-your-timeline",
    "relUrl": "/processes/ai-recognition.html#1-drop-an-ai-model-process-in-your-timeline"
  },"131": {
    "doc": "AI Recognition",
    "title": "2. Download and load model",
    "content": ". | BlazePose Fullbody ONNX from Ailia Download . | Yolov8 Pose: Download . | RTMPose: Download . | . ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#2-download-and-load-model",
    "relUrl": "/processes/ai-recognition.html#2-download-and-load-model"
  },"132": {
    "doc": "AI Recognition",
    "title": "3. Add an Input camera device (or video)",
    "content": "Choose a camera . Alternatively, drag &amp; drop a video file into score, and connect it to the AI model process. ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#3-add-an-input-camera-device-or-video",
    "relUrl": "/processes/ai-recognition.html#3-add-an-input-camera-device-or-video"
  },"133": {
    "doc": "AI Recognition",
    "title": "4. Add a window device for output",
    "content": "Adjust the output window size to match your model’s output. ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#4-add-a-window-device-for-output",
    "relUrl": "/processes/ai-recognition.html#4-add-a-window-device-for-output"
  },"134": {
    "doc": "AI Recognition",
    "title": "5. Play",
    "content": "Add a trigger if you want the process to loop continuously. ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#5-play",
    "relUrl": "/processes/ai-recognition.html#5-play"
  },"135": {
    "doc": "AI Recognition",
    "title": "6. Extract keypoints",
    "content": "Each AI model outputs keypoints in a specific format. For BlazePose, refer to the official documentation: . To extract keypoints like wrist or nose, use the Object Filter process to filter these fields. | Left wrist = .keypoints[15].position[] | Right wrist = .keypoints[16].position[] | Nose = .keypoints[0].position[] | . For other models like RTMPose, here is the 26-keypoint layout: . ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#6-extract-keypoints",
    "relUrl": "/processes/ai-recognition.html#6-extract-keypoints"
  },"136": {
    "doc": "AI Recognition",
    "title": "7. Use keypoints",
    "content": "Once keypoints are extracted, you can connect them to any parameter in score for interactive control. Download score . ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#7-use-keypoints",
    "relUrl": "/processes/ai-recognition.html#7-use-keypoints"
  },"137": {
    "doc": "AI Recognition",
    "title": "Example usage of keypoints",
    "content": "You can also send keypoints over OSC to external tools like Wekinator for gesture recognition or AI-based interaction. | Use an Object Filter to extract: . | left wrist, right wrist, nose (x, y, z) with the following formula : [ .keypoints[16].position[], .keypoints[15].position[], .keypoints[0].position[] ] . | . | Combine them into a 9-value OSC message using the Array Combinor process . | Send the OSC message to wekinator:/wek/inputs | . This can be used to trigger visuals, audio, shaders, and other cool things! . ",
    "url": "https://ossia.io/score-docs/processes/ai-recognition.html#example-usage-of-keypoints",
    "relUrl": "/processes/ai-recognition.html#example-usage-of-keypoints"
  },"138": {
    "doc": "Analysis",
    "title": "Analysis processes",
    "content": "Real-time music information retrieval (MIR) processes are available, thanks to the Gist library. They allow to easily build audio-reactive visuals, by extracting meaningful parameters from a live or pre-recorded audio signal. Here is a video example of their usage: . ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#analysis-processes",
    "relUrl": "/processes/analysis.html#analysis-processes"
  },"139": {
    "doc": "Analysis",
    "title": "Envelope",
    "content": ". These processes allow to extract the volume of an audio signal. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#envelope",
    "relUrl": "/processes/analysis.html#envelope"
  },"140": {
    "doc": "Analysis",
    "title": "Onset detection",
    "content": ". These processes allow to detect hits and impacts and are useful for beat detection. The first outlet outputs the detection signal. The second outlet outputs an impulse when an onset is detected. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#onset-detection",
    "relUrl": "/processes/analysis.html#onset-detection"
  },"141": {
    "doc": "Analysis",
    "title": "Pitch detection",
    "content": ". These processes allow to estimate the pitch of a monophonic signal (between 150 and 1500 Hz). ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#pitch-detection",
    "relUrl": "/processes/analysis.html#pitch-detection"
  },"142": {
    "doc": "Analysis",
    "title": "Spectral parameters",
    "content": ". These processes allow to extract parameters related to the spectrum and the timbre of an audio signal. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#spectral-parameters",
    "relUrl": "/processes/analysis.html#spectral-parameters"
  },"143": {
    "doc": "Analysis",
    "title": "Spectrum extraction",
    "content": ". These processes convert the input audio signal in an “audio” signal containing the spectra, and are mainly useful for further processing in custom processes. ",
    "url": "https://ossia.io/score-docs/processes/analysis.html#spectrum-extraction",
    "relUrl": "/processes/analysis.html#spectrum-extraction"
  },"144": {
    "doc": "Analysis",
    "title": "Analysis",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/analysis.html",
    "relUrl": "/processes/analysis.html"
  },"145": {
    "doc": "Architecture",
    "title": "Score API documentation",
    "content": "The API documentation is available at the following link. ",
    "url": "https://ossia.io/score-docs/development/architecture.html#score-api-documentation",
    "relUrl": "/development/architecture.html#score-api-documentation"
  },"146": {
    "doc": "Architecture",
    "title": "UML model",
    "content": "A draft UML model of the software is available in the git repository, at the following link. It can be opened with Qt Creator. ",
    "url": "https://ossia.io/score-docs/development/architecture.html#uml-model",
    "relUrl": "/development/architecture.html#uml-model"
  },"147": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/architecture.html",
    "relUrl": "/development/architecture.html"
  },"148": {
    "doc": "Array utilities",
    "title": "Array combiner",
    "content": ". Try it ! . This process combines multiple input arrays in one output array through various modes: . | Sum does an element-wise sum, that is given [1,2] and [10,20] as input the output would be [11, 22]. | Append puts each array behind each other, that is given [1,2] and [10,20] as input the output would be [1, 2, 10, 20]. | Product does an element-wise product, that is given [1,2] and [10,20] as input the output would be [10, 40]. | Intersperse sequences elements in a column-major fashion, that is given [1,2,3] and [10,20,30] as input the output would be [1, 10, 2, 20, 3, 30]. | . ",
    "url": "https://ossia.io/score-docs/processes/array-utilities.html#sum",
    "relUrl": "/processes/array-utilities.html#sum"
  },"149": {
    "doc": "Array utilities",
    "title": "Array tool",
    "content": ". Try it ! . An efficient multi-tool for all your array needs. ",
    "url": "https://ossia.io/score-docs/processes/array-utilities.html#tool",
    "relUrl": "/processes/array-utilities.html#tool"
  },"150": {
    "doc": "Array utilities",
    "title": "Array utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/array-utilities.html",
    "relUrl": "/processes/array-utilities.html"
  },"151": {
    "doc": "Art-Net device",
    "title": "Art-Net / DMX device",
    "content": ". It is possible to communicate through DMX with ossia score, in order to control and automate light fixtures. The user library contains a built-in fixture library that can be added. The fixture library is based on Open Fixture Library and uses the same JSON format. If no fixtures are added, then the device will instead provide the 512 raw DMX channels. Otherwise, each fixture will appear as a node of the device. ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#art-net--dmx-device",
    "relUrl": "/devices/artnet-device.html#art-net--dmx-device"
  },"152": {
    "doc": "Art-Net device",
    "title": "Custom fixtures",
    "content": "It is possible to add your custom fixtures, following the OFL format in the user library. To do so: . | Create a fixtures folder somewhere. | Inside it, add a manufacturers.json file with the fixture brands you want to add. | . For instance: . { \"$schema\": \"https://raw.githubusercontent.com/OpenLightingProject/open-fixture-library/master/schemas/manufacturers.json\", \"my_custom_fixtures\": { \"name\": \"My custom fixtures\" } } . | Create a subfolder my_custom_fixtures | Add your fixtures JSON files to the folder. | . ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#custom-fixtures",
    "relUrl": "/devices/artnet-device.html#custom-fixtures"
  },"153": {
    "doc": "Art-Net device",
    "title": "Supported transports",
    "content": "ossia score can exchange DMX through: . ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#supported-transports",
    "relUrl": "/devices/artnet-device.html#supported-transports"
  },"154": {
    "doc": "Art-Net device",
    "title": "ArtNet",
    "content": "Note that only one ArtNet device is supported per ethernet port: for instance, it is not possible to run QLC+ and ossia score on the same ArtNet interface at the same time as they both try to open the same port (UDP port 1936). Note also that ArtNet generally requires to be on IP network 10.x.x.x with DHCP disabled! . ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#artnet",
    "relUrl": "/devices/artnet-device.html#artnet"
  },"155": {
    "doc": "Art-Net device",
    "title": "s/ACN (also known as E1.31)",
    "content": "A much cleaner IP-based protocol than ArtNet. Use it if you can :-) . ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#sacn-also-known-as-e131",
    "relUrl": "/devices/artnet-device.html#sacn-also-known-as-e131"
  },"156": {
    "doc": "Art-Net device",
    "title": "ENTTEC DMX USB Pro Mk1",
    "content": "This device only supports one universe and can only send DMX. ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#enttec-dmx-usb-pro-mk1",
    "relUrl": "/devices/artnet-device.html#enttec-dmx-usb-pro-mk1"
  },"157": {
    "doc": "Art-Net device",
    "title": "ENTTEC DMX USB Pro Mk2",
    "content": "This device supports two universes and can either send or receive DMX. ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html#enttec-dmx-usb-pro-mk2",
    "relUrl": "/devices/artnet-device.html#enttec-dmx-usb-pro-mk2"
  },"158": {
    "doc": "Art-Net device",
    "title": "Art-Net device",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/artnet-device.html",
    "relUrl": "/devices/artnet-device.html"
  },"159": {
    "doc": "Audio device",
    "title": "Audio device",
    "content": "This device allows to expose the physical inputs and outputs of the sound card as device tree nodes, which can then be used at any place in the score to route a part of the score to a specific sound card output for instance. ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html",
    "relUrl": "/devices/audio-device.html"
  },"160": {
    "doc": "Audio device",
    "title": "Audio parameters",
    "content": "It is possible to set a float value between 0 and 1 on the audio parameters, for instance to automate the global volume of a given output. Multiple processes sending audio to the same parameter will be summed. ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#audio-parameters",
    "relUrl": "/devices/audio-device.html#audio-parameters"
  },"161": {
    "doc": "Audio device",
    "title": "Device tree",
    "content": "For a sound card with two mono inputs and outputs, creating the device would look like this: . | The address audio:/out/0 will refer to the first channel on the sound card. | The addresses audio:/in/main and audio:/out/main respectively refer to the entirety of the available channels. | In a score, the root interval is routed to audio:/out/main. | The volume control at the bottom of the user interface is a shortcut to control audio:/out/main’s volume. | . ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#device-tree",
    "relUrl": "/devices/audio-device.html#device-tree"
  },"162": {
    "doc": "Audio device",
    "title": "Adding busses",
    "content": "It is possible to create busses, for instance to create stereo pairs. To do so, just add a child to the device : . Physical busses . The matrix shows which channels from the soundcard will be mapped to which channels of the port, in ascending order. For instance, the above screenshot creates a bus which will send its first channel to the second output of the soundcard, and its second channel to the fourth output of the soundcard. Virtual busses . These are abstract busses that can be used for communication within score (for instance to send the output of a set of processes to another process, to make e.g. an aux track). ",
    "url": "https://ossia.io/score-docs/devices/audio-device.html#adding-busses",
    "relUrl": "/devices/audio-device.html#adding-busses"
  },"163": {
    "doc": "Audio Effects",
    "title": "Audio Effects",
    "content": ". score comes with a built-in collection of professional audio effects that you can drag’n’drop directly into your projects. These effects are based on established DSP libraries including Lance Putnam’s Gamma library. You’ll find five main types of audio processing: . | Flanger - Classic jet-like sweeping effects | Echo - Delays and ambient spaces | Compressor - Dynamic range control with sidechain support | Limiter - Transparent level limiting | Bitcrush - Lo-fi digital destruction | . All effects are optimized for real-time performance and can be combined with Faust processes or Audio Plugins to create complex audio processing chains. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html",
    "relUrl": "/processes/audio-effects.html"
  },"164": {
    "doc": "Audio Effects",
    "title": "Flanger",
    "content": ". The classic flanger effect that you hear on countless recordings. This process mixes your original signal with a delayed copy, using an LFO to continuously modulate the delay time. The result is that signature “whoosh” sound - think jet planes or the intro to “Itchycoo Park”. You can shape the flanging effect with these controls: . Amount (0.0 - 0.01) How deep the delay modulation goes. Start around 0.001 for subtle effects, push to 0.003+ for dramatic swooshes. Delay (0.0 - 10.0 ms) The center delay time that the LFO sweeps around. Short delays (0.5-2ms) give tight flanging, longer delays approach chorus territory. Frequency (0.001 - 100.0 Hz) Speed of the sweep. Try 0.2 Hz for slow, hypnotic sweeps or crank it up to 5+ Hz for tremolo-like effects. Feed-forward (-0.99 - 0.99) Mixes the delayed signal with the original. Positive values create upward sweeps, negative creates downward swooshes. Feed-back (-0.99 - 0.99) Sends the output back into the delay line for resonance and emphasis. Higher values make the effect more pronounced. Try these settings: For that classic jet plane sound, use Amount: 0.003, Delay: 2.0ms, Frequency: 0.2Hz, Feed-forward: 0.8, Feed-back: 0.6. For a subtle chorus-like effect, dial back to Amount: 0.001, Delay: 8.0ms, Frequency: 0.1Hz, Feed-forward: 0.3, Feed-back: 0.1. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#flanger",
    "relUrl": "/processes/audio-effects.html#flanger"
  },"165": {
    "doc": "Audio Effects",
    "title": "Echo",
    "content": ". This echo effect gives you everything from tight slap delays to massive ambient washes. Unlike simple repeats, it includes filtering and soft saturation to make the echoes sound natural and musical. Delay (0.001 - 30 seconds) How long to wait before the echo appears. You get a massive range here - from short slap-back delays at 80ms up to 30-second ambient textures. Feedback (0.0 - 1.0) How much of the echo gets fed back for more repeats. Keep it low (0.2-0.3) for single echoes, push it higher for long tails that fade into ambient washes. Filter (0.0 - 1.0) A low-pass filter that makes echoes sound more natural. Lower values give you darker, warmer repeats that sit nicely in the mix without getting harsh. Dry/Wet (0.0 - 1.0) Balances your original signal with the echoes. Start around 0.2-0.3 for musical delays, or push higher for special effects. The echo includes soft saturation (using 10x tanh limiting) to prevent harsh digital clipping, and the filter sweeps from 200Hz to 3000Hz for natural-sounding repeats. Try a short slap echo with Delay: 0.08s, Feedback: 0.3, Filter: 0.7, Dry/Wet: 0.3. For massive ambient spaces, try Delay: 2.5s, Feedback: 0.6, Filter: 0.3, Dry/Wet: 0.4. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#echo",
    "relUrl": "/processes/audio-effects.html#echo"
  },"166": {
    "doc": "Audio Effects",
    "title": "Compressor",
    "content": ". A full-featured compressor that evens out your audio levels. It makes quiet parts louder and loud parts quieter, plus it supports sidechain compression for pumping effects. You get standard compressor controls: Threshold sets where compression kicks in, Ratio controls how hard it compresses (2:1 is gentle, 10:1+ is heavy limiting), Attack and Release shape the timing, and Makeup gain compensates for level reduction. The Sidechain input lets you trigger compression from external sources - connect a kick drum here for that classic pumping EDM sound. Lookahead (0.001-0.005s) helps catch fast transients transparently. Try these settings: For vocals, use Threshold: 0.6, Ratio: 3:1, Attack: 0.003s, Release: 0.1s. For sidechain pumping, connect your kick to the sidechain input and try Ratio: 8:1 with fast Attack and slower Release around 0.2s. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#compressor",
    "relUrl": "/processes/audio-effects.html#compressor"
  },"167": {
    "doc": "Audio Effects",
    "title": "Limiter",
    "content": ". A transparent brick-wall limiter that prevents clipping while maintaining musical character. Perfect for mastering chains or protecting your speakers from unexpected peaks. This uses soft limiting algorithms with hyperbolic tangent curves instead of harsh clipping. The Threshold (default 0.98) sets the maximum level, while Lookahead (0.001-0.005s) lets it anticipate peaks for smooth gain reduction. Attack should stay very fast (0.0001s) for transparent limiting, and Release (around 0.05-0.08s) controls how quickly it lets go. The Makeup gain boosts the signal before limiting - use it carefully. For master bus limiting, try Threshold: 0.95, Release: 0.05s, Lookahead: 0.003s with minimal Makeup gain. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#limiter",
    "relUrl": "/processes/audio-effects.html#limiter"
  },"168": {
    "doc": "Audio Effects",
    "title": "Bitcrush",
    "content": ". Lo-fi digital destruction for that crunchy 8-bit sound. This process reduces sample rate and bit depth to create authentic digital artifacts and aliasing. Rate (10-22,000 Hz) controls sample rate reduction - lower values give more aggressive digital artifacts. Crush (0.0-1.0) adds bit quantization for that stepped, digital distortion sound. Try Rate: 8000Hz, Crush: 0.2 for subtle lo-fi character. For extreme 8-bit destruction, push Rate down to 2000Hz and Crush up to 0.8. At Rate: 100Hz and Crush: 0.9, you get complete digital chaos. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#bitcrush",
    "relUrl": "/processes/audio-effects.html#bitcrush"
  },"169": {
    "doc": "Audio Effects",
    "title": "Related processes",
    "content": "These audio effects work great with Audio Utilities and Audio Plugins. ",
    "url": "https://ossia.io/score-docs/processes/audio-effects.html#related-processes",
    "relUrl": "/processes/audio-effects.html#related-processes"
  },"170": {
    "doc": "Audio Particles",
    "title": "Audio Particles",
    "content": ". A granular synthesizer that creates swarms of audio particles by randomly triggering samples from a folder. Think of it as controlled chaos: you set the rules, and Audio Particles creates organic, ever-changing textures. Perfect for ambient soundscapes, percussive textures, or any time you want to transform a collection of samples into something completely new and alive. ",
    "url": "https://ossia.io/score-docs/processes/audio-particles.html",
    "relUrl": "/processes/audio-particles.html"
  },"171": {
    "doc": "Audio Particles",
    "title": "How it works",
    "content": "Audio Particles scans a folder for .wav files and randomly triggers them across multiple output channels. Each “particle” is a brief playback of one of your samples, scattered across time and space according to your settings. Folder - Point this to any folder containing .wav files Your samples become the raw material for particle generation. Mix and match different types of sounds - percussion hits, field recordings, vocal fragments, synth stabs. Channels (0-128, default 16) How many output channels to scatter particles across. More channels = wider spatial distribution. Perfect for surround sound or feeding into DBAP spatialization. Frequency (0.001-30 Hz, default 0.2) Rate of particle generation. Low values create sparse, meditative textures. High values build dense clouds of sound. Density (0.001-1.0, default 0.7) Probability that a particle actually triggers when scheduled. Lower density creates more irregular, organic timing patterns. ",
    "url": "https://ossia.io/score-docs/processes/audio-particles.html#how-it-works",
    "relUrl": "/processes/audio-particles.html#how-it-works"
  },"172": {
    "doc": "Audio Particles",
    "title": "Creative applications",
    "content": "Ambient textures: Load a folder of field recordings, set Frequency to 0.1Hz, Density to 0.3, and let it create sparse, atmospheric soundscapes. Rhythmic elements: Use short percussion samples with higher Frequency (2-5Hz) and high Density (0.9) for polyrhythmic patterns. Vocal clouds: Process speech recordings into ethereal, whispered textures by fragmenting words into particles. Orchestral dispersion: Take orchestral samples and scatter them across many channels for impossible ensemble effects. ",
    "url": "https://ossia.io/score-docs/processes/audio-particles.html#creative-applications",
    "relUrl": "/processes/audio-particles.html#creative-applications"
  },"173": {
    "doc": "Audio Particles",
    "title": "Technical details",
    "content": "Audio Particles uses exponential distribution for organic timing - particles don’t arrive on a rigid grid but with natural, breathing rhythms. Each sample gets randomly assigned to output channels, and multiple samples can play simultaneously for rich polyphonic textures. The process automatically monitors your folder for changes, so you can add new samples while performing and they’ll become part of the particle pool immediately. Works beautifully with Matrix routing for sending particles to different speaker arrays, or chain with Audio Effects for processed particle clouds. ",
    "url": "https://ossia.io/score-docs/processes/audio-particles.html#technical-details",
    "relUrl": "/processes/audio-particles.html#technical-details"
  },"174": {
    "doc": "Audio plugins",
    "title": "Audio plug-in support",
    "content": ". Plug-ins can simply be dropped from the process library), under the Audio section, into the main view. If the plug-in has a custom UI, it is possible to make it show up with the small “window” icon on the plug-in header. For plug-ins with many controls, controls won’t show up by default in the score user interface. When changed from the plug-in UI, if any, will show up in score and be automatable. The little “x” allows to remove an unwanted parameter. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#audio-plug-in-support",
    "relUrl": "/processes/audio-plugins.html#audio-plug-in-support"
  },"175": {
    "doc": "Audio plugins",
    "title": "Common formats: CLAP, VST, VST3, LV2, JSFX",
    "content": "Common plug-in formats are supported: . | VST 2.4 on all platforms. | VST 3 on all platforms. | CLAP on all platforms. | LV2 on Linux. | JSFX on all platforms. | AirWindows on all platforms. AirWindows are a set of built-in plug-ins that cover an extremely wide range of useful audio effects: filters, dynamics, distortions, reverbs, etc. | . Plug-ins are started automatically on startup. If for some reason this must be disabled, because the scanning process causes issues, one can set the SCORE_DISABLE_AUDIOPLUGINS=1 environment variable. Since LV2 plug-ins sometimes take a very long time to scan, it is possible to disable them specifically with SCORE_DISABLE_LV2=1. Already scanned plug-ins will still be available for VST and VST3. It is possible to save and reload presets ; however the built-in VST presets are not supported yet. VST2 plug-ins can be rescanned from the preferences. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#common-formats-clap-vst-vst3-lv2-jsfx",
    "relUrl": "/processes/audio-plugins.html#common-formats-clap-vst-vst3-lv2-jsfx"
  },"176": {
    "doc": "Audio plugins",
    "title": "Controlling VST parameters",
    "content": "To be able to automate and connect VST parameters to other parts of the session, it is necessary to make them visible in the nodes. For plug-ins with less than a dozen parameters, they will always be shown by default. For plug-ins with more parameters, this is however opt-in. The first button allows to show / hide the audio plug-in UI. The second, when enabled, means that the plug-in’s parameters will be checked for changes: whenever a value changes, it will appear in the score UI and be open to automation, etc. Here is the complete procedure: . This is currently only implemented for VST2, other plug-in APIs have all their parameters shown until the feature is implemented there too. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#controlling-vst-parameters",
    "relUrl": "/processes/audio-plugins.html#controlling-vst-parameters"
  },"177": {
    "doc": "Audio plugins",
    "title": "Adding JSFX plug-ins",
    "content": "JSFX plug-ins can be added in the user library. Score will look for files ending with the .jsfx extension. If you are on Unix or a system with bash, you can rename the JSFX plugins without extensions this way: . $ find . -type f ! -name '*.*' -exec perl-rename 's/$/.jsfx/' {} \\; . Here are some links to free JSFX collections: . | https://github.com/chkhld/jsfx | https://github.com/JoepVanlier/JSFX | https://geraintluff.github.io/jsfx | https://github.com/Justin-Johnson/ReJJ | . Some JSFX plug-ins need separate data files. To ensure that they can find it, the following organization is recommended: . jsfx_folder/Effects/foo/effect.jsfx jsfx_folder/Data/&lt;matching data files&gt; . For instance, a complete path on a Mac with the default user library location would look like: . /Users/you/Documents/ossia/score/packages/jsfx/Effects/dynamics/general_dynamics.jsfx /Users/you/Documents/ossia/score/packages/jsfx/Data/amp_models/SomeImpulse.wav . ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#jsfx",
    "relUrl": "/processes/audio-plugins.html#jsfx"
  },"178": {
    "doc": "Audio plugins",
    "title": "Advanced plug-in and extensions formats",
    "content": "It is also possible to use less common systems for audio processing: . | Faust DSPs | Pure Data patches | Javascript | Math expressions | Custom C++ plug-ins | . Some of these plug-in systems, like Faust are source-based: that is, score will compile the source code of the plug-in directly, which can take a few seconds when dropping the plug-in in the session. Preset support for these plug-ins is a work-in-progress. ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html#advanced-plug-in-and-extensions-formats",
    "relUrl": "/processes/audio-plugins.html#advanced-plug-in-and-extensions-formats"
  },"179": {
    "doc": "Audio plugins",
    "title": "Audio plugins",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-plugins.html",
    "relUrl": "/processes/audio-plugins.html"
  },"180": {
    "doc": "Audio routing",
    "title": "Audio routing",
    "content": ". | There is an implicit routing from child process to parent interval, and from interval to parent scenario, recursively up to the top of the score. | The audio output of the top interval is routed by default to the main stereo output of the audio interface defined in Audio Preferences. | When connecting an audio outlet to another audio inlet, propagation is removed. This means that the dry output of the source process will not be mixed in its parent interval. This can be toggled by selecting the port, in the inspector. | . ",
    "url": "https://ossia.io/score-docs/in-depth/audio-routing.html",
    "relUrl": "/in-depth/audio-routing.html"
  },"181": {
    "doc": "Audio utilities",
    "title": "Gain",
    "content": ". This plug-in simply multiplies its input audio by a gain value. ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#gain",
    "relUrl": "/processes/audio-utilities.html#gain"
  },"182": {
    "doc": "Audio utilities",
    "title": "Metronome",
    "content": ". This plug-in outputs a metronome sound, based on the time signature of its parent interval. The metronome sounds used can be changed: they are in the user library, in the folder “Util” ; the process looks for files named metro_tick.wav and metro_tock.wav. The second outlet outputs an impulse on each tick. ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#metronome",
    "relUrl": "/processes/audio-utilities.html#metronome"
  },"183": {
    "doc": "Audio utilities",
    "title": "Stereo merger",
    "content": ". This process combines stereo audio signal from N inlets, into one outlet whose channels correspond to the inputs’s channels one after each other (mono input channels are duplicated ; no input means silence on the output). That is, in the example below, the output of the Merger process will be a 4-channel signal with: . | Channel 0, 1: the audio generator (originally mono). | Channel 2, 3: the drum loop. | . ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html#stereo-merger",
    "relUrl": "/processes/audio-utilities.html#stereo-merger"
  },"184": {
    "doc": "Audio utilities",
    "title": "Audio utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-utilities.html",
    "relUrl": "/processes/audio-utilities.html"
  },"185": {
    "doc": "Audio looper",
    "title": "Audio Looper",
    "content": ". Different options are available when you use the audio looper: the operation mode and the passthrough. | If passthrough is enabled, while recording and overdubbing, the input audio will be copied to the output of the looper. | The looper’s state change can be quantized. | In the inspector, it is possible to make the looper automatically change mode after a fixed amount of bars instead of waiting on an automated change: the second “loop” parameter will control the state on which the looper moves after N bars in the initial state. | . ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#audio-looper",
    "relUrl": "/processes/audio-looper.html#audio-looper"
  },"186": {
    "doc": "Audio looper",
    "title": "Play",
    "content": "Play what the looper recorded. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#play",
    "relUrl": "/processes/audio-looper.html#play"
  },"187": {
    "doc": "Audio looper",
    "title": "Recording",
    "content": "Record the actual sound the looper is going to loop to. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#recording",
    "relUrl": "/processes/audio-looper.html#recording"
  },"188": {
    "doc": "Audio looper",
    "title": "Overdub",
    "content": "Record on top of the already recorded sound. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#overdub",
    "relUrl": "/processes/audio-looper.html#overdub"
  },"189": {
    "doc": "Audio looper",
    "title": "Stop",
    "content": "Output nothing. ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html#stop",
    "relUrl": "/processes/audio-looper.html#stop"
  },"190": {
    "doc": "Audio looper",
    "title": "Audio looper",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/audio-looper.html",
    "relUrl": "/processes/audio-looper.html"
  },"191": {
    "doc": "Automation (float)",
    "title": "Automation (float)",
    "content": ". The Automation (float) process allows to control single value parameter using a breakpoints function. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html",
    "relUrl": "/processes/automation_float.html"
  },"192": {
    "doc": "Automation (float)",
    "title": "Basic editing",
    "content": "Create new points on curve . Multiple points can be added on an automation. To add a point, double-click in the automation slot to create a point under the mouse cursor. You can also create a new point using Ctrl+click(Win / Linux) or⌘+click(Mac) in the automation’s slot. Remove points from curve . To delete a point from an automation, click on a point to select it, then from its contextual menu select Remove. Multiple points and attached segments can be selected and removed at once using the Remove contextual menu entry. Edit points . To edit a point value of position in time, select it using the mouse and move it along the x axis to adjust in position in time, or along the y axis to adjust its value. You will note that when selecting a point, its value gets displayed next to the mouse cursor . For fine control, you can also use the dedicated number boxes from the inspector. Click on a point to select it and display its inspector then use the value number box to adjust to the desired value. Adjust segment’s curve . Power type segments (default) can be added a curve factor. To do so, click a segment and use Shift+Drag. Dragging the curve upward add a log-like curvature to the segment, while dragging downward add a exp-like curvature. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#basic-editing",
    "relUrl": "/processes/automation_float.html#basic-editing"
  },"193": {
    "doc": "Automation (float)",
    "title": "Segment shapes",
    "content": "Segments between two points can be set to various predefined shapes. To do so, click a segment and from its contextual menu, choose the desired segment shape in the Type category. Shapes include: . | Power (default) | Linear (a slightly optimized version of Power with zero curve factor) | Standard Easing curves | . | backIn | quadraticIn | quarticIn | sineIn | exponentialIn | . | backOut | quadraticOut | quarticOut | sineOut | exponentialOut | . | backInOut | quadraticInOut | quarticInOut | sineInOut | exponentialInOut | . |   |   |   |   |   | . | bounceIn | cubicIn | quinticIn | circularIn | elasticIn | . | bounceOut | cubicOut | quinticOut | circularOut | elasticOut | . | bounceInOut | cubicInOut | quinticInOut | circularInOut | elasticInOut | . |   |   |   |   |   | . | PerlinInOut |   |   |   |   | . ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#segment-shapes",
    "relUrl": "/processes/automation_float.html#segment-shapes"
  },"194": {
    "doc": "Automation (float)",
    "title": "Freehand function",
    "content": "Automation’s function can be hand-drawn using Alt+Drag in Automation editor. Drawn function will get optimized and transformed onto a beak-point function on mouse release so you can edit various points individually. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#freehand-function",
    "relUrl": "/processes/automation_float.html#freehand-function"
  },"195": {
    "doc": "Automation (float)",
    "title": "Advanced edits",
    "content": "Lock between points . By default, moving a point in the automation is limited horizontally by previous and next points’ position in automation. This can be turned on and off using the Lock between points option in the automation contextual menu. When off, points can be freely moved along the whole automation’s slot. Suppress on overlap . When Lock between points option is unset, crossing adjacent points can be handled in two different ways. By default, crossing an adjacent point in automation will remove this point. This can be turned off using by unsetting the option in the automation’s contextual menu. When off, moved point will get inserted at its new position without removing other points in automation. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#advanced-edits",
    "relUrl": "/processes/automation_float.html#advanced-edits"
  },"196": {
    "doc": "Automation (float)",
    "title": "Tween mode",
    "content": "Tweening allows an automation to ramp smoothly from the running value of an address which was assigned to, during the first segment. This means that, assuming an OSC address /foo, if tweening is enabled, no matter the visual “start value” of the first point of the automation curve, the actual first point during execution will be taken from the value of /foo when the score reaches that part. This allows smooth transitions from a live control, to a scripted one. ",
    "url": "https://ossia.io/score-docs/processes/automation_float.html#tween-mode",
    "relUrl": "/processes/automation_float.html#tween-mode"
  },"197": {
    "doc": "Automations",
    "title": "Automations",
    "content": "Automations are a specific kind of score process, which will change the value of a parameter in time according to a visual curve. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html",
    "relUrl": "/in-depth/automations.html"
  },"198": {
    "doc": "Automations",
    "title": "Automation types",
    "content": ". | Normal, 1D automation: [[automation (float) | documented here]]. | . | 2D automation: documented here. | Color automation: documented here. | . ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#automation-types",
    "relUrl": "/in-depth/automations.html#automation-types"
  },"199": {
    "doc": "Automations",
    "title": "Creating automations",
    "content": "It is possible to create automations in various ways besides dropping an automation process from the library: . | By drag’n’dropping a parameter from the Device explorer to the score. | By using the Interpolate States feature. | By right-clicking on a value (green) port and pressing the “Create Automation” button. | . ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#creating-automations",
    "relUrl": "/in-depth/automations.html#creating-automations"
  },"200": {
    "doc": "Automations",
    "title": "Tweening",
    "content": "Automations can be tweened: that is, instead of starting from a fixed value, the automation can instead ramp from the current value of the parameter it is automating, in order to allow for smooth transitions. Check the inspector to enable the feature. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#tweening",
    "relUrl": "/in-depth/automations.html#tweening"
  },"201": {
    "doc": "Automations",
    "title": "Units",
    "content": "Automations can use the ossia address and unit system. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#units",
    "relUrl": "/in-depth/automations.html#units"
  },"202": {
    "doc": "Automations",
    "title": "Recording",
    "content": "It is possible to record messages from external devices as automations. See also the preferences for various options concerning the way these automations are recorded. ",
    "url": "https://ossia.io/score-docs/in-depth/automations.html#recording",
    "relUrl": "/in-depth/automations.html#recording"
  },"203": {
    "doc": "BarrVerb",
    "title": "BarrVerb",
    "content": ". BarrVerb is a vintage-inspired digital reverb effect based on the classic Alesis MIDIVerb algorithms. It recreates the distinctive sound of 1980s digital reverbs, perfect for retro aesthetics, creative sound design, and adding character to modern productions. ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html",
    "relUrl": "/processes/barrverb.html"
  },"204": {
    "doc": "BarrVerb",
    "title": "Overview",
    "content": "BarrVerb provides: . | Authentic vintage digital reverb algorithms | Multiple reverb types and settings | Real-time parameter control | CPU-efficient implementation | Classic 1980s digital reverb character | . Based on the open-source BarrVerb project, which recreates the algorithms from the legendary Alesis MIDIVerb series. ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html#overview",
    "relUrl": "/processes/barrverb.html#overview"
  },"205": {
    "doc": "BarrVerb",
    "title": "Inputs",
    "content": "| Port | Type | Description |   |   | . | Audio In | Audio | Input audio signal |   |   | . | Program | Dropdown | Reverb algorithm/preset | “Hall 1” | See Programs | . | Dry/Wet | Float (0-1) | Balance between dry and reverb signal |   |   | . ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html#inputs",
    "relUrl": "/processes/barrverb.html#inputs"
  },"206": {
    "doc": "BarrVerb",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Audio Out | Audio | Processed audio with reverb | . ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html#outputs",
    "relUrl": "/processes/barrverb.html#outputs"
  },"207": {
    "doc": "BarrVerb",
    "title": "Historical Context",
    "content": "The Alesis MIDIVerb series (1987-1990s) was revolutionary for making digital reverb affordable for home studios. BarrVerb preserves this legacy while adding modern convenience and automation capabilities. ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html#historical-context",
    "relUrl": "/processes/barrverb.html#historical-context"
  },"208": {
    "doc": "BarrVerb",
    "title": "Related Processes",
    "content": ". | Audio Effects - Other reverb and effects | Delay - Echo and delay effects | Chorus - Modulated effects | BitCrusher - Vintage digital artifacts | . ",
    "url": "https://ossia.io/score-docs/processes/barrverb.html#related-processes",
    "relUrl": "/processes/barrverb.html#related-processes"
  },"209": {
    "doc": "BLE device",
    "title": "BLE device",
    "content": ". The BLE device enables ossia to communicate over Bluetooth Low Energy, a protocol common across IoT sensors. There are two ways to use the protocol: . | If one simply selects the “BLE” protocol without selecting a specific Bluetooth identifier, then the device will not connec to any specific device and will instead display all the advertisments of the surrounding devices. | . | If one selects a specific device, then a BLE connection will be established. Note that this can often take on the order of 5 - 10 seconds depending on the BLE device performance and capabilities. This will grant access to all the GATT services provided by the device. | . ",
    "url": "https://ossia.io/score-docs/devices/ble-device.html",
    "relUrl": "/devices/ble-device.html"
  },"210": {
    "doc": "Integrating with Blender",
    "title": "Integrating with Blender",
    "content": "It is possible to control most properties of a Blender project’s nodal system through the NodeOSC addon, available from here: https://github.com/maybites/blender.NodeOSC. ",
    "url": "https://ossia.io/score-docs/integrations/blender.html",
    "relUrl": "/integrations/blender.html"
  },"211": {
    "doc": "Integrating with Blender",
    "title": "Setup",
    "content": ". | Download the NodeOSC add-on’s last version (this has been tested with version 2.4.0) . | Install it in blender: Edit &gt; Preferences&gt; Add-ons &gt; Install (top-right button) and enable it by checking its checkmark: . | . | Check that it is activated in the drop-down here: | . ",
    "url": "https://ossia.io/score-docs/integrations/blender.html#setup",
    "relUrl": "/integrations/blender.html#setup"
  },"212": {
    "doc": "Integrating with Blender",
    "title": "Usage",
    "content": "The complete documentation of NodeOSC is available at this link. If you simply aim to control a node setting through OSC, here is how you can do it: . | Open your material in the Nodes editor of Blender: | . | Select the parameter you aim to control over OSC, right-click on it and select “Copy full data path”. | . | In the NodeOSC panel (if it is hidden, enable it through the little arrow on the left of the object tree), select “Create new message handler”: | . | Paste the data path you copied in the “datapath” field. | . | Set the OSC address you want in the first field and toggle “Start”. | . | From score, you can now send OSC messages to this address: first add a matching OSC device: | . | Then add a matching OSC address: | . And from now on, changes to blender:/lightness in score will apply in teal-time to Blender! . ",
    "url": "https://ossia.io/score-docs/integrations/blender.html#usage",
    "relUrl": "/integrations/blender.html#usage"
  },"213": {
    "doc": "Breaking the timeline",
    "title": "Breaking the timeline",
    "content": "In previous steps of this Quick Start guide, we used score to write simple scenario use cases following a timeline-based approach pretty similar to the one found in usual DAW software. While such an approach allows us to write very precise temporal developments of a scenario, it may also hit some limits in live performance situation or installation where a much more flexible approach is required. score offers a number of features to bridge the gap between different approaches and thus combine timeline-based workflow and cue-based workflow. One of them is the use of trigger points. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html",
    "relUrl": "/quick-start/breaking-the-timeline.html"
  },"214": {
    "doc": "Breaking the timeline",
    "title": "Enabling triggers",
    "content": "Introducing trigger points in your scenario allows us to keep organizing things in time while allowing interactive triggering of elements: when executing the scenario, parts of the scenario starting with a trigger point will be put “on hold” until they get triggered. When triggered, following automations and states will get executed at the speed and duration specified in the scenario. To add a trigger point, simply select a state on the scenario, then from its inspector, toggle on the trigger icon. When turning on the trigger, you can see a T-like icon appearing on top of the selected state. You can also note that a dashed line appears on top of the preceding automation slot. This indicates that the duration of the preceding automations is now undefined: preceding automations will get executed up until the trigger is, well… triggered. In the example above, the scenario start with a simple fade-in. Notice that it gets executed as the scenario play-head goes across the automation slot. While the scenario play-head continues its progression, you will notice though that the green progression bar at the top of the automation stops as it reaches the trigger point. Execution of the following automations is then on hold until the trigger point is triggered by a mouse click. From then, execution follows its course until the next trigger point in the scenario. Here again, execution is put on hold until trigger point is clicked by mouse. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html#enabling-triggers",
    "relUrl": "/quick-start/breaking-the-timeline.html#enabling-triggers"
  },"215": {
    "doc": "Breaking the timeline",
    "title": "Triggers remote control",
    "content": "In the example above, we used the mouse to trigger the followup of the scenario execution. While convenient for demo purposes, you are more likely to rely on other inputs in creation situation such as some controller gear. You may use any parameter from your device as an input for trigger points. To set an input for a trigger point, just grab the desired parameter in the Device explorer and drop it on the trigger icon. In the example above, we use as an input one button of a Korg nanoKontrol Midi controller. When done, you will see in the inspector the address of the dropped parameter in the address field. You may also drop the parameter on the address field of the trigger point inspector. When playing your scenario, part of your scenario will now get triggered as you press the dedicated button on your controller. ",
    "url": "https://ossia.io/score-docs/quick-start/breaking-the-timeline.html#triggers-remote-control",
    "relUrl": "/quick-start/breaking-the-timeline.html#triggers-remote-control"
  },"216": {
    "doc": "Building from source",
    "title": "Building from source",
    "content": "Depending on the reasons that landed you on this page, you may want to look at the following instructions : . | If you want to package ossia score for a Linux distribution or something like that, please refer to Packaging score for Linux. | If you are an user of score and want to build the latest version, please refer to Creating a release build. | If you want to develop score then follow Hacking on score. | . ",
    "url": "https://ossia.io/score-docs/development/build-from-source.html",
    "relUrl": "/development/build-from-source.html"
  },"217": {
    "doc": "Bytebeat",
    "title": "What is bytebeat?",
    "content": ". Bytebeat is a minimal programming language for synthetic sounds, using various bit-level properties of numbers. Here are multiple guides to that language: . | Countercomplex’s blogpost which introduced Bytebeat | The absolute beginner’s guide to coding Bytebeats! | Greggman’s implementation | Radavis’s implementation | . ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#what-is-bytebeat",
    "relUrl": "/processes/bytebeat.html#what-is-bytebeat"
  },"218": {
    "doc": "Bytebeat",
    "title": "Usage",
    "content": "Bytebeat code can be edited when pressing the small “window” button on the process. Each line of code can be treated independently. The bytebeat code is compiled with a C++ compiler, so technically it’s possible to go a little bit outside the bounds of traditional beats ; in particular, if the SDK is installed, the &lt;cmath&gt; C++ header will be available. ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#usage",
    "relUrl": "/processes/bytebeat.html#usage"
  },"219": {
    "doc": "Bytebeat",
    "title": "Examples",
    "content": ". | A simple yet efficient tune: (((t&lt;&lt;1)^((t&lt;&lt;1)+(t&gt;&gt;7)&amp;t&gt;&gt;12))|t&gt;&gt;(4-(1^7&amp;(t&gt;&gt;19)))|t&gt;&gt;7) . | Lots of examples are available at the following link (they are partly backed up below for reference - note that due to the most used implementation being based on javascript, some changes to the code may be necessary, e.g. going from Math.abs to abs). | . (t%255&amp;t)-(t&gt;&gt;13&amp;t) (t&amp;t%255)-(t&gt;&gt;13&amp;(t%(t&gt;&gt;8|t&gt;&gt;16))) t*(t&gt;&gt;10&amp;((t&gt;&gt;16)+1)) //cycles through all t*(t&gt;&gt;10&amp;) melodies, like the 42 melody (t&gt;&gt;10)^(t&gt;&gt;14)|(t&gt;&gt;12)*42319 //basic rng w/ slight bias to fliping between high and low t&gt;&gt;t //odd thing (t&gt;&gt;8&amp;t)*t //chaotic (t&gt;&gt;13&amp;t)*(t&gt;&gt;8) //Slower version, has interesting properties (t&gt;&gt;8&amp;t)*(t&gt;&gt;15&amp;t) //Ambient (t%(t&gt;&gt;8|t&gt;&gt;16))^t //mod fractal tree cycles through different rhythms t%(t&gt;&gt;8|t&gt;&gt;16) //Acts like t and can be used for cool effect. Generates interesting and infinite rhythm variations. -0.99999999*t*t //Add more 9s to make slower, remove to make faster. t%(t&gt;&gt;13&amp;t) //Quiet, do -1 for to make louder and change the rhythm slightly. ((t&gt;&gt;8&amp;t&gt;&gt;4)&gt;&gt;(t&gt;&gt;16&amp;t&gt;&gt;8))*t //Not really sure. (((t*t) &amp; t&gt;&gt;8)/t)-1 //t&gt;&gt;8&amp;t variation? t%(t&gt;&gt;8^t&gt;&gt;4) // 11 khz only t%(t&gt;&gt;11^t&gt;&gt;12) //Another t like formula. Also a sweet 11khz song t%(t&gt;&gt;4^t&gt;&gt;16) // 22 khz only t*(t&gt;&gt;(t&gt;&gt;13&amp;t)) //i don't even (t-(t&gt;&gt;4&amp;t&gt;&gt;8)&amp;t&gt;&gt;12)-1 //The 8-bit echo, to play with, edit t&gt;&gt;12 to a number. Powers of 2 give square waves, powers of 2-1 give sawtooth, others are from t&gt;&gt;8&amp;t. Change t&gt;&gt;12 to t&gt;&gt;n to speed up or slow down. Remove -1 for starting quiet. (((t%(t&gt;&gt;16|t&gt;&gt;8))&gt;&gt;2)&amp;t)-1 //WARNING LOUD! Some kind of glitchcore thing? (((t%(t&gt;&gt;1|t&gt;&gt;9))&gt;&gt;2)&amp;t)-1 //Variation on above. (((t &amp; t&gt;&gt;8)-(t&gt;&gt;13&amp;t))&amp;((t &amp; t&gt;&gt;8)-(t&gt;&gt;13)))^(t&gt;&gt;8&amp;t) //Differences t&lt;&lt;((t&gt;&gt;8&amp;t)|(t&gt;&gt;14&amp;t)) //strange rhythms (t&lt;&lt;(t/(t&gt;&gt;8&amp;t))) //(t&gt;&gt;8&amp;t)-1 chaos remix t&lt;&lt;((t&gt;&gt;1|t&gt;&gt;8)^(t&gt;&gt;13)) //call and respond, 11kHz t&lt;&lt;((t&gt;&gt;1|t&gt;&gt;8)*(t&gt;&gt;13&amp;t&gt;&gt;12)) //call and respond 2, 11kHz t&lt;&lt;(t&gt;&gt;8&amp;(t/(t&gt;&gt;10&amp;t))) //another chaos remix t/(t%(t&gt;&gt;8|t&gt;&gt;16)) //8 or 11khz best, extremely loud grinding machine (t&gt;&gt;8&amp;t&gt;&gt;16)*t&gt;&gt;4 //32kHz, super Sierpinski scale (t &amp; (t&gt;&gt;15+(t&gt;&gt;8&amp;t)))*t //quarternoisemachine (t*(t&gt;&gt;5|t&gt;&gt;8))&gt;&gt;(t&gt;&gt;16&amp;t) //tejeez's t&gt;&gt;5|t&gt;&gt;8 song, edited to last forever and be scariers ((t&gt;&gt;8&amp;t)-(t&gt;&gt;3&amp;t&gt;&gt;8|t&gt;&gt;16))&amp;128 //Pulse wave heaven, General formula: ((BYTEBEAT1)-(BYTEBEAT2))&amp;MULTOF2, bytebeat1 can be just \"1\" (t^t&gt;&gt;8)*(t&gt;&gt;16&amp;t) //dance of the fractals (t*t)/(t^t&gt;&gt;12) //Voice changes ((t*t)/(t^t&gt;&gt;8))&amp;t //fractal heaven (t&gt;&gt;4 &amp; t&gt;&gt;8)*(t&gt;&gt;16&amp;t) //t&gt;&gt;4&amp;t&gt;&gt;8 builder (t&gt;&gt;4 &amp; t&gt;&gt;8)/(t&gt;&gt;16&amp;t) //dialtones ((2*(t&amp;1)-1)*t)-(t&gt;&gt;8) //weaoowwwoooooiiinnn (t&gt;&gt;5)*((t&amp;1)+(t&gt;&gt;16)) //eeclicks, change t&gt;&gt;16 to t&gt;&gt;16&amp;t for a variation. (((sin(t*t/10000000))&gt;0.5)-1)*t //speedupupup (((-t&amp;t&gt;&gt;12)/32)-1)*t //filterspinsky (((-t&amp;128)/64)-1)*t //triangle wave, todo: find a way to allow for any pitch. sin(t/40)&gt;0.5\\?t:-t //tertiary operator maddness sin(t/5+(sin(t/5))+t/1000)*64+t/2500 //wowaowowao sin(t/5+((sin(t/5)/(t/(4000*(t&gt;&gt;8^t&gt;&gt;4))))))*64+128 //signal to noise ratio (sin(sin(t/5)+t*t/(t&gt;&gt;8^t&gt;&gt;4))*100)+128 //sine wave harmonics and such (t*t)/(t&gt;&gt;8&amp;t) //signal decay2 t*t/(t&gt;&gt;n) //replace n with a smallish number (1 to 16 best) for a variety of effects. (t*t/(1+(t&gt;&gt;9&amp;t&gt;&gt;8)))&amp;128 //everything is broken t*(1/t*t)^t //fire crackles t%(t&gt;&gt;10&amp;t) (t &amp; t&gt;&gt;8)-(t&gt;&gt;16&amp;t) (sin(sin(t/10)*t*t/10000000000)*32)+128 //generic: (sin(sin(t/pitch))*t*t/speed)*amplitude)+128 (sin(tan(t/50)*t*t/10000000000)*32)+128 ((sin(t/10000)*t)&gt;&gt;4&amp;t&gt;&gt;8)*t //Speedupslowdown (sin(t/10000)*t&gt;&gt;n)/(sin(t/10001)) //t&gt;&gt;n like formula, where n is which t&gt;&gt;_ to act like. It's glitchy-ish. (sin(t/10000)*t&gt;&gt;8)/(sin(t/10001))&amp;t //Example of formula (sin(t/10)*(((t&gt;&gt;8&amp;t)%256)/2)+128) //non-cliping, sine form of t&gt;&gt;8&amp;t sin(t/(1+(t&gt;&gt;8&amp;t&gt;&gt;13)))*64+128 //Sine wave heaven t*t/(10000*(t&gt;&gt;8&amp;t&gt;&gt;13)) (t&amp;(t&gt;&gt;7|t&gt;&gt;8|t&gt;&gt;16)^t)*t w=Math.pow(2,t&gt;&gt;8&amp;t&gt;&gt;13),(128/w&amp;t)&gt;1?w*t:-w*(t+1) //Triangle wave song. t*((t/401)^(t/400)) //it wont stop (t&gt;&gt;(t&gt;&gt;(t/4)))^t //Chain dance ((t/256)&gt;&gt;(t&gt;&gt;t)) //Slow n Noisy chain (sin(t/10+sin(t*Math.pow(2,t&gt;&gt;10))))*64+128 //creepy t/64&gt;&gt;(t&gt;&gt;t/4) //ambient (t%256)&gt;(cos(t/40000)*128+128)?0:128 //conditional expression experiment. Pulse wave duty cycle cycler t*((t&gt;&gt;8&amp;t&gt;&gt;3)&gt;&gt;(t&gt;&gt;16&amp;t)) //Use with below (t*(t&gt;&gt;8&amp;t&gt;&gt;3))&gt;&gt;(t&gt;&gt;16&amp;t) //Use with above (t*((t%(t&gt;&gt;8|t&gt;&gt;16))&gt;&gt;8|t&gt;&gt;5))^(t*(t&gt;&gt;5)) //break t%(t&gt;&gt;(t/4)) //ambient sin(t/(t&gt;&gt;8&amp;t&amp;t&gt;&gt;13))&gt;0?128:64 //more conditional expressions! sin(t/((t&gt;&gt;8&amp;t&gt;&gt;7)%3))&gt;0?128:0 //morse code dialoge (sin(t/((t&gt;&gt;8&amp;t&gt;&gt;7)%3))*64)+128 //alternate version (uses sine waves instead of square) (t*(-(t&gt;&gt;8|t|t&gt;&gt;9|t&gt;&gt;13)))^t //ststututterter ((Math.abs(sin(t/(\"34543\"[t&gt;&gt;13&amp;3])))+sin(t/\"23432\"[t&gt;&gt;14&amp;3])))*40+128 //basic array thing (((t/91)&amp;t)^((t/90)&amp;t))-1 //waiver (t*t)/(t&gt;&gt;13 ^ t&gt;&gt;8) //glissando (t/(t%(t&gt;&gt;8|t&gt;&gt;16)))|(t*t/(t&gt;&gt;8|t&gt;&gt;13)) //(t/(t%(t&gt;&gt;8|t&gt;&gt;16))) and (t*t/(t&gt;&gt;8|t&gt;&gt;13)) mashup (t/(t%(t&gt;&gt;8|t&gt;&gt;16)))|(t*t/(t&gt;&gt;8|t&gt;&gt;16)) //variation w=t/10,sin((w&gt;&gt;8&amp;w))*64+128 //run (sin(sin(t/10)+t/(1000-(t&gt;&gt;10|t&gt;&gt;12)))*64)+128 //click and pop (sin(sin(t/10)+t/(1000-(t&gt;&gt;10^t&gt;&gt;12)))*64)+128 //click and pop 2 (sin(sin(t/10)+t/(1000-(t&gt;&gt;10^t&gt;&gt;12)))*64)^(sin(sin(t/10)+t/(1000-(t&gt;&gt;10|t&gt;&gt;12)))*64)+128 //Distort (sin(sin(t/10)+t/(1000-(t&gt;&gt;10&amp;t&gt;&gt;4))))*64+128 //bit crusher t&gt;&gt;(t%(t&gt;&gt;1&amp;t)) //Broken Signal sin((t%(t&gt;&gt;8|t&gt;&gt;16))/10)*64+128 //click and pop 3 w=(sin(t&gt;&gt;16)*6890866887),(t&gt;&gt;5|t&gt;&gt;8)*(t|w) //RNG changes stuff. Replace the big number with another for a variation. w=t%(t&gt;&gt;8|t&gt;&gt;16),b=w&gt;&gt;5|t&gt;&gt;8,(b*t)^(t*(t&gt;&gt;8)) //what's left behind t*t/(t&gt;&gt;8&amp;t&gt;&gt;4) //chaos ((t/(t&gt;&gt;8&amp;t&gt;&gt;7))&amp;t)-1 //beep ((t/(t&gt;&gt;8&amp;t&gt;&gt;4))&amp;t&gt;&gt;8)*t //t&gt;&gt;4&amp;t&gt;&gt;8 remix t/(t%(t&gt;&gt;8|t&gt;&gt;12)) //32kHz sin(sin(t/100)-t/((2+(t&gt;&gt;10&amp;t&gt;&gt;12)%9)))*64+128 //trill w=t%(t&gt;&gt;8|t&gt;&gt;16),b=w&gt;&gt;5|t&gt;&gt;8,(b*t)-(t*(t&gt;&gt;8)) //(t&gt;&gt;5|t&gt;&gt;8)*t builder (1.001*t^-t*1.001)+t/(500+(t&gt;&gt;16&amp;t&gt;&gt;8)) //process complete (t&amp;t&gt;&gt;4)-(t&gt;&gt;13&amp;t) //dark kick r=sin(t&gt;&gt;12)*30,w=sin(t/(r%5))+sin(t/(r%6)),w*64+128 //replace \"30\" with another number to get a new song w=t%(t&gt;&gt;15)&gt;0?t:-t,((w&gt;&gt;4&amp;w&gt;&gt;8)*w) //green noise, black noise ((t*.98)%(t&gt;&gt;13&amp;t&gt;&gt;12))+(t%(t&gt;&gt;13&amp;t&gt;&gt;10)) //duo team. Based off of mu6k's \"Long Line Theory\" t%50.01+t%40.1+t%30.1+t%60.01 //harmony. Based off of mu6k's \"Long Line Theory\" w=[1,2,3,4,3,4,1][(t&gt;&gt;13)%7]*t,(w%50.01+w%40.1+w%30.1+w%60.01) //harmony v2. Based off of mu6k's \"Long Line Theory\" n=50+([4,6,4,6,1,3,1,3][(t&gt;&gt;13)%8]),w=([1,1,1][(t&gt;&gt;13)%3])*t,(w%n)+(w%(n-10)+(w%(n+10))) //sad chords, again based off of mu6k's \"Long Line Theory\" (t&gt;&gt;8&amp;(t/(t&gt;&gt;4&amp;t&gt;&gt;8))&gt;&gt;4)*t //glitch s=((t&gt;&gt;8&amp;t&gt;&gt;4)%24)+1,v=128,(t*(t&gt;&gt;8&amp;t&gt;&gt;4))&amp;128?sin(t/s)*v+128:-sin(t/s)*v+128 //not quite a sine wave (((t&gt;&gt;8)+(t&gt;&gt;16&amp;t))&amp;t&gt;&gt;2)*t //use with below (((t&gt;&gt;8)+(t&gt;&gt;16&amp;t))&amp;t&gt;&gt;3)*t //use with above, tag team swish a=[1,1,2,3,1,1,2,3,1,1,2,4,4,4,5,5,5][(t&gt;&gt;12)%17],b=[5,4,3,2][(t&gt;&gt;16)%4],(t*b/a)%50.1+(t*b/a)%50 //array song. First real one i promise this time. t&gt;&gt;(8/((t/32)%3)) //reverse t*((((t&gt;&gt;8)&amp;t&gt;&gt;2)*t)/(((t&gt;&gt;8)&amp;t&gt;&gt;3)*t)+(((t&gt;&gt;8)&amp;t&gt;&gt;3)*t)/(((t&gt;&gt;8)&amp;t&gt;&gt;2)*t)) //everytype smasher ((t&gt;&gt;10|t&gt;&gt;1)&amp;t|(t&gt;&gt;18&amp;t))-t //muncher ((t/4)&gt;&gt;(t/4))&gt;&gt;(t&gt;&gt;(t/8))|t&gt;&gt;2 //plucker ((t/4)&gt;&gt;t/4)|(t&gt;&gt;2) //plucker v2 (t &amp; ((t%(t&gt;&gt;1&amp;t))|t&gt;&gt;3^t&gt;&gt;4)&gt;&gt;7)-1 //fractal glitcher (t &amp; ((t%(t&gt;&gt;1&amp;t))|t&gt;&gt;13^t&gt;&gt;5)&gt;&gt;7)-1 //fractal glitcher v2 ((t/1000)^(t/1001))*t //jumper t/((t%(t&gt;&gt;13&amp;t))) //noisecore synthcore t/(t^(t+1+(t&gt;&gt;16))) //cyclic . ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html#examples",
    "relUrl": "/processes/bytebeat.html#examples"
  },"220": {
    "doc": "Bytebeat",
    "title": "Bytebeat",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/bytebeat.html",
    "relUrl": "/processes/bytebeat.html"
  },"221": {
    "doc": "Calibrator",
    "title": "Calibrator",
    "content": ". This process allows to calibrate an input signal to extract the “significant” part of the signal, when it is impossible to define an accurate range of values at the time the score is being authored: for instance, consider a temperature sensor. Its range as defined in the Device explorer could be between -30°C and 70°C. However, the daily variations could be sometimes around 15°, sometimes around 25°… with most of the range being unused. The Calibrator object outputs values between 0 and 1, by computing over time the actual minimum and maximum of the input values and scaling between those. In addition, it allows to access a few statistics on the input signal. The effective range can further be adjusted and shaped. To get its output, simply connect to the “Scaled” output. In this example, the input of the calibrator is connected to the sensors:/temperature sensor, which has a range of 0-100°. But if the inputs of the process only vary between 10° and 30° while the installation is runnning, the scaled output will be 0 for 10° and 1 for 30°. ",
    "url": "https://ossia.io/score-docs/processes/calibrator.html",
    "relUrl": "/processes/calibrator.html"
  },"222": {
    "doc": "Camera device",
    "title": "Example: showing the raw camera feed",
    "content": "In this example, we perform the following steps: . | Add the camera input through the device explorer. | Likewise, add a window device in which the camera is going to be rendered. | Add a “passthrough” video effect, to connect the camera input to the window output. | Set up the passthrough ports. | Press play and enjoy ! | . The passthrough effect can be found in the user library, in the folder Presets/GLSL_Shaders/utility. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#example-showing-the-raw-camera-feed",
    "relUrl": "/devices/camera-device.html#example-showing-the-raw-camera-feed"
  },"223": {
    "doc": "Camera device",
    "title": "Technical information",
    "content": "The video input system uses FFMPEG, which itself leverages the operating system’s video input decoding mechanism as far as possible. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#technical-information",
    "relUrl": "/devices/camera-device.html#technical-information"
  },"224": {
    "doc": "Camera device",
    "title": "V4L2 support",
    "content": "V4L2 is the Linux video subsystem API. The v4l2loopback kernel module allows for a lot of useful things. Grabbing the screen with v4l2loopback . $ sudo modprobe v4l2loopback $ ffmpeg -f x11grab -framerate 60 -video_size 3840x2160 -i :0.0+0,0 -f v4l2 /dev/video0 . Forwarding an external video file to score through v4l2loopback . $ sudo modprobe v4l2loopback $ while 1 ; do ffmpeg -re -i ./test.mp4 -f v4l2 /dev/video0 ; done . ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#v4l2-support",
    "relUrl": "/devices/camera-device.html#v4l2-support"
  },"225": {
    "doc": "Camera device",
    "title": "Special camera support",
    "content": "Microsoft Kinect . Support for Kinect cameras has been implemented through the Freenect library. However, the support is still experimental and requires building score from source with the Freenect libraries. Spout, Syphon, PipeWire . Spout is supported as output on Windows. Syphon on Mac is not yet supported, neither is PipeWire on Linux. Complete support for both systems is slated for a 3.x release of score. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html#special-camera-support",
    "relUrl": "/devices/camera-device.html#special-camera-support"
  },"226": {
    "doc": "Camera device",
    "title": "Camera device",
    "content": ". Score supports using camera inputs in its VFX graph. The camera can be used as the input of a texture port. ",
    "url": "https://ossia.io/score-docs/devices/camera-device.html",
    "relUrl": "/devices/camera-device.html"
  },"227": {
    "doc": "Classifier",
    "title": "Classifier",
    "content": ". The Classifier process provides real-time machine learning classification capabilities using RapidLib algorithms. It’s similar to tools such as Wekinator but integrated directly into score’s processing pipeline. It is very close to the Regressor process: the difference is that Regressor interpolates while Classifier outputs the exact input value that was set during training. ",
    "url": "https://ossia.io/score-docs/processes/classifier.html",
    "relUrl": "/processes/classifier.html"
  },"228": {
    "doc": "Classifier",
    "title": "Overview",
    "content": "The Classifier enables: . | Real-time pattern recognition | Gesture classification | Sensor data categorization | Multi-class decision making | Adaptive learning during performance | . Perfect for: . | Interactive installations | Gesture-controlled instruments | Sensor-based interactions | Adaptive audio/visual systems | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#overview",
    "relUrl": "/processes/classifier.html#overview"
  },"229": {
    "doc": "Classifier",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Features | Float Array | Input feature vector | . | Record | Impulse | Record training example | . | Train | Impulse | Train the model | . | Reset | Impulse | Clear all training data | . | Target | Float inlets | Target values for recording | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#inputs",
    "relUrl": "/processes/classifier.html#inputs"
  },"230": {
    "doc": "Classifier",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Prediction | Float | Predicted output | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#outputs",
    "relUrl": "/processes/classifier.html#outputs"
  },"231": {
    "doc": "Classifier",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Features | Float Array | Input feature vector | . | Record | Impulse | Record training example | . | Train | Impulse | Train the model | . | Reset | Impulse | Clear all training data | . | Target | Float inlets | Target values for recording | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#inputs-1",
    "relUrl": "/processes/classifier.html#inputs-1"
  },"232": {
    "doc": "Classifier",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Prediction | Float | Predicted output values | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#outputs-1",
    "relUrl": "/processes/classifier.html#outputs-1"
  },"233": {
    "doc": "Classifier",
    "title": "Usage Workflow",
    "content": "1. Define Mapping . Decide what you want to map: . | Inputs : Sensor values, analysis data, control positions | Outputs : Audio parameters, visual controls, device values | . 2. Data Collection . For each training point: . | Set inputs to desired state | Set Target to desired outputs | Trigger Record | Repeat across your mapping space | . 3. Training and Use . Training Phase: [Input State] → [Set Target] → [Record] → [Collect Examples] → [Train] Runtime Phase: [Live Input] → [Regressor] → [Smooth Output] → [Parameter Control] . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#usage-workflow",
    "relUrl": "/processes/classifier.html#usage-workflow"
  },"234": {
    "doc": "Classifier",
    "title": "Example Applications",
    "content": "Gesture Recognition . Recognize hand gestures from accelerometer data: . [Accelerometer] → [Feature Extraction] → [Classifier] → [Gesture Type] ↓ ↓ [X, Y, Z, Magnitude] [Visual Response] . Training process: . | Perform “wave” gesture, record as Class 1 (input knob at value 0) | Perform “circle” gesture, record as Class 2 (input knob at value 0.5) | Perform “tap” gesture, record as Class 3 (input knob at value 1.0) | Train the model | Real-time gesture recognition | . Audio Classification . Classify different types of sounds: . [Audio Input] → [FFT] → [Spectral Features] → [Classifier] → [Sound Type] ↓ ↓ [Centroid, Rolloff, ZCR] [Trigger Actions] . Movement Classification . Classify dancer movements from video analysis: . [Camera] → [Pose Detection] → [Movement Features] → [Classifier] → [Dance Style] ↓ ↓ [Joint Velocities, Angles] [Music Selection] . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#example-applications",
    "relUrl": "/processes/classifier.html#example-applications"
  },"235": {
    "doc": "Classifier",
    "title": "Feature Engineering",
    "content": "Good features are crucial for classification performance: . Common Feature Types . Time Domain: . | Mean, standard deviation | Min, max values | Zero crossing rate | Peak locations | . Frequency Domain: . | Spectral centroid | Spectral rolloff | MFCC coefficients | Energy in bands | . Motion Features: . | Velocity, acceleration | Jerk (rate of acceleration change) | Angular velocity | Trajectory curvature | . Feature Extraction Example . [Raw Sensor] → [Sliding Window] → [Statistics] → [Features] ↓ ↓ [Buffer 100ms] [Mean, Std, Peak] . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#feature-engineering",
    "relUrl": "/processes/classifier.html#feature-engineering"
  },"236": {
    "doc": "Classifier",
    "title": "Training Best Practices",
    "content": "Data Collection . | Diverse Examples : Collect varied examples for each class | Balanced Dataset : Similar number of examples per class | Representative Data : Examples should cover expected variations | Clean Data : Remove obvious errors and outliers | . Class Design . | Distinct Classes : Make sure classes are meaningfully different | Consistent Labeling : Be consistent with class definitions | Sufficient Examples : At least 10-20 examples per class | Test Data : Keep some examples for testing | . Performance Monitoring . | Check confidence scores | Monitor misclassification patterns | Retrain with additional data if needed | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#training-best-practices",
    "relUrl": "/processes/classifier.html#training-best-practices"
  },"237": {
    "doc": "Classifier",
    "title": "Integration Examples",
    "content": "Interactive Music . [Gesture Input] → [Classifier] → [Music Style] ↓ [Instrument Selection] [Scale Selection] [Rhythm Pattern] . Adaptive Visuals . [Environmental Data] → [Classifier] → [Mood Classification] ↓ [Color Palette] [Animation Speed] [Effect Selection] . Smart Lighting . [Activity Sensors] → [Classifier] → [Activity Type] ↓ [Lighting Scene] [Color Temperature] [Brightness Level] . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#integration-examples",
    "relUrl": "/processes/classifier.html#integration-examples"
  },"238": {
    "doc": "Classifier",
    "title": "Related Processes",
    "content": ". | Regressor - For continuous value prediction | Analysis - Feature extraction from audio | Computer Vision Utilities - Visual features | Array Utilities - Feature preprocessing | . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#related-processes",
    "relUrl": "/processes/classifier.html#related-processes"
  },"239": {
    "doc": "Classifier",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/classifier.html#try-it",
    "relUrl": "/processes/classifier.html#try-it"
  },"240": {
    "doc": "CoAP Device",
    "title": "CoAP Device",
    "content": ". CoAP (Constrained Application Protocol) is a specialized web transfer protocol designed for use with constrained nodes and networks in the Internet of Things (IoT). It is a standard internet protocol closely related to HTTP in behavior and operations, but with much more efficient communication optimized for resource-limited devices. ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html",
    "relUrl": "/devices/coap-device.html"
  },"241": {
    "doc": "CoAP Device",
    "title": "Overview",
    "content": "CoAP is designed for: . | Constrained devices with limited processing power and memory | Lossy networks with high packet loss and low bandwidth | Battery-powered devices requiring energy-efficient communication | Machine-to-machine (M2M) communication in IoT ecosystems | Embedded control systems and sensor networks | . Key CoAP features: . | UDP-based for low overhead (default port: 5683) | RESTful architecture similar to HTTP but optimized for constraints | Built-in discovery mechanism via /.well-known/core | Observe pattern for real-time data subscription | Block-wise transfers for handling large payloads | . ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#overview",
    "relUrl": "/devices/coap-device.html#overview"
  },"242": {
    "doc": "CoAP Device",
    "title": "Supported Transports",
    "content": "ossia score supports all standard CoAP transports: . UDP (Default) . | Lightweight, connectionless communication | Best for battery-powered and resource-constrained devices | Port 5683 (5684 for DTLS secure connections) | . TCP . | Reliable, connection-oriented communication | Better for stable network connections | Useful when message ordering is critical | . WebSocket . | CoAP over WebSocket transport | Browser compatibility and firewall traversal | Integration with web-based systems | . ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#supported-transports",
    "relUrl": "/devices/coap-device.html#supported-transports"
  },"243": {
    "doc": "CoAP Device",
    "title": "Device Setup &amp; Discovery",
    "content": "Basic Configuration . | Add CoAP Device: Right-click Device Explorer → Add Device → CoAP | Configure Connection: . | Host: Target device IP address (e.g., 192.168.1.100) | Port: CoAP port (5683 for UDP, custom for others) | Transport: UDP, TCP, or WebSocket | . | . CoAP’s discovery mechanism then automatically finds available resources which get exposed as ossia device explorer nodes. ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#device-setup--discovery",
    "relUrl": "/devices/coap-device.html#device-setup--discovery"
  },"244": {
    "doc": "CoAP Device",
    "title": "Practical Examples",
    "content": "Public CoAP Testing . Try with the public CoAP server at coap.me: . | Add CoAP Device with host coap.me, port 5683, UDP transport | Explore resources like /hello, /time, /separate | Test OBSERVE on resources that support real-time updates | . ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#practical-examples",
    "relUrl": "/devices/coap-device.html#practical-examples"
  },"245": {
    "doc": "CoAP Device",
    "title": "Troubleshooting",
    "content": "Connection Issues . | Verify port 5683 accessibility through firewalls | Check device IP address and network connectivity | Test with CoAP tools (coap-client, Copper browser plugin) | Monitor UDP packet loss on unreliable networks | . Discovery Problems . | Check /.well-known/core endpoint responds correctly | Validate link format syntax in discovery responses | Try manual resource addition if auto-discovery fails | Verify content-type headers in discovery responses | . ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#troubleshooting",
    "relUrl": "/devices/coap-device.html#troubleshooting"
  },"246": {
    "doc": "CoAP Device",
    "title": "Related Documentation",
    "content": ". | MQTT Device - Alternative IoT messaging protocol | HTTP Device - Full-featured query-based web protocol | WS Device - Full-featured streaming web protocol | OSC Device - Real-time multimedia control | . ",
    "url": "https://ossia.io/score-docs/devices/coap-device.html#related-documentation",
    "relUrl": "/devices/coap-device.html#related-documentation"
  },"247": {
    "doc": "Command line API",
    "title": "Command-line reference",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#command-line-reference",
    "relUrl": "/reference/commandline.html#command-line-reference"
  },"248": {
    "doc": "Command line API",
    "title": "List of command-line options",
    "content": "Getting the list of options . $ ossia-score --help . Loading a score on startup: . $ ossia-score filename # For example: $ ossia-score /home/oscar/my-score.score . Playing a score on startup . $ ossia-score --autoplay filename # For example: $ ossia-score --autoplay /home/oscar/my-score.score . Playing a score on startup after some delay . This is useful if for instance the score has audio plug-ins that take some time to load, such as orchestral plug-ins with large sound banks. $ ossia-score --autoplay filename --wait delay_in_seconds # For example: $ ossia-score --autoplay /home/oscar/my-score.score --wait 5 . Loading score without showing the GUI . $ ossia-score --no-gui . (note: this is not very useful without specifying a file to load). Loading score without showing the “do you want to restore” pop-up dialog . This is useful if you are quitting score for instance by killing the process, as score will register that as a crash, which will cause the pop-up to show up next time. $ ossia-score --no-restore . Loading score in software rendering mode . ossia score uses as of v3 OpenGL for rendering the main timeline. On some old machines or machines with bad GL drivers, this can cause issues. We then recommend using that switch to launch it. $ ossia-score --no-opengl . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#list-of-command-line-options",
    "relUrl": "/reference/commandline.html#list-of-command-line-options"
  },"249": {
    "doc": "Command line API",
    "title": "Complete recommended command line to launch a score on startup",
    "content": "On Linux: . $ /usr/bin/ossia-score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" . On macOS: . $ /Applications/Score.app/Contents/MacOS/score --no-gui --no-restore --wait 5 --autoplay \"/path/to/your/score.score\" . On Windows: . &gt; \"c:\\Program Files\\ossia score\\score.exe\" --no-gui --no-restore --wait 5 --autoplay \"c:\\path\\to\\your\\score.score\" . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#complete-recommended-command-line-to-launch-a-score-on-startup",
    "relUrl": "/reference/commandline.html#complete-recommended-command-line-to-launch-a-score-on-startup"
  },"250": {
    "doc": "Command line API",
    "title": "List of useful environment variables",
    "content": ". | SCORE_DISABLE_ALSA=1: on Linux, disables the ALSA backend. | SCORE_DISABLE_AUDIOPLUGINS=1: disables scanning of VST, LV2 plug-ins on startup. | FAUST_LIB_PATH=/some/path: can override the default path where score looks for Faust libraries (by default they ship with score). | . ",
    "url": "https://ossia.io/score-docs/reference/commandline.html#list-of-useful-environment-variables",
    "relUrl": "/reference/commandline.html#list-of-useful-environment-variables"
  },"251": {
    "doc": "Command line API",
    "title": "Command line API",
    "content": "You can launch ossia score from the command line or shell scripts with various useful options. ",
    "url": "https://ossia.io/score-docs/reference/commandline.html",
    "relUrl": "/reference/commandline.html"
  },"252": {
    "doc": "Common practices",
    "title": "Common practices",
    "content": "The following pages will guide you through recurring patterns and snippets that apply to various use-cases common in the creation of media artworks. For instance, how to spatialize sound beyond stereo, how to organize a score in scenes, how to play cues, what are the possibilities for live-coding in score… . ",
    "url": "https://ossia.io/score-docs/common-practices",
    "relUrl": "/common-practices"
  },"253": {
    "doc": "Bitfocus Companion Device",
    "title": "Bitfocus Companion Device",
    "content": ". Bitfocus Companion is a professional application for controlling streaming, broadcast, and AV equipment through hardware controllers like Stream Deck. ossia score’s Companion integration enables seamless interaction between your interactive scores and Companion-compatible devices. ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html",
    "relUrl": "/devices/companion-device.html"
  },"254": {
    "doc": "Bitfocus Companion Device",
    "title": "Overview",
    "content": "This integration allows ossia score to: . | Control and receive feedback from any device supported by Bitfocus Companion | Synchronize show states with broadcast equipment | Integrate with professional streaming workflows | . For instance, this integration makes it possible to send messages to Slack and Discord directly from score, automate Micrrosoft PowerPoint, control Barco and Panasonic projectors, Behringer mixing consoles, GrandMA lighting desks, access APIs such as Birddog Cloud, Q-SYS, VDO.Ninja or BrightSign, or even do a SpeedTest right from the score and use the result to select different behaviours :-) . ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html#overview",
    "relUrl": "/devices/companion-device.html#overview"
  },"255": {
    "doc": "Bitfocus Companion Device",
    "title": "Requirements",
    "content": "Software . | ossia score with Companion package installed from the package manager in the settings | Compatible software or hardware controllers you want to use. | . Package Installation . | Open the Package Manager from the settings | Search for “Bitfocus” in the remote packages list | Install the Bitfocus Companion Modules package (it will take some times as it is roughly a 1 gigabyte download). | Restart ossia score | . ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html#requirements",
    "relUrl": "/devices/companion-device.html#requirements"
  },"256": {
    "doc": "Bitfocus Companion Device",
    "title": "Device Setup",
    "content": "1. Add Companion Device in score . | Right-click in Device Explorer | Select Add Device | Choose Bitfocus from protocols | Select the actual device or protocol in the list that appears. If you do not see nay device, the package may not be installed correctly. | Configure the actual Companion-compatible protocol you choose. | . ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html#device-setup",
    "relUrl": "/devices/companion-device.html#device-setup"
  },"257": {
    "doc": "Bitfocus Companion Device",
    "title": "Available Controls",
    "content": "Each device will present different controls, organized in the same categories. ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html#available-controls",
    "relUrl": "/devices/companion-device.html#available-controls"
  },"258": {
    "doc": "Bitfocus Companion Device",
    "title": "Related Documentation",
    "content": ". | OSC Device - Direct OSC communication | Control Surface - UI control surfaces to control specific modules in the timeline. | Remote Control - score remote control | . ",
    "url": "https://ossia.io/score-docs/devices/companion-device.html#related-documentation",
    "relUrl": "/devices/companion-device.html#related-documentation"
  },"259": {
    "doc": "Compute Shaders",
    "title": "CSF Shaders",
    "content": ". The compute shader process allow you to add and live-code your own shader to an image or video. A shader is a visual effect or generator program, which is processed with the graphics card for maximum performance. Compute shaders are written with a variation of the Interactive Shader Format (ISF), using GLSL. A lot of nice shaders are already provided as part of the user library, courtesy of Vidvox. They can be drag’n’dropped from the library, or from the explorer ; controls and inputs will be created automatically. ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html#csf-shaders",
    "relUrl": "/processes/compute-shaders.html#csf-shaders"
  },"260": {
    "doc": "Compute Shaders",
    "title": "Writing a compute shader",
    "content": "The rules are similar to ISF shaders, but the data types are different, and more precision is needed due to the advanced flexibility of the compute pipeline. The main differences are: . | We are in a compute shader: unlike vertex or fragment shaders, no input or output are predefined. It is up to the user to define the resources that the shader is going to operate upon. | The JSON header must contain the key: . | . \"MODE\": \"COMPUTE_SHADER\", . | The \"IMAGE\" type which creates a texture in ISF and VSA, creates an image in compute shaders. Use the \"TEXTURE\" type to create a sampled texture accessible with textureLod(...) instead of an image accessible with imageLoad and imageStore. | It is possible to refer to the width and height of another image in the JSON header with the $WIDTH_otherImageName and $HEIGHT_otherImageName macros (and, like ISF, use them as part of normal math formulas and expressions). | \"PASSES\" are mandatory as they define how the compute shader is going to be invoked. At least one pass is necessary. | . The pass syntax is slightly different from the ISF one as it needs to bring data relevant to compute shaders: . | The shader’s local size | How many workgroups are used | . For instance: assuming outputImage is 1020 x 770 pixels. Then: . { \"LOCAL_SIZE\": [16, 16, 1], \"EXECUTION_MODEL\": { \"TYPE\": \"MANUAL\", \"WORKGROUPS\": [64, 1, 1] } } . will translate to: . layout(local_size_x = 16, local_size_y = 16, local_size_z = 1​) in; void glDispatchCompute(64, 1, 1); . { \"LOCAL_SIZE\": [16, 16, 1], \"EXECUTION_MODEL\": { \"TYPE\": \"2D_IMAGE\", \"TARGET\": \"outputImage\" } } . will translate to: . layout(local_size_x = 16, local_size_y = 16, local_size_z = 1​) in; void glDispatchCompute((1020 + 16 - 1) / 16​, (770 + 16 - 1) / 16, 1); e.g. void glDispatchCompute(64, 49, 1); . which translates into (64 * 16) * (49 * 16) = 1024 * 784 invocations. ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html#writing-a-compute-shader",
    "relUrl": "/processes/compute-shaders.html#writing-a-compute-shader"
  },"261": {
    "doc": "Compute Shaders",
    "title": "Example",
    "content": "/*{ \"DESCRIPTION\": \"Adjusts image brightness using compute shader\", \"CREDIT\": \"ossia score\", \"ISFVSN\": \"2.0\", \"MODE\": \"COMPUTE_SHADER\", \"CATEGORIES\": [\"COLOR\"], \"RESOURCES\": [ { \"NAME\": \"inputImage\", \"TYPE\": \"IMAGE\", \"ACCESS\": \"read_only\", \"FORMAT\": \"RGBA8\" }, { \"NAME\": \"outputImage\", \"TYPE\": \"IMAGE\", \"ACCESS\": \"write_only\", \"FORMAT\": \"RGBA8\", \"WIDTH\": \"$WIDTH_inputImage\", \"HEIGHT\": \"$HEIGHT_inputImage\" }, { \"NAME\": \"brightness\", \"TYPE\": \"float\", \"LABEL\": \"Brightness\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0 }, { \"NAME\": \"contrast\", \"TYPE\": \"float\", \"LABEL\": \"Contrast\", \"DEFAULT\": 1.0, \"MIN\": 0.0, \"MAX\": 2.0 }, { \"NAME\": \"applyEffect\", \"TYPE\": \"bool\", \"LABEL\": \"Apply Effect\", \"DEFAULT\": true } ], \"PASSES\": [{ \"LOCAL_SIZE\": [16, 16, 1], \"EXECUTION_MODEL\": { \"TYPE\": \"2D_IMAGE\", \"TARGET\": \"outputImage\" } }] }*/ void main() { ivec2 coord = ivec2(gl_GlobalInvocationID.xy); vec4 color = imageLoad(inputImage, coord); if (applyEffect) { // Apply brightness and contrast color.rgb = (color.rgb - 0.5) * contrast + 0.5; color.rgb *= brightness; color.rgb = clamp(color.rgb, 0.0, 1.0); } imageStore(outputImage, coord, color); } . ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html#example",
    "relUrl": "/processes/compute-shaders.html#example"
  },"262": {
    "doc": "Compute Shaders",
    "title": "Related Processes",
    "content": ". | ISF Shader: Classic fragment shaders. | Model Display: To apply the shader onto a 3D surface. | Lightness Computer: To convert texture data into pixel arrays, for instance for LED design. | . ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html#related-processes",
    "relUrl": "/processes/compute-shaders.html#related-processes"
  },"263": {
    "doc": "Compute Shaders",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html#try-it",
    "relUrl": "/processes/compute-shaders.html#try-it"
  },"264": {
    "doc": "Compute Shaders",
    "title": "Compute Shaders",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/compute-shaders.html",
    "relUrl": "/processes/compute-shaders.html"
  },"265": {
    "doc": "Computer Vision utilities",
    "title": "Computer vision",
    "content": ". ",
    "url": "https://ossia.io/score-docs/processes/computer-vision-utilities.html#computer-vision",
    "relUrl": "/processes/computer-vision-utilities.html#computer-vision"
  },"266": {
    "doc": "Computer Vision utilities",
    "title": "Computer Vision utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/computer-vision-utilities.html",
    "relUrl": "/processes/computer-vision-utilities.html"
  },"267": {
    "doc": "Console",
    "title": "Console panel",
    "content": "The console panel (shortcut: Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac)) allows to create and run macros written in Javascript (ES7). See Scripting for detailed information on the script features. ",
    "url": "https://ossia.io/score-docs/panels/console.html#console-panel",
    "relUrl": "/panels/console.html#console-panel"
  },"268": {
    "doc": "Console",
    "title": "Console",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/console.html",
    "relUrl": "/panels/console.html"
  },"269": {
    "doc": "Context-Free Art",
    "title": "Context-Free Art",
    "content": ". This process allows to use Context-free art code for image generation. Note that this is not a real-time process. ",
    "url": "https://ossia.io/score-docs/processes/context-free-art.html",
    "relUrl": "/processes/context-free-art.html"
  },"270": {
    "doc": "Control utilities",
    "title": "Impulse metronome",
    "content": ". The simplest possible metronome, synchronized to its parent interval. Will send an impulse on each beat. ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html#impulse-metronome",
    "relUrl": "/processes/control-utilities.html#impulse-metronome"
  },"271": {
    "doc": "Control utilities",
    "title": "Free metronome",
    "content": ". A desynchronized metronome. It can ignore the parent interval’s tempo and will instead beat at its own unrelated speed, a bit like the [metro] objects in Pure Data or Max/MSP. If “Quantify” is set on “Free”, then the raw frequency in Hertz will be used as tempo source. Else, the parent tempo is used. The rate can be chosen with the musical division selector. ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html#free-metronome",
    "relUrl": "/processes/control-utilities.html#free-metronome"
  },"272": {
    "doc": "Control utilities",
    "title": "Control utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/control-utilities.html",
    "relUrl": "/processes/control-utilities.html"
  },"273": {
    "doc": "Controlling score with OSCQuery",
    "title": "Controlling score remotely with OSCQuery",
    "content": "A score can be controlled through OSC and OSCQuery with the Local device. See also the WebSocket remote control protocol. ",
    "url": "https://ossia.io/score-docs/faq/controlling-score-with-oscquery.html#controlling-score-remotely-with-oscquery",
    "relUrl": "/faq/controlling-score-with-oscquery.html#controlling-score-remotely-with-oscquery"
  },"274": {
    "doc": "Controlling score with OSCQuery",
    "title": "Controlling score with OSCQuery",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq/controlling-score-with-oscquery.html",
    "relUrl": "/faq/controlling-score-with-oscquery.html"
  },"275": {
    "doc": "Control surface",
    "title": "Control surface process",
    "content": ". This process allows to control remote parameters defined in the Device explorer from the central timeline / nodal view. To add an address, drag’n’drop it from the explorer to the process’s central area. This will add it as an automatable and controllable parameter for the duration of the execution of that process, with a meaningful user interface widget depending on the metadata associated with the OSC node (unit, data type, range…). Note that like every other score process, it will only have an effect during the execution of the score. ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html#control-surface-process",
    "relUrl": "/processes/controlsurface.html#control-surface-process"
  },"276": {
    "doc": "Control surface",
    "title": "Remote control API",
    "content": "The control surface process provides remote control features, through the system discussed in Remote Control. When such a process starts executing, the following message is sent: . { \"Message\": \"ControlSurfaceAdded\", \"Path\": \"/path/to/the/surface\", \"Controls\": [ ... list of control objects... ] } . When the process ends, the following message is sent: . { \"Message\": \"ControlSurfaceRemoved\", \"Path\": \"/path/to/the/surface\" } . Controls . A control object defines a given control and has the following format. { \"Custom\": \"The name of the control\", \"Domain\": { ... domain object ... }, \"Value\": { ... value object ... }, \"id\": 1234, // the identifier of the individual control \"uuid\": \"af2b4fc3-aecb-4c15-a5aa-1c573a239925\" // the identifier of the control kind } . The remote can send the following message to change a parameter in score: . { \"Message\": \"ControlSurface\", \"Path\": \"/path/to/the/surface\", \"id\": 1234, // the id of the individual control that changed \"Value\": { ... the value object ... } } . Value object . The Value object has the following format: . { \"TYPE\": VALUE } . Where TYPE can be any of Int, Float, Bool, String, Char, Vec2f, Vec3f, Vec4f, Tuple, Impulse. For instance, valid values are: . { \"Float\": 1.23456 } { \"Int\": 127 } { \"String\": \"hello world\" } { \"Vec2f\": [0.5, 1.54] } { \"Bool\": true } { \"Impulse\": 1 } { \"Tuple\": [ { \"Float\": 1.234}, { \"String\": \"hello\" } ] } . Domain object . The Domain object has the following format: . { \"TYPE\": { \"Min\": THE_MIN, \"Max\": THE_MAX } } . where TYPE is the same than above. The most common cases are of course Int and Float as it does not really make sense for bools, etc. Example to have a slider that goes from -10 to 100: . { \"Float\": { \"Min\": -10 \"Max\": 100 } } . It is also possible to define a domain through a set of acceptable values instead of a range: . { \"TYPE\": { \"Values\": [ ... array of acceptable values ...] } } . ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html#remote-control-api",
    "relUrl": "/processes/controlsurface.html#remote-control-api"
  },"277": {
    "doc": "Control surface",
    "title": "Control surface",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/controlsurface.html",
    "relUrl": "/processes/controlsurface.html"
  },"278": {
    "doc": "C++ JIT",
    "title": "C++ JIT",
    "content": "This process allows to compile C++ code into a score process at run-time. You can complete the process by opening the programming window in the inspector panel on the right. This allows ‘Just-in-time’ programming in C++ . ",
    "url": "https://ossia.io/score-docs/processes/cpp_jit.html",
    "relUrl": "/processes/cpp_jit.html"
  },"279": {
    "doc": "CSV recorder",
    "title": "CSV Recorder",
    "content": ". This process allows to record a set of addresses matching an address pattern expression. It will create a CSV file containing the recorded data, one row per address matched by the pattern. For instance, in the screenshot above, the following configuration would recreate a CSV file on each playback of the score called /tmp/save.csv with content such as : . timestamp,/0/co2,/1/co2,/2/co2 0,0.5429007,0.6073362,0.3612722 63,0.5429007,0.6073362,0.3612722 127,0.5429007,0.6073362,0.3612722 191,0.5037621,0.42720786,0.28013167 255,0.6991433,0.42720786,0.47998703 319,0.8627539,0.42720786,0.36869702 383,0.9684921,0.42720786,0.8776827 447,0.9994888,0.42720786,0.36079046 511,0.95079887,0.42720786,0.80060333 575,0.8301902,0.42720786,0.39480355 639,0.65690416,0.42720786,0.7897841 . with a row of data saved every 0.05 seconds (50 milliseconds). For archiving purposes, it is possible to use the %t macro in the filename which will be replaced by the date of recording in the filename. Given an existing CSV file, Playback or Loop mode will play the content back. ",
    "url": "https://ossia.io/score-docs/processes/csv-recorder.html#csv-recorder",
    "relUrl": "/processes/csv-recorder.html#csv-recorder"
  },"280": {
    "doc": "CSV recorder",
    "title": "CSV recorder",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/csv-recorder.html",
    "relUrl": "/processes/csv-recorder.html"
  },"281": {
    "doc": "Cues",
    "title": "Cues",
    "content": "Cues are an essential part of interactive shows: they allow to record a set of controls and messages that will be applied at a single point in time: OSC or DMX messages, MIDI control changes, etc. In score, cues are messages that are contained inside states. ",
    "url": "https://ossia.io/score-docs/cues.html",
    "relUrl": "/cues.html"
  },"282": {
    "doc": "Cues",
    "title": "Creating a cue",
    "content": "Cues are created by drag’n’drop, from a set of Device explorer nodes, to the score. It is possible to add messages to a cue by dropping on it. Existing messages to a given address will be replaced by the value that is being dropped. ",
    "url": "https://ossia.io/score-docs/cues.html#creating-a-cue",
    "relUrl": "/cues.html#creating-a-cue"
  },"283": {
    "doc": "Cues",
    "title": "Updating a cue",
    "content": "If you want to replace the parameters of a cue with their current value in the explorer, you can click on the state. The state inspector has a “Snapshot” feature which will update all the values stored in the cue, with their current live value. | The first icon with the camera, “Snapshot” (Ctrl+L(Win / Linux) or⌘+L(Mac)), takes all the parameters currently selected in the Device explorer and copies them to the cue. | The second icon, with the circled camera, “Refresh” (Ctrl+R(Win / Linux) or⌘+R(Mac)), takes all the parameters inside the saved cue, and updates them to their current “live” value as shown in the device explorer. | . ",
    "url": "https://ossia.io/score-docs/cues.html#updating-a-cue",
    "relUrl": "/cues.html#updating-a-cue"
  },"284": {
    "doc": "Cues",
    "title": "Playing a cue",
    "content": "Cues will be played automatically when the score execution reaches them: . ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue",
    "relUrl": "/cues.html#playing-a-cue"
  },"285": {
    "doc": "Cues",
    "title": "Playing a cue manually",
    "content": "It is possible to play a cue through the “Play” tool in the user interface. ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue-manually",
    "relUrl": "/cues.html#playing-a-cue-manually"
  },"286": {
    "doc": "Cues",
    "title": "Playing a cue with an external control",
    "content": "It is possible to entirely control when a cue is going to be sent, by adding a trigger on it and let it “float” in the scenario. Such a floating cue can originally be created by double-clicking on the scenario (or drag’n’dropping directly from the Device explorer, and removing the created interval afterwards). Then, one needs to add a trigger (through the inspector or by pressing T when the state is selected), and configure it for out-of-time playback. Here is how this would work: . The set-up on the triggers look like this: . Notice in particular that the two buttons, “Auto-Trigger” and “Start on play”, are checked. It would be possible for instance to trigger the cue when a MIDI CC reaches a specific value or similar. See Breaking the timeline for more information on triggers. ",
    "url": "https://ossia.io/score-docs/cues.html#playing-a-cue-with-an-external-control",
    "relUrl": "/cues.html#playing-a-cue-with-an-external-control"
  },"287": {
    "doc": "Custom UI",
    "title": "Custom UIs",
    "content": "It is possible to create custom control UIs for a given ossia score through QML and QtQuick, a GPU-accelerated UI language part of Qt. This allows to replace the entire control UI of ossia with your own personalized UI, while being able to interoperate with the score using the same Scripting API than usual. It is recommended to be familiar with QML, Qt Quick (for instance by going through the QML Book) and ossia score’s scripting before making your own UI. ",
    "url": "https://ossia.io/score-docs/custom-ui.html#custom-uis",
    "relUrl": "/custom-ui.html#custom-uis"
  },"288": {
    "doc": "Custom UI",
    "title": "UI objects",
    "content": "In addition to the normal console scripting API, accessible through the global Score object, the UI mode introduces the Score.UI namespace with a few useful types: . | Score.UI.PortSource allows to read and write input controls from the score. If read, the displayed value will be the current execution value, thus the score has to play. Ports are located by label or by name. | Score.UI.PortSink allows to read and write output controls from the score. If read, the displayed value will be the current execution value, thus the score has to play. | Score.UI.AddressSource allows to read and write addresses from the device explorer. | . ",
    "url": "https://ossia.io/score-docs/custom-ui.html#ui-objects",
    "relUrl": "/custom-ui.html#ui-objects"
  },"289": {
    "doc": "Custom UI",
    "title": "Running with a custom UI",
    "content": "For now the UI is passed as a command-line argument to a QML file: . $ ./score --ui path/to/my/ui.qml path/to/my/document.score . ",
    "url": "https://ossia.io/score-docs/custom-ui.html#running-with-a-custom-ui",
    "relUrl": "/custom-ui.html#running-with-a-custom-ui"
  },"290": {
    "doc": "Custom UI",
    "title": "Basic example",
    "content": "This example will create a basic UI which interoperates with the following score: download it here. Save the content of the QML file below as custom-ui.qml and run with: . $ ./score --ui custom-ui.qml custom-ui.score . You should see the following display: . The first dial controls a parameter of an ISF shader. The last dial sends messages to the OSC address /bar on port 9996. import QtQuick import QtQuick.Controls import Score.UI as UI Rectangle { color: \"white\" width: 640 height: 480 Component.onCompleted: Score.play(); Column { Label { text: \"Operating a control:\" } Dial { UI.PortSource on value { process: \"52.39\" port: 1 } } Label { text: \"Reading the value of a control inlet:\" } Label { UI.PortSource on text { process: \"LFO\" port: \"Ampl.\" } } Label { text: \"Reading the value of any outlet by adding a value display:\" } Label { UI.PortSource on text { process: \"Value display\" port: 0 } } Label { text: \"Reading the value of any address:\" } Label { UI.AddressSource on text { address: \"OSC:/foo\" sendUpdates: false } } Label { text: \"Setting the value of any address:\" } Dial { UI.AddressSource on value { address: \"OSC:/bar\" receiveUpdates: false } } } } . ",
    "url": "https://ossia.io/score-docs/custom-ui.html#basic-example",
    "relUrl": "/custom-ui.html#basic-example"
  },"291": {
    "doc": "Custom UI",
    "title": "Custom UI",
    "content": " ",
    "url": "https://ossia.io/score-docs/custom-ui.html",
    "relUrl": "/custom-ui.html"
  },"292": {
    "doc": "DBAP",
    "title": "Distance-Based Amplitude Panning (DBAP)",
    "content": "TODO . ",
    "url": "https://ossia.io/score-docs/processes/dbap.html#distance-based-amplitude-panning-dbap",
    "relUrl": "/processes/dbap.html#distance-based-amplitude-panning-dbap"
  },"293": {
    "doc": "DBAP",
    "title": "Related Processes",
    "content": ". | GBAP - Distance-based panning for irregular layouts | Matrix - Audio routing and mixing | Multi-Cursor - Multiple position sources | Path Generator - Automated trajectories | . ",
    "url": "https://ossia.io/score-docs/processes/dbap.html#related-processes",
    "relUrl": "/processes/dbap.html#related-processes"
  },"294": {
    "doc": "DBAP",
    "title": "DBAP",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/dbap.html",
    "relUrl": "/processes/dbap.html"
  },"295": {
    "doc": "Development",
    "title": "\nscore development manual",
    "content": "This section of the manual gives an overview of the score development processes. It explains how to make a local build, create a plug-in, discusses the software architecture, etc. ",
    "url": "https://ossia.io/score-docs/development#score-development-manual",
    "relUrl": "/development#score-development-manual"
  },"296": {
    "doc": "Development",
    "title": "Development",
    "content": " ",
    "url": "https://ossia.io/score-docs/development",
    "relUrl": "/development"
  },"297": {
    "doc": "Devices",
    "title": "Devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices.html",
    "relUrl": "/devices.html"
  },"298": {
    "doc": "Devices",
    "title": "What are devices ?",
    "content": "Devices are pieces of software or hardware used in your project to be controlled from score or used as input for your score scenario. Score currently support the following devices types: . | Network | Utilities | Hardware | Web | Lights | Audio | Video | . | OSCQuery | Mapper | Midi in | HTTP | Artnet | Audio | Window | . | OSC | Local | Midi out | WS |   |   | Camera | . | Minuit |   | Serial |   |   |   | Spout | . | CoAP |   | Joystick |   |   |   | Syphon | . | MQTT |   | Wiimote |   |   |   | Shmdata | . |   |   | GPS |   |   |   | NDI | . |   |   | Leapmotion |   |   |   |   | . |   |   | Raw I/O |   |   |   |   | . |   |   | BLE |   |   |   |   | . ",
    "url": "https://ossia.io/score-docs/devices.html#what-are-devices-",
    "relUrl": "/devices.html#what-are-devices-"
  },"299": {
    "doc": "Devices",
    "title": "Setting up devices",
    "content": "From score main window, right-click in the Device explorer on the left of window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. In the Device setup window, in the left column, select the desired device type. Each device type has its setup panel depending of the used protocol. Please see the relevant device reference page to setup your device. ",
    "url": "https://ossia.io/score-docs/devices.html#setting-up-devices",
    "relUrl": "/devices.html#setting-up-devices"
  },"300": {
    "doc": "Display Utilities",
    "title": "Display Utilities",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/processes/display-utilities.html",
    "relUrl": "/processes/display-utilities.html"
  },"301": {
    "doc": "Easetanbul",
    "title": "Easetanbul",
    "content": ". Create smooth transitions between values with professional easing curves. Instead of abrupt parameter changes, Easetanbul provides fluid, organic movement that feels natural and polished. Essential for creating smooth animations, gentle parameter transitions, or any time you need to interpolate between different values with precise timing control. ",
    "url": "https://ossia.io/score-docs/processes/easetanbul.html",
    "relUrl": "/processes/easetanbul.html"
  },"302": {
    "doc": "Easetanbul",
    "title": "Related processes",
    "content": "Tweener is the value alter-ego of Easetanbul: while Easetanbul tweens between incoming values, Tweener tweens between its two inlets. Automation allows to tween but only between one value known in advance and one unknown, Easetanbul instead tweens continuously between incoming values. ",
    "url": "https://ossia.io/score-docs/processes/easetanbul.html#related-processes",
    "relUrl": "/processes/easetanbul.html#related-processes"
  },"303": {
    "doc": "Easetanbul",
    "title": "Try it!",
    "content": "Try it by downloading this simple example!. ",
    "url": "https://ossia.io/score-docs/processes/easetanbul.html#try-it",
    "relUrl": "/processes/easetanbul.html#try-it"
  },"304": {
    "doc": "Embedded devices",
    "title": "Hardware support",
    "content": "ossia score supports running on ARM under Raspberry Pi 3 and 4. We recommend a Raspberry Pi 4 for much better performance for audio processing, as well as better support for graphics feature due to its more advanced GPU. Note that builds are provided for both 32-bit (ARMv7) and 64-bit (AArch64): make sure to download the one matching the OS you installed on your Raspberry Pi. The 32-bit build works on Debian Buster and Bullseye ; the 64-bit build will only work on Debian Bullseye. Other embedded boards will also likely work, they have just not been tested yet. If Qt runs on the hardware then most likely score will also run – see the following page for the reference hardware supported by Qt: . https://doc.qt.io/QtForDeviceCreation/qtdc-supported-platforms.html . Please report to us if you try to build and run score on any other kind of exotic system ! . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#hardware-support",
    "relUrl": "/in-depth/embedded.html#hardware-support"
  },"305": {
    "doc": "Embedded devices",
    "title": "Running on the Raspberry Pi (Raspbian)",
    "content": "Raspberry Pi 3 and 4 pre-made builds are accessible on Github Actions. Pi Zero, 1, 2 can technically work but no builds are currently being made for them. To use ossia score on the Pi, it is necessary to: . | Use an up-to-date Raspbian Buster distribution (Stretch is not supported). You can follow this guide. | Update the firmware to the kernel 5.10 at least: sudo rpi-update and reboot. | Enable Full KMS OpenGL settings in sudo raspi-config. Launch the utility, go to 6 Advanced Options, then GL Driver, then select GL (Full KMS) and reboot. Check this link for more information on the configuration process. | . If done correctly, /boot/config.txt should contain the following uncommented line near the end: . dtoverlay=vc4-kms-v3d . Then you are good to go. Two scripts are provided: ossia-score-x11 and ossia-score-eglfs. | ossia-score-x11 is for running under the normal desktop environment of the Pi. | ossia-score-eglfs will run the graphics pipeline full-screen, bypassing the desktop environment entirely, which can be much more efficient - you don’t even need to run X11 that way. But it is mostly useful in player mode, not for the score edition as there won’t be any window borders / chrome. | . Note that we recommend not using the default Pi desktop environment: in our testing, switching to a lighter environment such as i3wm or fluxbox instead of the default Pi desktop made a large difference in performance and drop-outs for the scores. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#running-on-the-raspberry-pi-raspbian",
    "relUrl": "/in-depth/embedded.html#running-on-the-raspberry-pi-raspbian"
  },"306": {
    "doc": "Embedded devices",
    "title": "Dependencies for minimal RPi installs",
    "content": "If you installed an OS without any GUI on your Raspberry, some packages may be missing at first when launching score. You can install them with the following command: . $ sudo apt install libasound2 libblkid1 libbsd0 libc6 libdbus-1-3 libdouble-conversion1 libdrm2 libevdev2 libexpat1 libffi6 libgbm1 libgcc1 libgcc-8-dev libgcrypt20 libgles2 libglib2.0-0 libgpg-error0 libgudev-1.0-0 libinput10 libjbig0 libjpeg62-turbo liblz4-1 liblzma5 libmount1 libmtdev1 libmd4c0 libpcre3 libselinux1 libstdc++6 libsystemd0 libtiff5 libtinfo6 libudev1 libuuid1 libwacom2 libwayland-client0 libwayland-cursor0 libwayland-egl1 libwayland-server0 libwebp6 libxcb1 libxcb-icccm4 libxcb-image0 libxcb-input0 libxcb-keysyms1 libxcb-randr0 libxcb-render0 libxcb-render-util0 libxcb-shape0 libxcb-shm0 libxcb-sync1 libxcb-util0 libxcb-xfixes0 libxcb-xinerama0 libxcb-xkb1 libxkbcommon0 libxkbcommon-x11-0 libzstd1 raspi-copies-and-fills zlib1g . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#dependencies-for-minimal-rpi-installs",
    "relUrl": "/in-depth/embedded.html#dependencies-for-minimal-rpi-installs"
  },"307": {
    "doc": "Embedded devices",
    "title": "Configuring the resolution under EGLFS",
    "content": ". | First create a config.json file with the following content: | . { \"device\": \"/dev/dri/card0\", \"pbuffers\": true, \"outputs\": [ { /* change to HDMI2 depending on the used output */ \"name\": \"HDMI1\", /* refresh rate can be specified with 1920x1080@60 for instance */ \"mode\": \"1280x720\" } ] } . | Then set the following environment variables before running ossia-score-eglfs: | . export QT_QPA_EGLFS_KMS_ATOMIC=1 export QT_QPA_EGLFS_KMS_CONFIG=$PWD/config.json . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#configuring-the-resolution-under-eglfs",
    "relUrl": "/in-depth/embedded.html#configuring-the-resolution-under-eglfs"
  },"308": {
    "doc": "Embedded devices",
    "title": "Building for the Raspberry Pi (Raspbian)",
    "content": ". | ossia score build scripts: https://github.com/ossia/score/tree/master/ci | ossia SDK build scripts (building latest Qt, FFMPEG, etc): https://github.com/ossia/sdk/tree/master/ARM/RPi4 | . They will produce binaries optimized for Pi 4, and that will also work on Pi 3. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#building-for-the-raspberry-pi-raspbian",
    "relUrl": "/in-depth/embedded.html#building-for-the-raspberry-pi-raspbian"
  },"309": {
    "doc": "Embedded devices",
    "title": "Arch Linux ARM",
    "content": "Experimental builds have been confirmed to work on Arch Linux ARM. The simplest is to use the AUR package ossia-score. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#arch-linux-arm",
    "relUrl": "/in-depth/embedded.html#arch-linux-arm"
  },"310": {
    "doc": "Embedded devices",
    "title": "Caveats",
    "content": "Some features are currently disabled – namely, VST3 support as there aren’t many Linux ARM VST3s. ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#caveats",
    "relUrl": "/in-depth/embedded.html#caveats"
  },"311": {
    "doc": "Embedded devices",
    "title": "Performance optimization",
    "content": ". | If possible do not use PulseAudio but instead use ALSA directly. | If possible use a RT kernel. | If possible run with as few processes as possible - if you can avoid running any desktop environment / X11 / Wayland it will be faster. | . ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html#performance-optimization",
    "relUrl": "/in-depth/embedded.html#performance-optimization"
  },"312": {
    "doc": "Embedded devices",
    "title": "Embedded devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/embedded.html",
    "relUrl": "/in-depth/embedded.html"
  },"313": {
    "doc": "Envelope Follower",
    "title": "Envelope Follower",
    "content": ". The Envelope Follower extracts the amplitude envelope from audio signals, converting them to control voltages suitable for modulating other parameters. Based on Kevin Ferguson’s algorithm, it provides smooth, responsive envelope detection that stays in the audio domain for CV-like control. ",
    "url": "https://ossia.io/score-docs/processes/envelope-follower.html",
    "relUrl": "/processes/envelope-follower.html"
  },"314": {
    "doc": "Envelope Follower",
    "title": "Overview",
    "content": "The Envelope Follower enables: . | Real-time envelope extraction from audio | CV-style control signal generation | Audio-reactive parameter modulation | Smooth amplitude tracking | Low-latency envelope detection | . Perfect for: . | Audio-reactive visuals | Sidechain-style effects | Dynamic parameter control | Live audio analysis | Expressive instrument design | . ",
    "url": "https://ossia.io/score-docs/processes/envelope-follower.html#overview",
    "relUrl": "/processes/envelope-follower.html#overview"
  },"315": {
    "doc": "Envelope Follower",
    "title": "Related Processes",
    "content": ". | Analysis - Audio feature extraction | Gate - Amplitude gating | Compressor - Dynamic range control | LFO - Alternative modulation source | . ",
    "url": "https://ossia.io/score-docs/processes/envelope-follower.html#related-processes",
    "relUrl": "/processes/envelope-follower.html#related-processes"
  },"316": {
    "doc": "Evdev device",
    "title": "Evdev device",
    "content": ". Access any Linux input device directly through the kernel’s evdev interface. This gives you raw access to keyboards, mice, touchpads, graphics tablets, custom hardware, and any other input device recognized by Linux. Perfect for custom hardware integration, low-latency input processing, or accessing specialized input devices that don’t have dedicated score support. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html",
    "relUrl": "/devices/evdev-device.html"
  },"317": {
    "doc": "Evdev device",
    "title": "Setting up an evdev device",
    "content": ". | Identify your device - Check /dev/input/event* or use evtest to find your device | Add device in the Device explorer and choose “Evdev” | Select device file - Choose the appropriate /dev/input/eventX file | Set permissions - Ensure score has read access to the device file | Test input - Interact with your device to see parameter updates | . You may need to adjust permissions or run score with appropriate privileges to access input devices. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#setting-up-an-evdev-device",
    "relUrl": "/devices/evdev-device.html#setting-up-an-evdev-device"
  },"318": {
    "doc": "Evdev device",
    "title": "Device capabilities",
    "content": "Universal input support . Any recognized device: If Linux can see it as an input device, evdev can access it. Raw event access: Get unprocessed input data directly from the kernel for minimal latency. Multiple devices: Access several input devices simultaneously for complex control setups. Hot-plug support: Automatically handle device connection and disconnection. Event types . Key events: Keyboard keys, mouse buttons, custom button inputs with press/release states. Relative motion: Mouse movement, trackball input, scroll wheel data. Absolute positioning: Graphics tablets, touchscreens, joystick axis positions. Touch events: Multi-touch data from touchscreens and trackpads. Custom events: Specialized input from custom hardware or unusual devices. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#device-capabilities",
    "relUrl": "/devices/evdev-device.html#device-capabilities"
  },"319": {
    "doc": "Evdev device",
    "title": "Creative applications",
    "content": "Custom controllers: Build unique input devices and access them directly without needing custom drivers. Graphics tablets: Use pressure-sensitive tablets for expressive control of audio effects, synthesis parameters, or visual processing. Touch interfaces: Create multi-touch installations using touchscreens or touch-sensitive surfaces. Accessibility devices: Integrate specialized accessibility hardware for inclusive interactive experiences. Industrial sensors: Access industrial input devices, sensors, or control interfaces that appear as Linux input devices. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#creative-applications",
    "relUrl": "/devices/evdev-device.html#creative-applications"
  },"320": {
    "doc": "Evdev device",
    "title": "Integration advantages",
    "content": "Low latency: Direct kernel access provides minimal input delay for time-critical applications. Full device access: Get all the data your device provides, not just what higher-level drivers expose. Custom hardware: Perfect for prototype devices, Arduino-based controllers, or custom-built interfaces. System integration: Access the same devices that other Linux applications use without conflicts. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#integration-advantages",
    "relUrl": "/devices/evdev-device.html#integration-advantages"
  },"321": {
    "doc": "Evdev device",
    "title": "Advanced features",
    "content": "Event filtering: Choose which types of events to monitor for efficient processing. Exclusive access: Optionally grab devices exclusively to prevent other applications from receiving their input. Value scaling: Automatic scaling of device-specific ranges to standard 0-1 ranges for score. State tracking: Maintain state for buttons, keys, and other stateful inputs. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#advanced-features",
    "relUrl": "/devices/evdev-device.html#advanced-features"
  },"322": {
    "doc": "Evdev device",
    "title": "Integration with score",
    "content": "Evdev works perfectly with Mapping Tool to shape raw input data into useful parameter ranges. The low-latency access makes it ideal for controlling Audio Effects that need precise timing, or DBAP/GBAP for spatial audio control. Real-time control: Direct kernel access provides the low latency needed for musical performance and real-time interaction. Custom mappings: Use Mapping Tool to create custom response curves for unusual input devices. Multi-device coordination: Combine multiple evdev devices for complex, multi-dimensional control interfaces. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#integration-with-score",
    "relUrl": "/devices/evdev-device.html#integration-with-score"
  },"323": {
    "doc": "Evdev device",
    "title": "Technical considerations",
    "content": "Permissions: Linux restricts access to input devices - you may need to add your user to the input group or set up appropriate udev rules. Device identification: Input device numbers can change between reboots - use stable identifiers or udev rules for production installations. Event formats: Different devices provide data in different formats - understanding Linux input event structures helps with complex devices. Performance: Direct kernel access is efficient, but processing many high-frequency input devices can impact performance. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#technical-considerations",
    "relUrl": "/devices/evdev-device.html#technical-considerations"
  },"324": {
    "doc": "Evdev device",
    "title": "Setup and permissions",
    "content": "User permissions: Add your user to the input group: sudo usermod -a -G input $USER . Udev rules: Create rules for consistent device naming and permissions in /etc/udev/rules.d/ . Testing: Use evtest command-line tool to verify device access and understand event formats. Security: Be aware that evdev access can potentially intercept sensitive input like passwords. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#setup-and-permissions",
    "relUrl": "/devices/evdev-device.html#setup-and-permissions"
  },"325": {
    "doc": "Evdev device",
    "title": "Troubleshooting",
    "content": "Permission denied: Check that your user has access to /dev/input/event* files - usually requires being in the input group. Device not found: Verify the device is recognized by Linux with ls /dev/input/ or cat /proc/bus/input/devices. Wrong device: Use evtest to identify which /dev/input/eventX corresponds to your specific device. Events not appearing: Some devices may need to be configured or activated before they generate events. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#troubleshooting",
    "relUrl": "/devices/evdev-device.html#troubleshooting"
  },"326": {
    "doc": "Evdev device",
    "title": "Related devices",
    "content": "Evdev provides low-level access that complements higher-level device protocols. Use alongside MIDI for musical devices, OSC for network communication, or Joystick device for standardized game controller access. ",
    "url": "https://ossia.io/score-docs/devices/evdev-device.html#related-devices",
    "relUrl": "/devices/evdev-device.html#related-devices"
  },"327": {
    "doc": "Execution engine",
    "title": "Execution engine",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/execution.html",
    "relUrl": "/in-depth/execution.html"
  },"328": {
    "doc": "Execution engine",
    "title": "libossia execution",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/execution.html#libossia-execution",
    "relUrl": "/in-depth/execution.html#libossia-execution"
  },"329": {
    "doc": "Device explorer",
    "title": "Device explorer",
    "content": "The device explorer (shortcut: Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac)) is where external devices and hardware can be interacted with and added to a score. ",
    "url": "https://ossia.io/score-docs/panels/explorer.html",
    "relUrl": "/panels/explorer.html"
  },"330": {
    "doc": "Math expressions",
    "title": "ExprTK support",
    "content": "Several processes allow to write simple math expressions. Such processes include: . | Micromap: for very simple math expressions, e.g. x * 100. | Expression Audio Generator: generates multi-channel audio. | Expression Audio Filter: filters multi-channel audio. | Expression Value Generator: generates values suitable for the device explorer on every tick. | Expression Value Filter: filters values suitable for the device explorer. | Arraygen: generates an array of values. | Arraymap: applies the function to each value of the input array. | . These expressions are evaluated within score using the ExprTK library. The expression can be written in the process built-in editor on multiple lines. Numerous math functions are available: sin, cos, abs, log, as well as the usual pi, etc. constants. ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#exprtk-support",
    "relUrl": "/processes/exprtk.html#exprtk-support"
  },"331": {
    "doc": "Math expressions",
    "title": "Audio handling",
    "content": "For audio processes, the processing is done per-frame. The input x is an array, where x[0] is the first channel, x[1] the second channel, etc. Note that ExprTK has powerful array processing features; the following two codes implement the same distortion: . // This is the syntax to get the size of the array // e.g. the number of channels here: var n := x[]; for (var i := 0; i &lt; n; i += 1) { var dist := tan(x[i]*log(1 + 200 * a)); out[i] := clamp(-1, dist, 1); } . out := clamp(-1, tan(x * log(1 + 200 * a)), 1); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-handling",
    "relUrl": "/processes/exprtk.html#audio-handling"
  },"332": {
    "doc": "Math expressions",
    "title": "Using arrays in ExprTK",
    "content": "For value processes, the same expression syntax cannot be used for single-value or array input: . | Use x, px, po to write an expression that processes single values, e.g. a float input. | Use xv, pxv, pov to write an expression that processes arrays. | . For instance: . tanh(x + 1) . will process a single float as input, while: . return [ xv[0] cos(xv[1]), xv[0] sin(xv[1]) ]; . will take a vec2 that contains polar coordinates [r, theta] and convert it into cartesian coordinates [x, y]. Note that it isn’t possible to create dynamic arrays in ExprTK. To return an array, it has to be wrapped in an array itself and then unwrapped with an Object filter: . Alternatively, the Arraygen object can be used to create an array from a generator expression. ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#using-arrays-in-exprtk",
    "relUrl": "/processes/exprtk.html#using-arrays-in-exprtk"
  },"333": {
    "doc": "Math expressions",
    "title": "Using Arraygen",
    "content": ". Arraygen will generate an array with as many elements as chosen. The expression will be used to generate each element. i represents the current element index, starting from zero and n is useable as the total count of elements. Arraygen can also return arrays: . Download the example score here. ## Using Arraymap {#arraymap} . Arraymap applies the expression to every element used as input. The same variables are useable than for Arraygen, the only difference is that triggering is bound to the presence of an input value instead of the timeline. ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#arraygen",
    "relUrl": "/processes/exprtk.html#arraygen"
  },"334": {
    "doc": "Math expressions",
    "title": "Available variables",
    "content": "Everywhere . | t: the current time in flicks. | pos: the position in the interval | . Value filter, Value generator, Audio filter, Audio generator . | a, b, c: three provided controls | pa, pb, pc: previous value of a, b, c | m1, m2, m3: three provided variables (which will keep their value across a tick) . | In the audio cases they are arrays. | . | . Value filter, Micromap, Arraymap . | x: the value of the current input if it’s a single value | px: the value of the previous input if it was a single value | po: the value of the previous output if it was a single value | dt: the time delta | . Value filter, Micromap . | xv: the value of the current input if it is an array | pxv: the value of the previous input if it was an array | pov: the value of the previous output if it was an array | . Value generator . | dt: the time delta | po: the value of the previous output | . Audio filter . | x: the value of the current sample | out: where to write the output | px: the value of the previous sample | fs: the sampling rate | . Audio generator . | out: where to write the output | fs: the sampling rate | . Arraymap, Arraygen . | i: the current index | n: the total count | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#available-variables",
    "relUrl": "/processes/exprtk.html#available-variables"
  },"335": {
    "doc": "Math expressions",
    "title": "Available functions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#available-functions",
    "relUrl": "/processes/exprtk.html#available-functions"
  },"336": {
    "doc": "Math expressions",
    "title": "\nExprTK-provided functions:",
    "content": ". | Basic math: min, max, avg, sum, abs, ceil, floor, round, roundn, exp, log, log10, logn, pow, root, sqrt, clamp, inrange, swap | Trigonometry: sin, cos, tan, acos, asin, atan, atan2, cosh, cot, csc, sec, sinh, tanh, d2r, r2d, d2g, g2d, hyp | Numeric integration and differentiation | Vector Processing: BLAS-L1 (axpy, axpby, axpb), all/any-true/false, count, rotate-left/right, shift-left/right, sort, nth_element, iota, sum, kahan-sum, dot-product, copy | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#exprtk-provided-functions",
    "relUrl": "/processes/exprtk.html#exprtk-provided-functions"
  },"337": {
    "doc": "Math expressions",
    "title": "score-provided functions",
    "content": ". | random(min, max): returns a random real number in the given interval. | random(0, 1) can be 0., 0.3, 0.23455436, 1. | round(random(1, 20)) is a 20-sided dice with lower probabilities for 1, 20. | floor(random(1, 21)) is a 20-sided dice with same probabilities for everyone. | . | noise(t, octaves, persistence): Perlin noise. | t should be something that increases ; pos is generally a good candidate. | octaves: the higher this is, the more detailed the noise is. 2 would be smooth, 7 very detailed but more computationally intensive. Between 1 and 10. | persistence: how much each octave fades. 1: no fade, very noisy. 0: very smooth. | 5 * (noise(pos * 100, 4, 0.5) - 0.5) gives a convincing fairly dynamic noise between -1 and 1. | noise(pos * 10, 3, 0.1) gives a very smooth evolution between 0 and 1. | . | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#score-provided-functions",
    "relUrl": "/processes/exprtk.html#score-provided-functions"
  },"338": {
    "doc": "Math expressions",
    "title": "Examples",
    "content": "The user library comes with a few utility functions, be sure to check them in the preset pane ! . Contributing useful functions to the library is also very welcome. | Audio Filter | Audio Generator | Value Filter | Value Generator | Micromap | Arraymap | Arraygen | . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#examples",
    "relUrl": "/processes/exprtk.html#examples"
  },"339": {
    "doc": "Math expressions",
    "title": "Value generator",
    "content": "Logistic function . Implemented as a preset (Logistic): . if(m1 == 0) { m2 := 0.8; m1 := 1; } var r := 4 * a; m2 := r * m2 * (1 - m2) . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#value-generator-1",
    "relUrl": "/processes/exprtk.html#value-generator-1"
  },"340": {
    "doc": "Math expressions",
    "title": "Value mapper",
    "content": "Add noise . Implemented as a preset (Noisify): . var rnd_m := pow(2, 31); var rnd_a := 1103515245; var rnd_c := 12345; if(m2 == 0) { m2 := 1; m1 := 12345678; } var r := (rnd_a * m1 + rnd_c) % rnd_m; m1 := r; x + a * r / (2^33); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#value-mapper",
    "relUrl": "/processes/exprtk.html#value-mapper"
  },"341": {
    "doc": "Math expressions",
    "title": "Audio generator",
    "content": "Sine wave . Implemented as a preset (Sine): . var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; out[0] := b * cos(m1[0]); out[1] := b * cos(m1[0]); . Square wave . Implemented as a preset (Square): . var phi := 2 * pi * (20 + a * 500) / fs; m1[0] += phi; var f := cos(m1[0]) &gt; 0 ? b : -b; out[0] := f; out[1] := f; . Wobbly synth . Implemented as a preset (Wobbly): . var freq_l := 225 + cos(t/(100*(a+0.1))); freq_l := 2 * pi * m1[0] * freq_l * b / fs; var freq_r := 215 + sin(t/(100*(a+0.1))); freq_r := 2 * pi * m1[0] * freq_l * b / fs; m1[0] += 1; out[0] := b * cos( freq_l ); out[1] := b * cos( freq_r ); . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-generator-1",
    "relUrl": "/processes/exprtk.html#audio-generator-1"
  },"342": {
    "doc": "Math expressions",
    "title": "Audio filter",
    "content": "Crude distortion . 2-channel version: . out[0] := clamp(0, tan(x[0]*log(1 + 200 * a)), 1); out[1] := clamp(0, tan(x[1]*log(1 + 200 * a)), 1); . Any number of channel version: . var n := x[]; for (var i := 0; i &lt; n; i += 1) { var dist := tan(x[i]*log(1 + 200 * a)); out[i] := clamp(-1, dist, 1); } . ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html#audio-filter-1",
    "relUrl": "/processes/exprtk.html#audio-filter-1"
  },"343": {
    "doc": "Math expressions",
    "title": "Math expressions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/exprtk.html",
    "relUrl": "/processes/exprtk.html"
  },"344": {
    "doc": "FAQ",
    "title": "Frequently Asked Questions",
    "content": "Here is a list of (not necessarily) frequently asked questions. In case none of these answer yours, feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/faq.html#frequently-asked-questions",
    "relUrl": "/faq.html#frequently-asked-questions"
  },"345": {
    "doc": "FAQ",
    "title": "FAQ",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq.html",
    "relUrl": "/faq.html"
  },"346": {
    "doc": "Faust",
    "title": "Faust",
    "content": ". Faust is a domain-specific programming language, tailored for writing digital signal processing code, for instance audio effects and synthesizers, super easily. It is mainly developed at Grame, with an international community of contributors. Faust DSP files can be drag’n’dropped directly inside a score. This will compile the DSP and embed it as a signal processor in the score. Additionally, any .dsp file found recursively in the library folder will be detected and added under the Faust section in the process library. Faust code can be edited directly from within the user interface, by clicking on the small “window” icon on the node header. One must press “Compile” when the code is ready to update it to the audio engine. ",
    "url": "https://ossia.io/score-docs/processes/faust.html",
    "relUrl": "/processes/faust.html"
  },"347": {
    "doc": "Faust",
    "title": "Important links",
    "content": ". | Faust website &amp; docs | User library | . ",
    "url": "https://ossia.io/score-docs/processes/faust.html#important-links",
    "relUrl": "/processes/faust.html#important-links"
  },"348": {
    "doc": "Faust",
    "title": "Video tutorial",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/faust.html#video-tutorial",
    "relUrl": "/processes/faust.html#video-tutorial"
  },"349": {
    "doc": "Faust",
    "title": "Faust packages",
    "content": "It is possible to provide new Faust libraries as score packages. This is done for instance with Alain Bonardi’s abclib which is packaged here : most importantly, the library folder in such a package will be added to the Faust library path so that new functions can be provided. ",
    "url": "https://ossia.io/score-docs/processes/faust.html#faust-packages",
    "relUrl": "/processes/faust.html#faust-packages"
  },"350": {
    "doc": "GBAP",
    "title": "Grid-Based Amplitude Panning (GBAP)",
    "content": ". GBAP (Grid-Based Amplitude Panning) is a spatial audio technique that distributes sound across a regular grid of speakers or virtual sound sources. It calculates amplitude weights based on the proximity of a sound source to grid points, enabling intuitive 2D spatialization for installations, concerts, and immersive audio environments. ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#grid-based-amplitude-panning-gbap",
    "relUrl": "/processes/gbap.html#grid-based-amplitude-panning-gbap"
  },"351": {
    "doc": "GBAP",
    "title": "Moving cursor",
    "content": ". | The cursor can be dragged in 2D space using the mouse. It is also possible to click on an empty area to move the cursor. | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#moving-cursor",
    "relUrl": "/processes/gbap.html#moving-cursor"
  },"352": {
    "doc": "GBAP",
    "title": "Parameters",
    "content": ". | Gain : Gain parameter adjusts the maximum volume of the various sinks. | Roll Off : Roll Off parameter shapes how the amplitude decays across the grid. A higher roll-off value emphasizes the closest sinks while reducing the influence of distant ones. | Normalize : When enabled, the volume values are normalized so that the highest value equals 1. This ensures the panning keeps consistent energy regardless of the number of affected sinks. | Sink (X or Y) # : Defines how many sinks (speakers/outputs) are placed horizontally (X) and vertically (Y) in the 2D grid. | Sinks Size : Sets the size (width and height) of each sink’s influence zone in the grid. Larger sizes make sinks cover more area. | Cursor Size : Represents the area of influence (e.g., a sound source) within the grid. Bigger cursors affect more sinks, resulting in broader spatial panning. | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#parameters",
    "relUrl": "/processes/gbap.html#parameters"
  },"353": {
    "doc": "GBAP",
    "title": "How to add a multicursor or an path",
    "content": "To allow even more creative possibilities in sound spacialization, it is possible to integrate multiple sources and automatic trajectories thanks to MultiCursor and PathGenerator. To do this, when your Multicursor and Pathgenerator are set up, connect its output array to the second GBAP input. NOTE : When an external panel is connected to the GBAP. The array integrated in the gbap is no longer taken into account and therefore has no effect on the final result. ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#how-to-add-a-multicursor-or-an-path",
    "relUrl": "/processes/gbap.html#how-to-add-a-multicursor-or-an-path"
  },"354": {
    "doc": "GBAP",
    "title": "Inputs and Outputs",
    "content": "| Port | Type | Description | . | Cursor Position | Vec2 | X,Y position of the sound source | . | External Cursors | Array | Array of cursor positions from Multi-Cursor or Path Generator | . | Port | Type | Description | . | Gains | Float Array | Amplitude coefficients for each grid point/speaker | . | Visual | Object | Grid state for visual feedback | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#inputs-and-outputs",
    "relUrl": "/processes/gbap.html#inputs-and-outputs"
  },"355": {
    "doc": "GBAP",
    "title": "Usage Examples",
    "content": "Basic Spatialization Setup . | Add GBAP Process: Drag GBAP from Process Library | Configure Grid: Set X and Y sink count for your speaker layout | Connect Audio: Route through Matrix process to speakers | Control Position: Use mouse, MIDI, or sensors | . [Audio Source] → [Matrix] → [Speaker 1-4] ↑ [GBAP Gains] ←── [Cursor Control] . Automated Movement . Create automatic spatial trajectories: . [LFO X] → [Combine] → [GBAP] → [Speaker Gains] [LFO Y] → . Interactive Installation . Use sensor data for positioning: . [Motion Sensor] → [Scale/Filter] → [GBAP] → [Multi-Speaker Array] . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#usage-examples",
    "relUrl": "/processes/gbap.html#usage-examples"
  },"356": {
    "doc": "GBAP",
    "title": "Integration with Other Processes",
    "content": "With Multi-Cursor . Create multiple simultaneous sound sources: . [Multi-Cursor] → [GBAP] → [Combined Gains] → [Speaker Array] . With Path Generator . Automate complex spatial trajectories: . [Path Generator] → [GBAP] → [Trajectory Gains] → [Immersive Audio] . With Audio Sources . Complete spatialization chain: . [Multiple Sources] → [Audio Router] → [GBAP Processing] → [Physical Speakers] ↑ [Position Controllers] . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#integration-with-other-processes",
    "relUrl": "/processes/gbap.html#integration-with-other-processes"
  },"357": {
    "doc": "GBAP",
    "title": "Best Practices",
    "content": ". | Grid Size: Match grid dimensions to your physical speaker layout | Cursor Size: Larger cursors create smoother, wider spatialization | Normalization: Enable for consistent energy across positions | Roll-off: Tune for your room acoustics and desired focus | Real-time: GBAP is optimized for real-time performance | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#best-practices",
    "relUrl": "/processes/gbap.html#best-practices"
  },"358": {
    "doc": "GBAP",
    "title": "Troubleshooting",
    "content": ". | No output: Check Matrix routing and speaker connections | Harsh transitions: Increase cursor size or reduce roll-off | Uneven levels: Enable normalization | Performance: Reduce grid size for complex setups | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#troubleshooting",
    "relUrl": "/processes/gbap.html#troubleshooting"
  },"359": {
    "doc": "GBAP",
    "title": "Related Processes",
    "content": ". | DBAP - Distance-based panning for irregular layouts | Matrix - Audio routing and mixing | Multi-Cursor - Multiple position sources | Path Generator - Automated trajectories | . ",
    "url": "https://ossia.io/score-docs/processes/gbap.html#related-processes",
    "relUrl": "/processes/gbap.html#related-processes"
  },"360": {
    "doc": "GBAP",
    "title": "GBAP",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/gbap.html",
    "relUrl": "/processes/gbap.html"
  },"361": {
    "doc": "Geo Zones",
    "title": "Geo Zones",
    "content": ". Create interactive zones in 2D space where parameters change based on position within those zones. Define areas with different behaviors and interpolate smoothly between them as objects or people move through the space. Perfect for location-based installations, interactive floor projections, or any system where you want different behaviors in different areas of a physical or virtual space. ",
    "url": "https://ossia.io/score-docs/processes/geo-zones.html",
    "relUrl": "/processes/geo-zones.html"
  },"362": {
    "doc": "Geo Zones",
    "title": "How it works",
    "content": "Geo Zones lets you define multiple zones in a 2D coordinate system, each with its own parameter values. As a position input moves through this space, the system interpolates between zone values to create smooth transitions. Position input - XY coordinates representing location in 2D space, in latitude / longitude. Zone definition - Create zones with shapes, positions, and parameter values Blur - Smooth blending between zone parameters Multiple outputs - Different parameters can have different zone configurations . ",
    "url": "https://ossia.io/score-docs/processes/geo-zones.html#how-it-works",
    "relUrl": "/processes/geo-zones.html#how-it-works"
  },"363": {
    "doc": "Geo Zones",
    "title": "Creative applications",
    "content": "Interactive floors: Create floor projections where different areas trigger different sounds, visuals, or lighting as people walk through them. Spatial audio zones: Use position tracking to control DBAP or GBAP spatialization parameters, creating areas with different acoustic characteristics. Installation narratives: Create story-driven installations where different physical locations trigger different narrative elements or media content. Performance spaces: Design performance areas where musicians or dancers moving to different stage positions automatically affect sound or lighting parameters. Gallery interactivity: Let gallery visitors discover different content by exploring different areas of an exhibition space. ## Usage . The most important thing for the process is the definition of the zones. Zones are defined through a simple JSON syntax: . [ // Root array containing the zones { // First zone \"polygon\": [ // Points of the polygon in lat / lon [45.528668022454156, -73.59866480075671], [45.528640776488615, -73.59863261424853], [45.52871155322648, -73.59861115657641] ], // All the other members will be associated with the zone \"variable1\": 0.1, // Numbers will be interpolated depending on the blur radius \"variable2\": \"Foo\" }, { // Second zone \"polygon\": [ [45.52895895772783, -73.59866748296572], [45.52878514835371, -73.59859506332232], [45.52880409516411, -73.59868491732432], [45.528858743384646, -73.59878281795336], [45.528947213892906, -73.59873319708659] ], \"variable1\": 0.81, \"variable2\": \"Foo|Bar\" // String values act as enumerations, with | indicating that multiples values are present. }, ] . The process outputs the following: . { // If we're inside a zone: \"inside\": [ distance_to_side, distance_to_center, influence ], // If we're close enought to a zone: \"closest\": [ distance_to_side, distance_to_center, influence ], // Raw information for every zone \"per_zone\": [ [ distance_to_side, distance_to_center, influence ], // for first zone [ distance_to_side, distance_to_center, influence ], // for second zone // etc. ], // Interpolated values of the attributes set in the zone definition \"attributes\": { \"variable1\": 0.75, \"variable2_Foo\": 1.0, // One will be created for each enumeration member \"variable2_Bar\": 0.0, } } . Here is for instance a complete example of zones from a Montreal park: . [ { \"polygon\": [ [45.52890437603729, -73.59889355630321], [45.52867350296089, -73.59877343022181], [45.528668022454156, -73.59866480075671], [45.52871155322648, -73.59861115657641], [45.52878514835371, -73.59859506332232], [45.52880409516411, -73.59868491732432], [45.528858743384646, -73.59878281795336], [45.528947213892906, -73.59873319708659] ], \"volume\": 79.9, \"superficie\": 131, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.52895895772783, -73.59866748296572], [45.52878514835371, -73.59859506332232], [45.52880409516411, -73.59868491732432], [45.528858743384646, -73.59878281795336], [45.528947213892906, -73.59873319708659] ], \"volume\": 55.5, \"superficie\": 91, \"residus\": \"HeavyMetal|MatieresResiduelles\" }, { \"polygon\": [ [45.528668022454156, -73.59866480075671], [45.528640776488615, -73.59863261424853], [45.52871155322648, -73.59861115657641] ], \"volume\": 55.5, \"superficie\": 91, \"residus\": \"HeavyMetal|MatieresResiduelles\" }, { \"polygon\": [ [45.52895895772783, -73.59866748296572], [45.52893954112888, -73.59843681299044], [45.528815369301896, -73.59847838723017], [45.52891652317469, -73.59836305224253], [45.52894455188325, -73.59828660928561], [45.52894455188325, -73.59828660928561], [45.528925605120165, -73.59837646328761], [45.52896866596742, -73.59846899949862], [45.529004210716344, -73.59854812466456] ], \"volume\": 489.6, \"superficie\": 322, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.52894455188325, -73.59828660928561], [45.528925605120165, -73.59837646328761], [45.52896866596742, -73.59846899949862], [45.529004210716344, -73.59854812466456], [45.52909722189715, -73.59829331480815], [45.529001235559086, -73.5982490583594] ], \"volume\": 187, \"superficie\": 187, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.52912932168997, -73.59817932092501], [45.52920651771554, -73.59797144972636], [45.52908469510181, -73.597727368706], [45.528979626807086, -73.59791646444155], [45.529009847650784, -73.59799290739848], [45.52904210406851, -73.59802241169764] ], \"volume\": 334, \"superficie\": 334, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.528979626807086, -73.59791646444155], [45.529009847650784, -73.59799290739848], [45.52894220302412, -73.59794999205424] ], \"volume\": 120, \"superficie\": 240, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.52894423861794, -73.5975999637778], [45.528854202234676, -73.59764690243556], [45.52878671399659, -73.59777698957278], [45.52881129787547, -73.59784270369364], [45.528807696405224, -73.59793255769564], [45.52878342567628, -73.59797144972636], [45.528755396887455, -73.59803716384722], [45.52884010951448, -73.5980680092509], [45.528922942994804, -73.59797547303988] ], \"volume\": 120, \"superficie\": 240, \"residus\": \"HeavyMetal\" }, { \"polygon\": [ [45.528571878463225, -73.59710643731906], [45.52862261227488, -73.5973853870566], [45.528598341466065, -73.59742427908732], [45.52861916736876, -73.59755973064257], [45.528529130465145, -73.59758521162821], [45.52850673864912, -73.59763215028597], [45.52839806777833, -73.59764556133105], [45.52842296498062, -73.5975637539561], [45.52840621023194, -73.5974926754172], [45.528389455478276, -73.59744037234141], [45.52834827322601, -73.59739611589266], [45.52837097825894, -73.59734381281687], [45.528359860609044, -73.59728882753207] ], \"volume\": 297.5, \"superficie\": 595, \"residus\": \"MatieresResiduelles|Hydrocarbures\" }, { \"polygon\": [ [45.52839806777833, -73.59764556133105], [45.52842296498062, -73.5975637539561], [45.52840621023194, -73.5974926754172], [45.528389455478276, -73.59744037234141], [45.52834827322601, -73.59739611589266], [45.52832212337431, -73.59758789383723] ], \"volume\": 107.8, \"superficie\": 98, \"residus\": \"MatieresResiduelles|Hydrocarbures\" }, { \"polygon\": [ [45.528120752545135, -73.59679395996882], [45.528240541627376, -73.59661291086032], [45.528280158072214, -73.59669740044428], [45.5282784356087, -73.59692404710604] ], \"volume\": 87, \"superficie\": 145, \"residus\": \"Hydrocarbures\" }, { \"polygon\": [ [45.527962129571236, -73.59724859439685], [45.527847350748175, -73.59719629132105], [45.5277645156839, -73.59716544591738], [45.52791092542931, -73.597005854481] ], \"volume\": 58.5, \"superficie\": 167, \"residus\": \"MatieresResiduelles\" } ] . ",
    "url": "https://ossia.io/score-docs/processes/geo-zones.html#creative-applications",
    "relUrl": "/processes/geo-zones.html#creative-applications"
  },"364": {
    "doc": "Gestures",
    "title": "Gestures",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/processes/gestures.html",
    "relUrl": "/processes/gestures.html"
  },"365": {
    "doc": "Glossary",
    "title": "Glossary",
    "content": ". | Automation | Branch | Condition | Device | Device explorer | Graph inspector | Interval | Process | Processes explorer | Project folder | Protocol | Slot | State | Timeline | Trigger | User library | . Automation . Branch . Condition . Device . Devices are pieces of equipment you want to use with score in your creative project. These can be hardware (a Midi controller, a synthesizer) or software running locally or on the network. Device explorer . The device explorer is the left panel. This is where devices involved in your project can be set up, browsed or monitored. Graph inspector . The Graph inspector available in score’s top right panel allows to inspect a temporal object and its context. For example, select an interval on the scenario to list all attached processes. Interval . Some block of time in the scenario. Process . A process is an action used in the scenario to control some devices’ parameter or other processes’ parameters. score includes a number of processes such as breakpoint function-based automation, sub-scenarios, LFO or modulators or custom scripts. Processes explorer . The processes explorer is accessible at the left panel in score main window. This is where you can browse and select some processes to use in your scenario. Project folder . This is where you can browse the content of the current project. Protocol . Slot . State . Timeline . Trigger . User library . The User library can be accessed in the left panel in score main window. It can contains various uer defined components such as devices setups, processes, presets. ",
    "url": "https://ossia.io/score-docs/reference/glossary.html",
    "relUrl": "/reference/glossary.html"
  },"366": {
    "doc": "GPS device",
    "title": "GPS device",
    "content": ". ossia supports reading GPS data from gpsd servers. This can be used for instance to easily read the data of a GPS chip such as a BN-220 connected to a Raspberry Pi’s UART port. When connected to a GPSD instance, ossia will report latitude, longitude, number of satellites and GPS time. ",
    "url": "https://ossia.io/score-docs/devices/gps-device.html",
    "relUrl": "/devices/gps-device.html"
  },"367": {
    "doc": "Gradient Scrubber",
    "title": "Gradient Scrubber",
    "content": ". Scrub through color gradients interactively to extract colors and create dynamic color sequences. This process lets you define color gradients and then “scrub” through them with a position control, outputting the resulting colors for use in lighting, video effects, or other visual applications. Perfect for dynamic lighting control, color-based installations, or any project where you need smooth color transitions controlled by sensors, automation, or user interaction. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html",
    "relUrl": "/processes/gradient-scrubber.html"
  },"368": {
    "doc": "Gradient Scrubber",
    "title": "How it works",
    "content": "Gradient Scrubber creates a color gradient from your defined color stops, then uses a position parameter (0-1) to extract colors from any point along the gradient. Gradient definition - Set up your color gradient with multiple color stops and positions Position control - Scrub through the gradient (0.0 = start, 1.0 = end) Color output - Get RGB, HSV, or other color format outputs Interpolation - Smooth color blending between your defined stops . ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#how-it-works",
    "relUrl": "/processes/gradient-scrubber.html#how-it-works"
  },"369": {
    "doc": "Gradient Scrubber",
    "title": "Gradient creation",
    "content": "Color stops: Define key colors at specific positions along the gradient - you can have as many as needed for complex color schemes. Position mapping: Each color stop has a position value, allowing for non-uniform color distribution along the gradient. Interpolation modes: Choose between linear, cubic, or other interpolation methods for different color blending characteristics. Color spaces: Work in RGB, HSV, or other color spaces depending on your desired color transitions. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#gradient-creation",
    "relUrl": "/processes/gradient-scrubber.html#gradient-creation"
  },"370": {
    "doc": "Gradient Scrubber",
    "title": "Creative applications",
    "content": "Dynamic lighting: Control LED installations, architectural lighting, or stage lighting with smooth color transitions based on musical content, sensor data, or user interaction. Video effects: Generate color sequences for video processing, background generation, or visual effect parameters. Interactive installations: Map user gestures, sensor readings, or other control data to color gradient positions for responsive color environments. Sunset/sunrise simulation: Create natural color progressions that follow environmental or temporal patterns. Mood lighting: Generate color sequences that respond to audio content, creating synchronized lighting and sound experiences. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#creative-applications",
    "relUrl": "/processes/gradient-scrubber.html#creative-applications"
  },"371": {
    "doc": "Gradient Scrubber",
    "title": "Integration techniques",
    "content": "Sensor control: Map sensor data to gradient position using Mapping Tool - temperature sensors could control warm/cool color transitions, motion sensors could trigger color changes. Audio synchronization: Use audio analysis to drive gradient position based on music tempo, frequency content, or amplitude. Timeline automation: Automate gradient position over time for predetermined color sequences that sync with other timeline elements. Multi-gradient systems: Use multiple Gradient Scrubbers for different color aspects - one for hue, another for brightness, creating complex color evolution. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#integration-techniques",
    "relUrl": "/processes/gradient-scrubber.html#integration-techniques"
  },"372": {
    "doc": "Gradient Scrubber",
    "title": "Technical features",
    "content": "Real-time processing: Fast color interpolation suitable for high-frequency control and smooth color transitions. Multiple outputs: Simultaneous RGB, HSV, and other color format outputs for different types of devices and applications. Smooth interpolation: Advanced color blending algorithms prevent harsh transitions and color banding. Preset management: Save and recall gradient configurations for different moods, scenes, or installation requirements. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#technical-features",
    "relUrl": "/processes/gradient-scrubber.html#technical-features"
  },"373": {
    "doc": "Gradient Scrubber",
    "title": "Workflow tips",
    "content": "Color theory: Use complementary colors and natural color progressions for pleasing visual results. Position mapping: Consider using Mapping Tool to shape the position control response - ease-in/out curves can create more natural color timing. Multiple gradients: Layer different color aspects by using separate gradients for hue, saturation, and brightness control. Testing: Always test gradients with your actual lighting or display hardware, as different devices reproduce colors differently. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#workflow-tips",
    "relUrl": "/processes/gradient-scrubber.html#workflow-tips"
  },"374": {
    "doc": "Gradient Scrubber",
    "title": "Integration with lighting",
    "content": "RGB LED strips: Direct connection to RGB color outputs for pixel-perfect color reproduction. DMX lighting: Convert color outputs to DMX values for professional lighting control. Smart bulbs: Control Philips Hue, LIFX, or other smart lighting systems through HTTP or other network protocols. Projection systems: Feed color data to video systems for large-scale color projection and mapping. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#integration-with-lighting",
    "relUrl": "/processes/gradient-scrubber.html#integration-with-lighting"
  },"375": {
    "doc": "Gradient Scrubber",
    "title": "Related processes",
    "content": "Perfect companion to Mapping Tool for position control shaping, LFO for cyclical color movements, lighting device protocols for hardware control, or Video processes for visual color applications. ",
    "url": "https://ossia.io/score-docs/processes/gradient-scrubber.html#related-processes",
    "relUrl": "/processes/gradient-scrubber.html#related-processes"
  },"376": {
    "doc": "Gradient",
    "title": "Color automation",
    "content": ". This process allows to automate colors over time. ",
    "url": "https://ossia.io/score-docs/processes/gradient.html#color-automation",
    "relUrl": "/processes/gradient.html#color-automation"
  },"377": {
    "doc": "Gradient",
    "title": "Usage",
    "content": ". | Keypoints can be moved by dragging the vertical lines. | By pressing the little arrow at the top of each line, one can change the color. | Double-clicking adds a point. | Right-clicking removes a point. | . ",
    "url": "https://ossia.io/score-docs/processes/gradient.html#usage",
    "relUrl": "/processes/gradient.html#usage"
  },"378": {
    "doc": "Gradient",
    "title": "Gradient",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/gradient.html",
    "relUrl": "/processes/gradient.html"
  },"379": {
    "doc": "Graphics pipeline",
    "title": "Graphics pipeline",
    "content": "score uses Qt RHI as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, and Direct 3D 11 in a very efficient way. score shaders are written with the Interactive Shader Format specification. Video processes are combined into a dynamic render graph which is processed in a separate thread. Each process writes to a render target. ",
    "url": "https://ossia.io/score-docs/in-depth/video.html",
    "relUrl": "/in-depth/video.html"
  },"380": {
    "doc": "Graphics Utilities",
    "title": "Graphics Utilities",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/processes/graphics-utilities.html",
    "relUrl": "/processes/graphics-utilities.html"
  },"381": {
    "doc": "HDF5 Support",
    "title": "HDF5 Data Processing",
    "content": ". HDF5 (Hierarchical Data Format version 5) is a powerful file format designed for storing and managing large datasets. Ossia score provides comprehensive HDF5 support through specialized processes that can read time series data, textures, and complex multi-dimensional datasets. ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#hdf5-data-processing",
    "relUrl": "/processes/hdf5.html#hdf5-data-processing"
  },"382": {
    "doc": "HDF5 Support",
    "title": "Overview",
    "content": "The HDF5 addon enables ossia score to work with scientific datasets, sensor recordings, simulation outputs, and any hierarchically organized data. This makes score particularly powerful for data-driven art, scientific visualization, and large-scale interactive installations. ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#overview",
    "relUrl": "/processes/hdf5.html#overview"
  },"383": {
    "doc": "HDF5 Support",
    "title": "HDF5 Reader (1D) {#1d-reader}",
    "content": "The 1D HDF5 Reader process extracts time series and scalar data from HDF5 files, making it ideal for sensor data playback and scientific dataset visualization. Parameters . HDF5 File . Type: File input Extensions: *.h5 . Select the HDF5 file containing your datasets. The file is memory-mapped for efficient access to large datasets. Path . Type: Text input Default: / . Specify the path to the dataset within the HDF5 file hierarchy. Uses standard HDF5 path syntax: . | / - Root group | /dataset_name - Dataset in root | /group/subgroup/dataset - Nested dataset path | . Percentage . Type: Horizontal slider (0.0 - 1.0) Default: 0.0 . Controls playback position through the dataset as a percentage of total length. This enables scrubbing through time series data. Output . Out . Type: ossia::value Content: Current data value at the specified percentage . Returns the data value at the current playback position. Automatically handles different data types (integers, floats, strings). Usage Examples . Sensor Data Playback . HDF5 Reader (/sensors/temperature) → Data Visualization . Read temperature sensor recordings and visualize them in real-time. Scientific Dataset Analysis . HDF5 Reader (/experiment/results/trial_1) → Statistical Analysis → OSC Output . Extract experimental results and send to analysis software via OSC. Environmental Monitoring . HDF5 Reader (/weather/wind_speed) → Conditional Logic → Wind Effect Trigger . Use weather data to trigger environmental effects in an installation. ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#hdf5-reader-1d-1d-reader",
    "relUrl": "/processes/hdf5.html#hdf5-reader-1d-1d-reader"
  },"384": {
    "doc": "HDF5 Support",
    "title": "HDF5 Texture Reader",
    "content": "The HDF5 Texture Reader process extracts image and texture data from HDF5 files, enabling visualization of 2D datasets, medical imaging data, and generated imagery. Parameters . HDF5 File . Type: File input Extensions: *.h5 . Select the HDF5 file containing texture/image datasets. Path . Type: Text input Default: / . Path to the image dataset within the HDF5 file. The dataset should contain 2D or 3D arrays representing image data. Percentage . Type: Horizontal slider (0.0 - 1.0) Default: 0.0 . For image sequences or 3D volumes, controls which frame/slice to display. Output . Out . Type: RGBA Texture Content: Image data as GPU texture . Provides the extracted image as a GPU-ready texture for immediate use in visual processes. Usage Examples . Medical Imaging . HDF5 Texture Reader (/mri/brain_scan) → ISF Shader → 3D Visualization . Display MRI brain scans with custom visualization shaders. Scientific Visualization . HDF5 Texture Reader (/simulation/heat_map) → Color Mapping → Display . Visualize simulation results as heat maps or false-color images. Generative Art . HDF5 Texture Reader (/generated/patterns) → Texture Effects → Output . Use procedurally generated textures stored in HDF5 format. ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#texture-reader",
    "relUrl": "/processes/hdf5.html#texture-reader"
  },"385": {
    "doc": "HDF5 Support",
    "title": "Technical Details",
    "content": "HDF5 Features Supported . Data Types . | Integers: 8, 16, 32, 64-bit signed and unsigned | Floating Point: 32 and 64-bit IEEE 754 | Strings: Variable and fixed-length strings | Arrays: Multi-dimensional arrays of any supported type | . File Structure . | Groups: Hierarchical organization like directories | Datasets: Arrays of homogeneous data | Attributes: Metadata attached to groups or datasets | Links: References to other objects in the file | . Performance Features . | Memory Mapping: Efficient access to large files | Chunking: Optimized storage for partial reads | Compression: Built-in compression support (gzip, szip, LZF) | Parallel Access: Thread-safe reading from multiple processes | . Data Access Patterns . Time Series Access . For 1D time series data: . percentage = 0.0 → first sample percentage = 0.5 → middle sample percentage = 1.0 → last sample . Image Sequence Access . For 3D image stacks: . percentage = 0.0 → first image percentage = 0.5 → middle image percentage = 1.0 → last image . Multi-dimensional Indexing . Use ossia’s destination indexing syntax for complex datasets: . /dataset[0][5][2] → specific element access /dataset[0:10][5] → slice access . ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#technical-details",
    "relUrl": "/processes/hdf5.html#technical-details"
  },"386": {
    "doc": "HDF5 Support",
    "title": "Integration Workflows",
    "content": "Scientific Data Pipeline . Data Collection → HDF5 Export → HDF5 Reader → Analysis → Visualization . Real-time Monitoring . Sensor Array → HDF5 Writer → HDF5 Reader → Dashboard → Alerts . Artistic Interpretation . Scientific Data → HDF5 Reader → Data Sonification → Audio Output Mathematical Model → HDF5 Texture Reader → Visual Art → Display . ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#integration-workflows",
    "relUrl": "/processes/hdf5.html#integration-workflows"
  },"387": {
    "doc": "HDF5 Support",
    "title": "Advanced Usage",
    "content": "Dataset Exploration . Use HDF5 tools to explore file structure: . h5dump -n file.h5 # List all objects h5ls -r file.h5 # Recursive listing h5stat file.h5 # File statistics . Custom Data Preparation . import h5py import numpy as np # Create time series dataset with h5py.File('timeseries.h5', 'w') as f: data = np.sin(np.linspace(0, 10*np.pi, 1000)) f.create_dataset('/sensor/temperature', data=data) # Create image sequence with h5py.File('images.h5', 'w') as f: frames = np.random.rand(100, 480, 640, 3) # 100 frames f.create_dataset('/animation/frames', data=frames) . Performance Optimization . | Chunking: Store data in optimal chunk sizes for your access patterns | Compression: Use appropriate compression for your data type | Memory: Monitor RAM usage with very large datasets | Caching: HDF5 automatically caches frequently accessed data | . ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#advanced-usage",
    "relUrl": "/processes/hdf5.html#advanced-usage"
  },"388": {
    "doc": "HDF5 Support",
    "title": "Best Practices",
    "content": "File Organization . | Use descriptive group and dataset names | Include metadata as attributes | Document units and data types | Use consistent naming conventions | . Performance . | Choose appropriate chunk sizes (typically 10KB - 1MB) | Enable compression for large datasets | Use memory mapping for read-only access | Profile access patterns for optimization | . Data Integrity . | Validate data ranges and types | Include checksums when available | Use HDF5’s built-in error detection | Backup important datasets | . ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#best-practices",
    "relUrl": "/processes/hdf5.html#best-practices"
  },"389": {
    "doc": "HDF5 Support",
    "title": "Related Processes",
    "content": ". | Data Processing: Statistical analysis of HDF5 datasets | Visualization: Real-time plotting and graphing | Export: Converting ossia data to HDF5 format | Network: Streaming HDF5 data over protocols | . ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html#related-processes",
    "relUrl": "/processes/hdf5.html#related-processes"
  },"390": {
    "doc": "HDF5 Support",
    "title": "HDF5 Support",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/hdf5.html",
    "relUrl": "/processes/hdf5.html"
  },"391": {
    "doc": "HTTP device",
    "title": "HTTP device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/http-device.html",
    "relUrl": "/devices/http-device.html"
  },"392": {
    "doc": "Image process",
    "title": "Image Process",
    "content": ". This process displays an image in a viewport. Multiple image processes can display their images by outputting in a single port. ",
    "url": "https://ossia.io/score-docs/processes/image.html#image-process",
    "relUrl": "/processes/image.html#image-process"
  },"393": {
    "doc": "Image process",
    "title": "Creating the process",
    "content": "The process can be created simply by dropping an image or a set of images on the score, or on an interval. If multiple images are dropped, it will be possible to switch through those with the Index control. If those images are GIFs, then the index allows to sift through the gif’s frames. Here is an example of a simple score which loops over a set of images and applies a visual effect to the output, useful for VJ purposes: . ",
    "url": "https://ossia.io/score-docs/processes/image.html#creating-the-process",
    "relUrl": "/processes/image.html#creating-the-process"
  },"394": {
    "doc": "Image process",
    "title": "Image process",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/image.html",
    "relUrl": "/processes/image.html"
  },"395": {
    "doc": "In depth",
    "title": "Advanced features",
    "content": "This chapter describes various advanced use cases for ossia score, and explains how the software works. ",
    "url": "https://ossia.io/score-docs/in-depth#advanced-features",
    "relUrl": "/in-depth#advanced-features"
  },"396": {
    "doc": "In depth",
    "title": "In depth",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth",
    "relUrl": "/in-depth"
  },"397": {
    "doc": "Home",
    "title": "Score documentation",
    "content": ". This is the documentation for ossia score 3.7.1. Browse by categories on the left, or if you are looking for a specific topic, check out the search bar at the top of the page. Disclaimer: the documentation is currently in-progress. If you spot a missing / incomplete / wrong information, or even just a spelling mistake, you can click the link at the bottom of the page which allows to submit a fix request to the documentation. In the meantime, feel more than welcome to ask for help on the ossia.io forum or send a message on the ossia score Gitter channel where you will most likely find a handful of score users and developers. If you see any issue on the documentation, please use the “Edit” link at the bottom of every page and edit directly, we will look quickly at your Github pull request :-) . You may also find some information watching the french video tutorials. ",
    "url": "https://ossia.io/score-docs/#score-documentation",
    "relUrl": "/#score-documentation"
  },"398": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "https://ossia.io/score-docs/",
    "relUrl": "/"
  },"399": {
    "doc": "Inspector",
    "title": "Inspector",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/inspector.html",
    "relUrl": "/panels/inspector.html"
  },"400": {
    "doc": "Integrations",
    "title": "Integrations",
    "content": "The following pages will detail how to use ossia score with various existing environments. ",
    "url": "https://ossia.io/score-docs/integrations",
    "relUrl": "/integrations"
  },"401": {
    "doc": "Interface overview",
    "title": "\nscore interface overview",
    "content": "Score provides a unique window embedding all main features and toolboxes. From it, you can setup how your media applications and score will communicate, observe their parameters value navigate through their namespace in a structured way, store some parameters value in snapshots, draw some automations, structure you scenario in flexible ways and more. All can be done from one of the 3 UI areas described below. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#score-interface-overview",
    "relUrl": "/quick-start/interface-overview.html#score-interface-overview"
  },"402": {
    "doc": "Interface overview",
    "title": "Explorer panel",
    "content": "On the left of score main window is the Explorer panel. This is where you can browse and manage the various contents needed for your project. It comprises 4 main sections that can be switched using the icon at the bottom: . | Device explorer: This is where you can setup the devices (hardware or software devices on the network) you want to control from score. The Device explorer also offers a way to monitor or browse devices involved in your project, inspect its parameters and their behavior. This also is where you can grab parameters you want to save in a snapshot, write automations on as explained in the following pages. | Processes explorer: This is where you can browse and select some processes to use in your scenario to control various parameters of your devices or other processes. | User library explorer. This is where you can access some user defined assets. These can be devices setups, presets, processes collections amongst other things. | Project folder: This is where you can browse the content of the current project. | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#explorer-panel",
    "relUrl": "/quick-start/interface-overview.html#explorer-panel"
  },"403": {
    "doc": "Interface overview",
    "title": "Scenario editor",
    "content": "At the center of the score window is the scenario editor. This is where you can write and edit the various parts of your project’s flexible and interactive scenario. From there you can create some snapshots by dragging some parameters from the Device explorer at a particular time frame, create some automations by dragging parameters from the Device explorer on an interval, drop some audio or video medias from your hard drive to integrate them in your scenario. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#scenario-editor",
    "relUrl": "/quick-start/interface-overview.html#scenario-editor"
  },"404": {
    "doc": "Interface overview",
    "title": "Zooming and dezooming",
    "content": "It is possible to zoom the main score horizontally and vertically. | Horizontal zoom: Ctrl+Mouse Up/Down(Win / Linux) or⌘+Mouse Up/Down(Mac) | Vertical zoom: Shift+Mouse Up/Down | . Note that it is also possible to zoom the entire UI of the software through the preferences. ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#zooming-and-dezooming",
    "relUrl": "/quick-start/interface-overview.html#zooming-and-dezooming"
  },"405": {
    "doc": "Interface overview",
    "title": "Objects inspector panel",
    "content": "On the right part of score main window is the Object inspector. It allows to dynamically inspect and setup the selected objects in the scenario. | Top part of the inspector is the structural context of the selected object. For example, the parent interval a process is attached to, the time point a state is placed on and its linked states, etc. | Bottom part are the various parameters of the selected object in the scenario: start time, duration and parameter address of an automation, source and target addresses of a mapping, its domain ranges, etc. | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#objects-inspector-panel",
    "relUrl": "/quick-start/interface-overview.html#objects-inspector-panel"
  },"406": {
    "doc": "Interface overview",
    "title": "UI controls",
    "content": ". | Use right-click to edit controls precisely. | Many controls are available: sliders, color choosers, toggles… . | . ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html#ui-controls",
    "relUrl": "/quick-start/interface-overview.html#ui-controls"
  },"407": {
    "doc": "Interface overview",
    "title": "Interface overview",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/interface-overview.html",
    "relUrl": "/quick-start/interface-overview.html"
  },"408": {
    "doc": "Interpolator",
    "title": "Interpolator",
    "content": ". This process interpolates between multiple values according to weights. ",
    "url": "https://ossia.io/score-docs/processes/interpolator.html",
    "relUrl": "/processes/interpolator.html"
  },"409": {
    "doc": "Interpolator",
    "title": "See also",
    "content": ". | Nodes can be extremely useful for obtaining weights through a visual interface. | . ",
    "url": "https://ossia.io/score-docs/processes/interpolator.html#see-also",
    "relUrl": "/processes/interpolator.html#see-also"
  },"410": {
    "doc": "Interpolator",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/interpolator.html#try-it",
    "relUrl": "/processes/interpolator.html#try-it"
  },"411": {
    "doc": "Javascript",
    "title": "Javascript support",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#javascript-support",
    "relUrl": "/processes/javascript.html#javascript-support"
  },"412": {
    "doc": "Javascript",
    "title": "Scripting in Javascript / QML.",
    "content": "score allows to write scripts using the JavaScript language. These scripts can be used to write specific processes such as value mappers, audio generators. score uses JavaScript version ES7 through QML. See the JavaScript reference for more information about the JS language. QML is a superset language of Javascript which enables very efficient integration with Qt software and thus ossia. It comes with some additional syntax (property real, etc.). See the QML Reference for more information as well as the QML Book to get started with the language. Either code directly or a path to the file can be added to the Javascript code editor - if it’s a file it will be watched for changes. JS can be used as a process both for intervals, and in states. | To add a JS process to an interval, simply drag’n’drop it from the Process Library to the interval. | To add a JS process to a state, right-click on the state in the Object Explorer, and choose “Add Process”. | . JS can also be used for generative graphics by using the whole power of QtQuick. A basic example is given below. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#scripting-in-javascript--qml",
    "relUrl": "/processes/javascript.html#scripting-in-javascript--qml"
  },"413": {
    "doc": "Javascript",
    "title": "Editing code",
    "content": "An important thing to note is that the edited script will not be saved in the scenario if there are compilation errors. This is a known issue and likely to change. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#editing-code",
    "relUrl": "/processes/javascript.html#editing-code"
  },"414": {
    "doc": "Javascript",
    "title": "General syntax",
    "content": "Every script must contain . import Score . somewhere at the top. A script defines a javascript object, with : . | Input and output ports | Callbacks that are called either regularly on every tick, or on special events (start, stop, pause, resume). | . The smallest valid empty script looks like this: . import Score Script { tick: function(token, state) { } } . The tick function’s two arguments give both timing and contextual information useful for writing algorithms. Please read the Timing page to understand the timing concepts used in ossia score, in particular how model, physical and musical dates relate to each other. Available functions . A very simple API to read / write messages from the device explorer is provided: . // Reads the current value of an address in the device explorer let value = Device.read(\"an:/address\"); console.log(JSON.stringify(value)); // Sends a value to the device explorer Device.write(\"an:/address\", 123); . Note that some types (vec2, vec3, vec4) that may be returned from the equivalent types in the device explorer require an import of QtQuick to be useable. Token object . Important note: due to the way numbers work in Javascript (that is, double-precision floating point numbers), and due to the timing units, scripts can only be expected to be accurate for representing durations no greater than 147 days. That is, if a time interval lasts a year, after 147 days the timing values returned by prev_date, date, … may not be accurate anymore. This limit is pushed back to the hard limit of 414 years when using the C++ integer-based API instead. Note that this does not affect for instance, scores with normal durations which would loop back to the beginning - permanently running installations are safe. Properties . | previous_date: the model date at which the tick starts. | date: the model date at which the tick ends | parent_duration: the nominal model duration of the closest parent interval. | offset: the model date at which we must start reading from our input. | speed: current speed (a multiplicative factor). | tempo: current tempo. | musical_start_last_signature: what is the position in quarter notes of the closest previous musical signature change to previous_date. | musical_start_last_bar: what is the position in quarter notes of the closest previous bar change to previous_date. | musical_start_position: what is the position of previous_date in quarter notes. | musical_end_last_bar: what is the position in quarter notes of the closest previous musical signature change to date. | musical_end_position: what is the position of date in quarter notes. | signature_upper: 6 in “6/8”, at the start of the tick. | signature_lower: 8 in “6/8”, at the start of the tick. | . Methods . | logical_read_duration(): how long are we reading from the model data. | physical_start(ratio): at which sample in the output must we start to write. | physical_read_duration(ratio): how many samples are we reading from the input ports. | physical_write_duration(ratio): how many samples are we writing to the output ports. | to_physical_time_in_tick(time, ratio): convert a model time into a physical time. | from_physical_time_in_tick(time, ratio): convert a time in physical dates, to a time in model dates. | in_range(time): check that the model time given is indeed in the range of this tick. | position(): where are we in relation to our parent interval. 0 is the beginning, 1 is the nominal duration. If an interval has a greater max, or is infinite, this will go beyond 1. | forward(): is the time going forward in this tick (speed &gt; 0). | backward(): is the time going backward in this tick (speed &lt; 0). | paused(): is the time going anywhere in this tick (speed == 0). Note that there is a difference between setting the speed to zero, and pressing the “pause” button - in the first case, processes will still keep being executed, just with no duration. | get_quantification_date(quant): get a model date if there is a quantification date for the requested quantification in this tick. -1 is returned if there isn’t any. | get_physical_quantification_date(quant, ratio): get a physical date if there is a quantification date for the requested quantification in this tick. -1 is returned if there isn’t any. | . State object . The state object contains global properties relevant for the whole score execution. Properties . | sample_rate: explicit. | buffer_size: explicit. | model_to_physical: the ratio to pass to the token functions going from model to physical dates. | physical_to_model: the ratio to pass to the token functions going from physical to model dates. | physical_date: how many samples have elapsed since the score has started playing. | start_date_ns: the date in nanoseconds when the score started playing. | current_date_ns: the current date in nanoseconds. | timings(token): given the token object, this gives back a timings object, which has the following properties: . | start_sample: at which index is the first sample to write in an audio buffer. | length: how many samples must be written. | . | . timings is most of the time what you need ! . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#general-syntax",
    "relUrl": "/processes/javascript.html#general-syntax"
  },"415": {
    "doc": "Javascript",
    "title": "Example of a value mapper",
    "content": "// Necessary for the Script object. // It is also possible to import QtQml and QtQuick import Score // Create our script object Script { // Define the inputs &amp; outputs - they are sub-objects of the script object ValueInlet { id: in1 } ValueOutlet { id: out1 } FloatSlider { id: slider; min: 10; max: 100; } // QML syntax for defining a floating-point constant readonly property real my_constant: 1.234 // This function is called on each tick. tick: function(token, state) { // has a message been received ? if (typeof in1.value !== 'undefined') { // print it in the console console.log(in1.value); // transform it with some math operations. var newValue = in1.value + slider.value * Math.random() + my_constant; // write it in the output out1.value = newValue; } } start: function() { console.log(\"I am called on start\"); } stop: function() { console.log(\"I am called on stop\"); } pause: function() { console.log(\"I am called on pause\"); } resume: function() { console.log(\"I am called on resume\"); } } . Note: it is also possible to access the list of messages with their precise timing, with values. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-a-value-mapper",
    "relUrl": "/processes/javascript.html#example-of-a-value-mapper"
  },"416": {
    "doc": "Javascript",
    "title": "Example of an audio generator",
    "content": "import Score Script { // Declare our inputs &amp; outputs FloatSlider { id: in1; min: 20; max: 800; init: 440; objectName: \"Frequency\" } AudioOutlet { id: out1 } // Index to keep track of the phase property real phase: 0; tick: function(token, state) { // Create an array to store our samples let arr = new Array(state.buffer_size); for (let i = 0; i &lt; state.buffer_size; ++i) arr[i] = 0; // How many samples we must write in this array // (the process could run for e.g. only frame 17 through 24 in a 128-frame buffer) const tm = state.timings(token); if(tm.length &gt; 0) { // Computer the sin() coefficient var freq = in1.value; // Notice how we get sample_rate from state. var phi = 2 * Math.PI * freq / state.sample_rate; // Fill our array for(var s = 0; s &lt; n; s++) { phase += phi; var sample = Math.sin(phase); sample = freq &gt; 0 ? sample : 0; arr[tm.start_sample + s] = 0.3 * sample; } } // Write two audio channels, which will give stereo output by default in score. out1.setChannel(0, arr); out1.setChannel(1, arr); } } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-an-audio-generator",
    "relUrl": "/processes/javascript.html#example-of-an-audio-generator"
  },"417": {
    "doc": "Javascript",
    "title": "Example of a MIDI transposer",
    "content": "See the user library: Presets/JS/transpose.qml . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-a-midi-transposer",
    "relUrl": "/processes/javascript.html#example-of-a-midi-transposer"
  },"418": {
    "doc": "Javascript",
    "title": "Port types",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#port-types",
    "relUrl": "/processes/javascript.html#port-types"
  },"419": {
    "doc": "Javascript",
    "title": "Properties common to all ports",
    "content": "FloatSlider { id: myVariableName // &lt;- how you refer to it in the javascript Code objectName: \"The name shown in the score UI\" address: \"foo:/bar/baz\" // &lt;- default address used when the object is created } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#properties-common-to-all-ports",
    "relUrl": "/processes/javascript.html#properties-common-to-all-ports"
  },"420": {
    "doc": "Javascript",
    "title": "Audio",
    "content": "Create an audio input: . AudioInlet { id: in } ... var left = in.channel(0); var right = in.channel(1); console.log(left[0]); // print the first sample of the first channel for (var value in left) { ... } . Create an audio output: . AudioOutlet { id: out } ... // set the data of channel 0 to the following: out.setChannel(0, [0.1, 0.0, 0.2, 0.0, -0.1, 0.0]); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#audio",
    "relUrl": "/processes/javascript.html#audio"
  },"421": {
    "doc": "Javascript",
    "title": "Example of fetching various timings",
    "content": "This example shows how one can access both score-relative and global-time-relative timing information from a JS script. import Score Script { ValueInlet { id: in1 } ValueOutlet { id: out1; objectName: \"logical\" } ValueOutlet { id: out2; objectName: \"physical\" } property int samples_since_beginning: 0 tick: function(token, state) { // Logical time: this time is affected // by the speed sliders in score. // The unit is the Flick. out1.value = token.date; // Logical time in seconds: out1.value = token.date / 705600000; // Physical time: the time in real-world clock since the interval started playing. // The physical time unit is the audio sample. samples_since_beginning += state.buffer_size; out2.value = samples_since_beginning; // Physical time in seconds: out2.value = samples_since_beginning / state.sample_rate; } } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#example-of-fetching-various-timings",
    "relUrl": "/processes/javascript.html#example-of-fetching-various-timings"
  },"422": {
    "doc": "Javascript",
    "title": "MIDI",
    "content": "Create a MIDI input: . MidiInlet { id: in } ... var messages = in.messages(); for (var message in messages) { // Print the MIDI bytes console.log(message[0], message[1], message[2]); } . Create a MIDI output: . MidiOutlet { id: out } ... // push a new message out.add([144, 64, 127]); // set &amp; replace all the messages to be pushed out.setMessages([ [144, 64, 127], [144, 68, 127], [127, 30, 0] ]); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#midi",
    "relUrl": "/processes/javascript.html#midi"
  },"423": {
    "doc": "Javascript",
    "title": "Messages",
    "content": "Receiving: . ValueInlet { id: in } ... // Print the latest message received console.log(in.value()); // Iterate through all the messages received for this tick, with their timestamp for (var message in in.values) { console.log(message.timestamp, message.value); } . Sending: . ValueOutlet { id: out } ... // Use either out.setValue(1.234); // or out.addValue(timestamp, 1.234); . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#messages",
    "relUrl": "/processes/javascript.html#messages"
  },"424": {
    "doc": "Javascript",
    "title": "Controls",
    "content": "Controls behave exactly like ValueInlet but show up as actual UI controls. They have as such relevant properties: min, max, etc. FloatSlider { min: 0.0 max: 1.0 init: 0.5 } . IntSlider { min: 0 max: 127 init: 0 } . Enum { choices: [\"foo\", \"bar\", \"baz\"] index: 2 } . Toggle { checked: true } . LineEdit { text: \"Hello world\" } . ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#controls",
    "relUrl": "/processes/javascript.html#controls"
  },"425": {
    "doc": "Javascript",
    "title": "Generative graphics",
    "content": "TextureOutlet { item: Rectangle { } } . Adding a TextureOutlet ports turns the JS object into a GPU one - rendering will be performed by Qt Quick in the GPU thread. Note that it will not run if not connected to a graphical output! . Any QtQuick item can be put as item. Here is an example of a basic animated rectangle: . import Score import QtQuick Script { TextureOutlet { objectName: \"out\" item: Rectangle { id: rect color: \"blue\" width: 100 height: 100 } } tick: function(token, state) { rect.x = ((rect.x + 1) % 100) rect.y = ((rect.y + 1) % 100) } } . When using Qt Quick Controls, it is better to use explicit namespaces as some objects have the same type name between Score and QtQuick.Controls modules. It is possible to use reactive bindings: . import Score as Score import QtQuick import QtQuick.Controls as QQC Score.Script { Score.Toggle { id: show_text objectName: \"Show text\" } Score.TextureOutlet { objectName: \"out\" item: Item { id: self anchors.fill: parent QQC.Label { anchors.bottom: parent.bottom text: self.height color: \"white\" visible: show_text.value font.pointSize: 64 } } } } . As well as interactive widgets: . import Score as Score import QtQuick import QtQuick.Controls as QQC Score.Script { Score.TextureOutlet { objectName: \"out\" item: Item { id: self anchors.fill: parent QQC.Button { anchors.centerIn: parent text: \"X\" onClicked: text = text + \"X\" } } } } . Note however that any internal state will be reset on resolution change as the items will so far be deleted and recreated since they may live on different threads. ",
    "url": "https://ossia.io/score-docs/processes/javascript.html#generative-graphics",
    "relUrl": "/processes/javascript.html#generative-graphics"
  },"426": {
    "doc": "Javascript",
    "title": "Javascript",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/javascript.html",
    "relUrl": "/processes/javascript.html"
  },"427": {
    "doc": "Joystick device",
    "title": "Joystick device",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/joystick-device.html",
    "relUrl": "/devices/joystick-device.html"
  },"428": {
    "doc": "Kinect device",
    "title": "Kinect device",
    "content": "Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/kinect-device.html",
    "relUrl": "/devices/kinect-device.html"
  },"429": {
    "doc": "Leapmotion device",
    "title": "Leapmotion device",
    "content": ". ossia supports using the Leapmotion. Right now only one sensor at a time is supported, this limit will soon be lifted. Every UltraLeap device recognized by the Gemini or Hyperion drivers are supported. | On Windows and macOS the UltraLeap drivers (Gemini or Hyperion) must be installed : https://leap2.ultraleap.com/downloads/haptics-development-kit/. Both AppleSilicon and Intel Macs are supported. | On Linux, ossia will be looking for the following Ultraleap binaries: . | . /opt/ultraleap/LeapSDK/lib/libLeaC.so.5 /opt/ultraleap/LeapSDK/lib/libLeaC.so.6 . ",
    "url": "https://ossia.io/score-docs/devices/leapmotion-device.html",
    "relUrl": "/devices/leapmotion-device.html"
  },"430": {
    "doc": "LED device",
    "title": "LED device",
    "content": ". ossia supports talking to NeoPixels over a bitbang-based SPI protocol. ",
    "url": "https://ossia.io/score-docs/devices/led-device.html",
    "relUrl": "/devices/led-device.html"
  },"431": {
    "doc": "LED View",
    "title": "LED View",
    "content": ". Visualize control signals in real-time for monitoring, debugging, and performance feedback. LED View is a monitoring tool specialized for visualizing an input array as either RGB, RGBA, or individual values between [0; 1] or [0; 255]. It is useful for instance for visualizing arrays of LEDs, or arrays with large numbers of elements where Signal Display becomes impractical. ",
    "url": "https://ossia.io/score-docs/processes/led-view.html",
    "relUrl": "/processes/led-view.html"
  },"432": {
    "doc": "LED View",
    "title": "Related processes",
    "content": "score comes with multiple processes for monitoring input data LED View, Signal Display, Value display. ",
    "url": "https://ossia.io/score-docs/processes/led-view.html#related-processes",
    "relUrl": "/processes/led-view.html#related-processes"
  },"433": {
    "doc": "LFO",
    "title": "LFO",
    "content": ". You can use the Low Frequency Oscillator in order to generate a value. This value can be used later to control other parameters. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html",
    "relUrl": "/processes/lfo.html"
  },"434": {
    "doc": "LFO",
    "title": "Frequency",
    "content": "You can change the value between 0.10 and 100 Hz. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#frequency",
    "relUrl": "/processes/lfo.html#frequency"
  },"435": {
    "doc": "LFO",
    "title": "Wave Shape",
    "content": "There are 8 different wafeforms available : sinusoidal, triangle, saw, square, sample &amp; hold and 3 noise form. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#wave-shape",
    "relUrl": "/processes/lfo.html#wave-shape"
  },"436": {
    "doc": "LFO",
    "title": "Range",
    "content": "This value can take values between 0 and 1000. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#range",
    "relUrl": "/processes/lfo.html#range"
  },"437": {
    "doc": "LFO",
    "title": "Offset",
    "content": "The offset value is between -1000 and 1000. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#offset",
    "relUrl": "/processes/lfo.html#offset"
  },"438": {
    "doc": "LFO",
    "title": "Jitter",
    "content": "Allows to add some amount of noise to the signal. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#jitter",
    "relUrl": "/processes/lfo.html#jitter"
  },"439": {
    "doc": "LFO",
    "title": "Phase",
    "content": "Allows to alter the phase of the signal. ",
    "url": "https://ossia.io/score-docs/processes/lfo.html#phase",
    "relUrl": "/processes/lfo.html#phase"
  },"440": {
    "doc": "Libav device",
    "title": "Libav device",
    "content": "Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/libav-device.html",
    "relUrl": "/devices/libav-device.html"
  },"441": {
    "doc": "Library",
    "title": "Library",
    "content": "The library is split across multiple panels: . | The Process library: Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac) | The system library: Ctrl+Shift+B(Win / Linux) or⌘+Shift+B(Mac) | The project library: Ctrl+Shift+L(Win / Linux) or⌘+Shift+L(Mac) | . ",
    "url": "https://ossia.io/score-docs/panels/library.html",
    "relUrl": "/panels/library.html"
  },"442": {
    "doc": "Library",
    "title": "Process library",
    "content": "This pane shows the processes available to add to the score: automations, audio effects, etc. Everything is there ! . The top part shows the list of available processes, grouped by category. Processes there can be dragged to the score. The middle part shows available presets for the selected processes. Presets can also be dragged to the score. The bottom part shows information on the selected process. Fast creation of effect chains . To allow easy experimentation, double-clicking on a process or preset will add it and connect it, if possible, to the currently selected process in the score, or to the currently selected port if a port is selected. If nothing is selected, the process will be added to the currently displayed interval. Note: that means that by default, if nothing is selected, the processes may go at the bottom slot and won’t be visible without scrolling to the bottom of the score. ",
    "url": "https://ossia.io/score-docs/panels/library.html#process-library",
    "relUrl": "/panels/library.html#process-library"
  },"443": {
    "doc": "Library",
    "title": "System library",
    "content": "This pane displays content shared across all scores. By default, it will be in &lt;Documents&gt;/ossia/score/packages . The location can be changed in the settings. The User Library which contains pre-existing presets will be downloaded on first launch. Please contribute to it! . Packages installed through the package manager will also go there. Various actions are possible: . | Dragging and dropping one or multiple files to the score. | Double-clicking on files. For instance, double-clicking on a .score will open it. | Right-click allows to open a folder in the system file explorer. | Dragging and dropping processes from the score: one can save a preset at a specific place by dragging from the folder preset icon. | . Here is an example of saving and loading a whole score as a preset, to embed it recursively in itself. Important folders in the default library . | Skins: contains skins which can be changed in the settings. The currently provided screens are adaptations for various colour-blindness schemes. | Util/metro_tick.wav and Util/metro_tock.wav: replace these if you want to change the sound of the metronome. | . ",
    "url": "https://ossia.io/score-docs/panels/library.html#system-library",
    "relUrl": "/panels/library.html#system-library"
  },"444": {
    "doc": "Library",
    "title": "Project library",
    "content": "This pane displays the content of the current project folder: this is simply the folder in which the edited score is saved. Otherwise, it behaves exactly like the system library. ",
    "url": "https://ossia.io/score-docs/panels/library.html#project-library",
    "relUrl": "/panels/library.html#project-library"
  },"445": {
    "doc": "Library",
    "title": "Preview",
    "content": "For now, sound files are previewed when clicking on them ; playback can be started and stopped with the little play / stop button at the bottom-left. ",
    "url": "https://ossia.io/score-docs/panels/library.html#preview",
    "relUrl": "/panels/library.html#preview"
  },"446": {
    "doc": "Running on Linux",
    "title": "Basic configuration",
    "content": "Some basic steps are usually required on Linux systems to make the most out of ossia. For instance, a lot of Linux capabilities are by default accessible only to the root user, e.g. through sudo for instance. It is generally not feasible to run score as for instance sound daemons such as JACK or PipeWire are per-user ; thus running score under another user would prevent access to sound output. The way capabilities are granted to non-root users is through the groups system. We recommend to be in the following groups (and creating them if they aren’t with groupadd \"name_of_the_group\": . | uucp and / or dialout depending on the distribution for serial port access (including access to DMX devices such as an ENTTEC USB-DMX for instance). | audio for raw access to sound and MIDI devices (usually this one is by default). | video for cameras and anything in /dev/video. | render to be able to use direct rendering through EGLFS, without e.g. X11 or Wayland. | realtime for enabling low-latency support with e.g. JACK or PipeWire. | gpio to access GPIO pins, etc. | i2c to access other raw devices. | bluetooth to use the Bluetooth support. | input to use the raw evdev input device and for some BLE devices (Bluetooth gamepads). | power if you want to be able to control e.g. turning off a computer through score directly. | . This can be done in one command: . $ sudo usermod -a -G dialout,uucp,audio,video,render,realtime,gpio,i2c,bluetooth,input,power $USER . Note that it is necessary to log-out and log-in again after it as this command does not affect the current user session. ",
    "url": "https://ossia.io/score-docs/faq/linux.html#basic-configuration",
    "relUrl": "/faq/linux.html#basic-configuration"
  },"447": {
    "doc": "Running on Linux",
    "title": "Running on Linux",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq/linux.html",
    "relUrl": "/faq/linux.html"
  },"448": {
    "doc": "Local device",
    "title": "Using score OSCQuery device",
    "content": "score exposes its scenario execution parameters through OSCQuery protocol so they can be monitored and controlled locally or from any device on the network. For example, using score’s own Device explorer, you will see when browsing available OSCQuery devices the score application and its address and port. Exposed parameters include: . | ‘exit’: close current scenario | ‘global_play’: play score’s current scenario | ‘play’: play score’s current scenario | ‘reconnect’: reconnect a device | ‘reinit’: stop score execution and recall init state | ‘running’: report whether score is playing | ‘stop’: stop scenario execution | ‘transport’: set scenario main playhead at a particular point (in ms.) | . Below is a simple Max patcher provided in ossia-max package illustrating remote control of score’s transport. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html#using-score-oscquery-device",
    "relUrl": "/devices/local-device.html#using-score-oscquery-device"
  },"449": {
    "doc": "Local device",
    "title": "More parameters in the local tree",
    "content": "In the preferences of the software, it is possible to enable the extended tree. This tree will create nodes for every interval, process, etc. This means that it will become possible to control any parameter in your score from OSC / OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html#more-parameters-in-the-local-tree",
    "relUrl": "/devices/local-device.html#more-parameters-in-the-local-tree"
  },"450": {
    "doc": "Local device",
    "title": "Local device",
    "content": "While score can synchronise and automate your media softwares and hardware, it can also be remote-controlled, should you need to control your scenario execution using some hyper advanced next generation IA software, a custom sensor interface or whatever fits your needs. ",
    "url": "https://ossia.io/score-docs/devices/local-device.html",
    "relUrl": "/devices/local-device.html"
  },"451": {
    "doc": "LSL device",
    "title": "LSL device",
    "content": "Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/devices/lsl-device.html",
    "relUrl": "/devices/lsl-device.html"
  },"452": {
    "doc": "Mapper device",
    "title": "Mapper device",
    "content": "The mapper device allows mapping the parameters between devices directly. It will operate permanently, even when the score is not running. Like other devices such as Serial, HTTP and WebSockets, it is defined in Javascript within a QML script. The basic form is: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\" } ] } ] } } . This does nothing interesting and only creates a tree with a single address: Mapper:/node/sensor . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapper-device",
    "relUrl": "/devices/mapper-device.html#mapper-device"
  },"453": {
    "doc": "Mapper device",
    "title": "Mapping a node of the mapper to another",
    "content": "This is useful to give for instance an user-readable name to another parameter. For instance, to give a name to a specific MIDI CC: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: \"MidiDevice:/1/control/45\", type: Ossia.Type.Int } ] } ] } } . Which gives: . The mapping is bidirectional: . | When MidiDevice:/1/control/45 receives a message, it is written to Mapper:/node/sensor | When Mapper:/node/sensor receives a message, it is written to MidiDevice:/1/control/45 | . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapping-a-node-of-the-mapper-to-another",
    "relUrl": "/devices/mapper-device.html#mapping-a-node-of-the-mapper-to-another"
  },"454": {
    "doc": "Mapper device",
    "title": "Custom mappings with Javascript expressions",
    "content": "If one wants to transform the value, for instance to rescale it, it is possible to use small JS snippets: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: \"MidiDevice:/1/control/45\", type: Ossia.Type.Float, // What happens when the bound parameter (MidiDevice:/1/control/45) is written to: // // When MidiDevice:/1/control/45 receives the value 64, // Mapper:/node/sensor will get the value 64 / 127, roughly 0.5. read: function(orig, v) { return v.value / 127.; }, // What happens when the mapper parameter (Mapper:/node/sensor) is written to: // // When Mapper:/node/sensor receives the value 0.5, // MidiDevice:/1/control/45 will get the value 0.5 * 127, roughly 64. write: function(v) { return v.value * 127.; } } ] } ] } } . This example will scale the 0-127 integer values of the MIDI CC to 0-1 floating point values for the Mapper. Example: . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#custom-mappings-with-javascript-expressions",
    "relUrl": "/devices/mapper-device.html#custom-mappings-with-javascript-expressions"
  },"455": {
    "doc": "Mapper device",
    "title": "Binding to multiple parameters",
    "content": "bind: can be an array. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: [\"MidiDevice:/1/control/45\", \"MidiDevice:/1/control/55\"], type: Ossia.Type.Float, // The first parameter, `orig` is the OSC address of the parameter which // was changed: it will be either \"/1/control/45\" or \"/1/control/55\". // The second parameter is the value. read: function(orig, v) { return v.value / 127.; }, // Here we now return an array of values, one for each address: // for instance, if a message \"0.5\" is sent to Mapper:/node/sensor from within score, // - MidiDevice:/1/control/45 will get 0.5 * 127 // - MidiDevice:/1/control/55 will get 0 write: function(v) { return [v.value * 127., 0]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#binding-to-multiple-parameters",
    "relUrl": "/devices/mapper-device.html#binding-to-multiple-parameters"
  },"456": {
    "doc": "Mapper device",
    "title": "Writing to arbitrary parameters",
    "content": "Sometimes one may want to map an address to another only known at run-time, depending on a message. For instance, imagine a case where you want to send messages [channel, value] to control varying MIDI channels at run-time, e.g. sending the list message [12, 45, 127] to Mapper:/node/sensor should write the CC value 127 to the CC 45 on MIDI channel 12, e.g. at the address MidiDevice:/12/control/45. This can be done by returning a list of address-value pairs from write: . [ { address: \"foo:/bar\", value: 123 }, etc... ] . In this case one must not set bind: or read: as they do not make sense: . Example: . import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", type: Ossia.Type.List, // What happens when the mapper parameter (Mapper:/node/sensor) is written to write: (v) =&gt; { // If v is [12, 45, 127], this gives: // MidiDevice:/12/control/45 let addr = `MidiDevice:/${v.value[0].value}/control/${v.value[1].value}` return [ { address: addr, value : v.value[2].value } ]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#writing-to-arbitrary-parameters",
    "relUrl": "/devices/mapper-device.html#writing-to-arbitrary-parameters"
  },"457": {
    "doc": "Mapper device",
    "title": "Mapping and combining values from multiple addresses",
    "content": "To do this, one can simply add a custom member to the QML object. For instance, here we combine two distinct addresses which represent an XY coordinate, in a single parameter of type Vec2. import Ossia 1.0 as Ossia Ossia.Mapper { // Our custom member which will contain the current value for the address. property var xy: [0.0, 0.0] function createTree() { return [ { name: \"node\", children: [ { name: \"sensor\", bind: [\"Millumin:/millumin/layer/x/instance\", \"Millumin:/millumin/layer/y/instance\"], type: Ossia.Type.Vec2f, read: function(orig, v) { // Assign to xy depending on the origin if(orig === \"/millumin/layer/x/instance\") xy[0] = v.value; if(orig === \"/millumin/layer/y/instance\") xy[1] = v.value; return xy; }, // Write to the correct addresses. \"v.value\" is a Vec2, so two floats directly write: (v) =&gt; { return [v.value[0], v.value[1]]; } } ] } ] } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#mapping-and-combining-values-from-multiple-addresses",
    "relUrl": "/devices/mapper-device.html#mapping-and-combining-values-from-multiple-addresses"
  },"458": {
    "doc": "Mapper device",
    "title": "Using the mapper device as a generator",
    "content": "The device provides an easy way to create generic generative devices with Javascript. Here is a simple example which creates a device which gives the time. The interval: property is used to define at which granularity in milliseconds the parameters will be polled. import Ossia 1.0 as Ossia Ossia.Mapper { function createTree() { return [ { name: \"hours\", type: Ossia.Type.Int, interval: 1000, // The read function() will be called every 1000 millisecond (every second) read: function() { return new Date().getHours(); } }, { name: \"minutes\", type: Ossia.Type.Int, interval: 1000, read: function() { return new Date().getMinutes(); } }, { name: \"seconds\", type: Ossia.Type.Int, interval: 200, read: function() { return new Date().getSeconds(); } } ]; } } . ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html#using-the-mapper-device-as-a-generator",
    "relUrl": "/devices/mapper-device.html#using-the-mapper-device-as-a-generator"
  },"459": {
    "doc": "Mapper device",
    "title": "Mapper device",
    "content": ". ",
    "url": "https://ossia.io/score-docs/devices/mapper-device.html",
    "relUrl": "/devices/mapper-device.html"
  },"460": {
    "doc": "Mapping Curve",
    "title": "Mapping Curve",
    "content": ". Create custom parameter mappings using an interactive curve editor. Draw curves to define exactly how input values should be transformed into output values, giving you precise control over parameter response characteristics. Perfect for creating musical controller responses, sensor calibration curves, or any situation where you need non-linear parameter transformation that goes beyond simple linear scaling. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html",
    "relUrl": "/processes/mapping-curve.html"
  },"461": {
    "doc": "Mapping Curve",
    "title": "How it works",
    "content": "Mapping Curve presents a visual editor where you can draw or edit curves that define the relationship between input and output values. The X-axis represents input values (0-1), and the Y-axis represents output values (also 0-1 by default). Input - Any control signal (0-1 range) Curve editor - Interactive graphical curve editing Output - Transformed value based on your curve Curve types - Various curve shapes and mathematical functions . ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#how-it-works",
    "relUrl": "/processes/mapping-curve.html#how-it-works"
  },"462": {
    "doc": "Mapping Curve",
    "title": "Curve editing features",
    "content": "Point editing: Click to add control points, drag to adjust curve shape, delete points to simplify curves. Curve types: Linear segments, smooth curves, step functions, or mathematical curves like exponential, logarithmic, or sine waves. Symmetry tools: Mirror curves horizontally or vertically for consistent response characteristics. Preset curves: Common curves like exponential, logarithmic, S-curves, and inverse curves available as starting points. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#curve-editing-features",
    "relUrl": "/processes/mapping-curve.html#curve-editing-features"
  },"463": {
    "doc": "Mapping Curve",
    "title": "Creative applications",
    "content": "Musical controllers: Shape MIDI controller response to feel more musical - make faders respond exponentially at low values, linearly in mid-range, and compress at high values. Sensor calibration: Create custom calibration curves for sensors that don’t have linear responses - distance sensors, light sensors, or pressure sensors often need custom curves. Expressive control: Design curves that provide fine control where you need it most - more sensitivity in certain ranges, less in others. Audio parameter shaping: Create custom response curves for audio effect parameters - make filter cutoffs respond more naturally, or create special response characteristics for creative effects. Visual effect timing: Shape animation curves for visual effects to create more natural or dramatic timing characteristics. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#creative-applications",
    "relUrl": "/processes/mapping-curve.html#creative-applications"
  },"464": {
    "doc": "Mapping Curve",
    "title": "Advanced techniques",
    "content": "Multi-segment curves: Create complex curves with different characteristics in different ranges - linear at the bottom, exponential in the middle, compressed at the top. Inverse curves: Create curves that invert normal parameter behavior for special effects or alternative control paradigms. Asymmetric responses: Design curves that respond differently to increasing versus decreasing input values for unique interactive characteristics. Micro-adjustments: Fine-tune specific regions of the curve for precise control over parameter behavior in critical ranges. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#advanced-techniques",
    "relUrl": "/processes/mapping-curve.html#advanced-techniques"
  },"465": {
    "doc": "Mapping Curve",
    "title": "Integration with score",
    "content": "Mapping Curve works perfectly with any control source - MIDI controllers, sensor data from device protocols, LFO output, or any other parameter data that needs custom shaping. Cascading curves: Chain multiple Mapping Curve processes for complex transformations that build on each other. Parallel processing: Use multiple curves to create different parameter responses from the same input source. Dynamic curves: While the curve shape is typically static, the input and output ranges can be controlled dynamically for evolving response characteristics. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#integration-with-score",
    "relUrl": "/processes/mapping-curve.html#integration-with-score"
  },"466": {
    "doc": "Mapping Curve",
    "title": "Workflow tips",
    "content": "Start simple: Begin with basic exponential or logarithmic curves before creating complex multi-segment shapes. Test thoroughly: Test your curves across the full input range to ensure they behave as expected in all conditions. Consider context: Match your curve characteristics to the intended use - smooth curves for audio parameters, step functions for discrete control, exponential curves for natural-feeling responses. Save presets: Save useful curves as presets for reuse in other projects or different parameters. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#workflow-tips",
    "relUrl": "/processes/mapping-curve.html#workflow-tips"
  },"467": {
    "doc": "Mapping Curve",
    "title": "Common curve types",
    "content": "Exponential: Fast rise at the beginning, slower at the end - good for audio volume controls. Logarithmic: Slow rise at the beginning, faster at the end - good for frequency controls. S-curve: Slow at both ends, fast in the middle - good for natural-feeling responses. Inverse: Flipped response characteristics - high input gives low output. Step functions: Discrete jumps between values - useful for switching between preset values. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#common-curve-types",
    "relUrl": "/processes/mapping-curve.html#common-curve-types"
  },"468": {
    "doc": "Mapping Curve",
    "title": "Related processes",
    "content": "Mapping Curve works with Mapping Tool for comprehensive parameter transformation, pairs with Calibrator for sensor work, and can shape the output of LFO or other control sources for more expressive parameter control. ",
    "url": "https://ossia.io/score-docs/processes/mapping-curve.html#related-processes",
    "relUrl": "/processes/mapping-curve.html#related-processes"
  },"469": {
    "doc": "Mapping tool",
    "title": "Mapping Tool",
    "content": ". The swiss-army knife of parameter transformation. This process takes incoming values and maps them to completely different ranges, with intelligent learning, curve shaping, and deadzone handling. Think of it as a super-powered version of the Range Mapper with automatic calibration. You can drag’n’drop this into your score whenever you need to: . | Calibrate sensors automatically by learning their actual ranges | Shape controller responses with mathematical curves | Handle noisy inputs with deadzones | Convert between completely different parameter scales | Create complex, non-linear mappings on the fly | . Perfect for interactive installations where you don’t know exactly what ranges your sensors will produce, or when you want to fine-tune controller response curves during performance. ",
    "url": "https://ossia.io/score-docs/processes/mapping-tool.html#mapping-tool",
    "relUrl": "/processes/mapping-tool.html#mapping-tool"
  },"470": {
    "doc": "Mapping tool",
    "title": "How it works",
    "content": "Set your input range with Min and Max - or better yet, turn on Learn Min and Learn Max and let the process figure out your sensor’s actual range by watching the incoming data. The Deadzone creates a quiet area around the midpoint where small variations get ignored - great for noisy sensors or joysticks with center drift. Shape Behaviour lets you apply curves to the response: . | None: Straight linear mapping | Tanh: S-curve with soft saturation at the ends | Sin: Smooth S-curve | Asym: Asymmetric exponential for uneven response | . The Curve knob does power-law shaping - negative values give exponential curves (slow start, fast finish), positive values give logarithmic curves (fast start, slow finish). Range Behaviour controls what happens to out-of-bounds values: . | Clip: Hard limiting (most common) | Wrap: Values wrap around like a loop | Fold: Values bounce back and forth | Free: Let them go wherever they want | . Finally, Out Min and Out Max set your final output range. You can Invert the response or use Absolute Value for special cases. ",
    "url": "https://ossia.io/score-docs/processes/mapping-tool.html#how-it-works",
    "relUrl": "/processes/mapping-tool.html#how-it-works"
  },"471": {
    "doc": "Mapping tool",
    "title": "Common uses",
    "content": "Sensor calibration: Turn on Learn Min/Max, exercise your sensor through its full range, then turn learning off. The process automatically figures out the real-world range. MIDI controller shaping: Use Curve: 0.3 with Shape: Tanh to make faders feel more musical - they’ll respond more gently in the middle ranges. Noisy input cleanup: Set a small Deadzone around the midpoint to ignore small variations from sensors or controllers with drift. Creative effects: Try Wrap or Fold range behaviors with oscillating inputs for interesting cyclical effects. The processing order is: Absolute Value → Deadzone → Normalize → Range Behavior → Shape → Curve → Invert → Scale to Output. This pairs perfectly with the Calibrator for even more advanced sensor handling, or use the simpler Range Mapper when you don’t need all the bells and whistles. ",
    "url": "https://ossia.io/score-docs/processes/mapping-tool.html#common-uses",
    "relUrl": "/processes/mapping-tool.html#common-uses"
  },"472": {
    "doc": "Mapping tool",
    "title": "Mapping tool",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/mapping-tool.html",
    "relUrl": "/processes/mapping-tool.html"
  },"473": {
    "doc": "Mapping utilities",
    "title": "Mapping utilities",
    "content": ". Reference is not yet available. Feel more than welcome to ask for help on the ossia.io forum or send a message on ossia score Gitter channel where you will most likely find a handful of score users and developers. ",
    "url": "https://ossia.io/score-docs/processes/mapping-utilities.html",
    "relUrl": "/processes/mapping-utilities.html"
  },"474": {
    "doc": "Mapping (float)",
    "title": "Mapping (float)",
    "content": ". This process allows to map a float value to another, by following a transfer curve. The inspector allows to choose the expected range for input and output values. ",
    "url": "https://ossia.io/score-docs/processes/mapping.html",
    "relUrl": "/processes/mapping.html"
  },"475": {
    "doc": "Mapping (float)",
    "title": "Example",
    "content": "Consider the following setup: . When a value gets into the mapping input, it is mapped as if it was a value of the horizontal axis of the diagram, where 0 is the left and 1 is at the right, to the value of the curve being drawn, where the bottom of the process is at -100 and the top of the process is at 100. Here are a table of some of the (approximative) outputs for various inputs in the above case: . | input = 0 =&gt; output = -100 | input = 0.1 =&gt; output = -50 | input = 0.2 =&gt; output = 0 | input = 0.3 =&gt; output = 0 | input = 0.4 =&gt; output = 0 | input = 0.5 =&gt; output = 1 | … | input = 0.8 =&gt; output = 10 | input = 0.9 =&gt; output = 50 | input = 1.0 =&gt; output = 100 | . ",
    "url": "https://ossia.io/score-docs/processes/mapping.html#example",
    "relUrl": "/processes/mapping.html#example"
  },"476": {
    "doc": "Matrix",
    "title": "Matrix",
    "content": ". The Matrix process provides flexible audio routing and mixing capabilities, allowing you to route any input to any output with individual gain control. It’s essential for complex spatialization setups and multi-channel audio routing. ",
    "url": "https://ossia.io/score-docs/processes/matrix.html",
    "relUrl": "/processes/matrix.html"
  },"477": {
    "doc": "Matrix",
    "title": "Overview",
    "content": "The Matrix acts as a configurable audio router with: . | Any number of inputs and outputs | Individual gain control for each connection | Real-time automation capabilities | Integration with spatialization algorithms | Support for large-scale audio systems | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#overview",
    "relUrl": "/processes/matrix.html#overview"
  },"478": {
    "doc": "Matrix",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Audio Inputs | Audio Array | Multiple audio sources | . | Coefficients | Float Array | Routing coefficients | . | Control | Object | Automation control data | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#inputs",
    "relUrl": "/processes/matrix.html#inputs"
  },"479": {
    "doc": "Matrix",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Audio Outputs | Audio Array | Routed audio channels | . | Monitoring | Float Array | Current routing state | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#outputs",
    "relUrl": "/processes/matrix.html#outputs"
  },"480": {
    "doc": "Matrix",
    "title": "Parameters",
    "content": "| Parameter | Widget | Description | Default | Range | . | Input Count | Integer | Number of inputs | 2 | 1-128 | . | Output Count | Integer | Number of outputs | 2 | 1-128 | . | Mode | Dropdown | Routing mode | “Additive” | Additive, Replace, Multiply | . | Interpolation | Dropdown | Coefficient smoothing | “Linear” | None, Linear, Exponential | . | Fade Time | Float | Transition time (ms) | 10 | 0-1000 | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#parameters",
    "relUrl": "/processes/matrix.html#parameters"
  },"481": {
    "doc": "Matrix",
    "title": "Matrix Configuration",
    "content": "Visual Interface . The Matrix provides a grid interface where: . | Rows represent inputs | Columns represent outputs | Intersections show routing gains | Click and drag to adjust values | . Coefficient Array . The coefficient array is organized as a flat array: . [in1→out1, in1→out2, ..., in2→out1, in2→out2, ...] . For a 2x2 matrix: . [0.0, 1.0, // Input 1: silent to output 1, full to output 2 1.0, 0.0] // Input 2: full to output 1, silent to output 2 . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#matrix-configuration",
    "relUrl": "/processes/matrix.html#matrix-configuration"
  },"482": {
    "doc": "Matrix",
    "title": "Usage Examples",
    "content": "Basic Stereo Routing . Simple stereo crossfade: . [Left Channel] → [Matrix 2x2] → [Left Output] [Right Channel] → → [Right Output] . Spatialization Integration . Use with GBAP or DBAP for speaker routing: . [Audio Source] → [Matrix] → [Speaker 1] ↑ → [Speaker 2] [GBAP Gains] → [Speaker 3] → [Speaker 4] . Multi-Source Mixing . Mix multiple sources to multiple destinations: . [Source 1] → [Matrix 4x8] → [Output Bus 1-8] [Source 2] → [Source 3] → [Source 4] → . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#usage-examples",
    "relUrl": "/processes/matrix.html#usage-examples"
  },"483": {
    "doc": "Matrix",
    "title": "Automation",
    "content": "Coefficient Control . Automate individual matrix points: . [LFO] → [Scale 0-1] → [Matrix.coeff[5]] . Pattern Sequencing . Create routing patterns: . [Step Sequencer] → [Coefficient Array] → [Matrix] . Dynamic Routing . Change routing based on analysis: . [Audio Analysis] → [Threshold] → [Matrix Preset] . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#automation",
    "relUrl": "/processes/matrix.html#automation"
  },"484": {
    "doc": "Matrix",
    "title": "Presets and Scenes",
    "content": "Saving Configurations . | Set up desired routing | Right-click → “Save as Preset” | Name the configuration | . Preset Interpolation . Smoothly transition between routing configurations: . [Preset A] → [Interpolator] → [Matrix] [Preset B] → ↑ [Fade Control] . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#presets-and-scenes",
    "relUrl": "/processes/matrix.html#presets-and-scenes"
  },"485": {
    "doc": "Matrix",
    "title": "Advanced Techniques",
    "content": "Feedback Matrix . Create feedback networks (use with caution): . [Input] → [Matrix] → [Effect] → [Output] ↑ ↓ ←──────────┘ . Parallel Processing . Split signals for parallel effects: . [Input] → [Matrix 1x4] → [Effect 1] → [Matrix 4x1] → [Output] → [Effect 2] → → [Effect 3] → → [Dry Path] → . Surround Upmixing . Convert stereo to surround: . [L/R Input] → [Matrix 2x6] → [5.1 Output] ↑ [Upmix Coefficients] . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#advanced-techniques",
    "relUrl": "/processes/matrix.html#advanced-techniques"
  },"486": {
    "doc": "Matrix",
    "title": "Integration Examples",
    "content": "With Spatialization . Complete spatialization chain: . [Sources] → [Matrix] → [Speakers] ↑ [DBAP] + [GBAP] ↑ ↑ [Position] [Grid Control] . Live Performance Setup . Flexible routing for live shows: . [Instruments] → [Matrix] → [FOH] → [Monitors] → [Recording] → [Effects Send] . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#integration-examples",
    "relUrl": "/processes/matrix.html#integration-examples"
  },"487": {
    "doc": "Matrix",
    "title": "Performance Considerations",
    "content": "CPU Usage . | Increases with matrix size | Interpolation adds overhead | Use sparse matrices when possible | . Latency . | Near-zero latency for routing | Interpolation adds minimal delay | Consider fade time settings | . Memory . | Scales with input × output count | Coefficient storage is efficient | Preset storage considerations | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#performance-considerations",
    "relUrl": "/processes/matrix.html#performance-considerations"
  },"488": {
    "doc": "Matrix",
    "title": "Best Practices",
    "content": ". | Start Small: Begin with minimal routing needs | Document Routing: Label inputs/outputs clearly | Use Presets: Save common configurations | Monitor Levels: Watch for gain buildup | Test Thoroughly: Verify all routing paths | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#best-practices",
    "relUrl": "/processes/matrix.html#best-practices"
  },"489": {
    "doc": "Matrix",
    "title": "Common Patterns",
    "content": "Cross-fade Matrix . [1.0, 0.0] // A to Left [0.0, 1.0] // B to Right . Distribution Matrix . [0.5, 0.5] // Equal to both [0.5, 0.5] . Isolation Matrix . [1.0, 0.0, 0.0] // Channel isolation [0.0, 1.0, 0.0] [0.0, 0.0, 1.0] . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#common-patterns",
    "relUrl": "/processes/matrix.html#common-patterns"
  },"490": {
    "doc": "Matrix",
    "title": "Troubleshooting",
    "content": "No Audio Output . | Check coefficient values | Verify input signals | Confirm output connections | . Distortion . | Reduce coefficient sum per output | Check input levels | Enable normalization if needed | . Clicking/Popping . | Increase fade time | Use interpolation | Avoid instant large changes | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#troubleshooting",
    "relUrl": "/processes/matrix.html#troubleshooting"
  },"491": {
    "doc": "Matrix",
    "title": "Related Processes",
    "content": ". | GBAP - Grid-based panning | DBAP - Distance-based panning | Audio Mixer - Simple mixing | Mapping - Parameter control | . ",
    "url": "https://ossia.io/score-docs/processes/matrix.html#related-processes",
    "relUrl": "/processes/matrix.html#related-processes"
  },"492": {
    "doc": "Media management",
    "title": "Media management",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/media.html",
    "relUrl": "/in-depth/media.html"
  },"493": {
    "doc": "Media management",
    "title": "Paths to media",
    "content": "If the path to a media is relative, it will looked for in the project folder first. The project folder is the folder which contains the saved .score file. Special information in paths can also influence where the file is searched: . &lt;PROJECT&gt;:/foo/bar . will look in the project directory. &lt;LIBRARY&gt;:/foo/bar . will look in the user library. ",
    "url": "https://ossia.io/score-docs/in-depth/media.html#paths-to-media",
    "relUrl": "/in-depth/media.html#paths-to-media"
  },"494": {
    "doc": "Melodial",
    "title": "Melodial",
    "content": ". Generate MIDI sequences from pattern data with full polyphonic support. Melodial takes nested arrays of musical information and converts them into properly timed MIDI output, complete with chord support and musical quantization. Perfect for algorithmic composition, pattern-based sequencing, or converting data structures into musical sequences. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html",
    "relUrl": "/processes/melodial.html"
  },"495": {
    "doc": "Melodial",
    "title": "How it works",
    "content": "Melodial interprets nested array patterns where each step can contain single notes or full chords. The patterns are played back with musical timing, creating natural-feeling sequences. Pattern - Nested array structure defining your sequence: . [ [ [pitch, velocity], [pitch, velocity]] , // Chord in step 1 [ [pitch, velocity] ], // Single note in step 2 [], // Rest in step 3 [ [60, 100], [64, 80], [67, 90]] // C major chord in step 4 ] . Each inner array represents one time step, and can contain multiple note pairs for chords or single note pairs for monophonic passages. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#how-it-works",
    "relUrl": "/processes/melodial.html#how-it-works"
  },"496": {
    "doc": "Melodial",
    "title": "Pattern structure",
    "content": "Notes: Each note is defined as [pitch, velocity] where pitch is MIDI note number (0-127) and velocity is MIDI velocity (0-127). Chords: Multiple note pairs in a single step: [[60, 100], [64, 80], [67, 90]] plays C, E, and G simultaneously. Rests: Empty arrays [] create silence for that step. Pattern length: The pattern can be any length - short motifs or long sequences. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#pattern-structure",
    "relUrl": "/processes/melodial.html#pattern-structure"
  },"497": {
    "doc": "Melodial",
    "title": "Musical features",
    "content": "Polyphonic support: Full chord support with individual velocity control for each note. Musical quantization: Automatically syncs with score’s musical timeline for proper timing. Running note management: Handles note-on/off messages correctly, preventing stuck notes. Dynamic patterns: Pattern data can be modified in real-time for evolving sequences. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#musical-features",
    "relUrl": "/processes/melodial.html#musical-features"
  },"498": {
    "doc": "Melodial",
    "title": "Creative applications",
    "content": "Algorithmic composition: Generate patterns programmatically and feed them to Melodial for instant musical output. Data sonification: Convert numerical data into musical patterns - stock prices, sensor readings, or scientific data become melodies and harmonies. Interactive sequencing: Modify pattern data based on user input, sensors, or other processes for responsive musical systems. Harmonic exploration: Experiment with chord progressions and voicings by directly editing pattern data. Rhythmic patterns: Create complex polyrhythms by using patterns of different lengths. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#creative-applications",
    "relUrl": "/processes/melodial.html#creative-applications"
  },"499": {
    "doc": "Melodial",
    "title": "Advanced techniques",
    "content": "Pattern layering: Use multiple Melodial processes with different patterns for complex polyrhythmic compositions. Dynamic editing: Modify pattern data in real-time to create evolving, living musical sequences. Data conversion: Transform control data from sensors, algorithms, or other sources into pattern format for musical expression. Chord vocabulary: Build libraries of chord patterns for different harmonic styles and progressions. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#advanced-techniques",
    "relUrl": "/processes/melodial.html#advanced-techniques"
  },"500": {
    "doc": "Melodial",
    "title": "Integration with score",
    "content": "Melodial works seamlessly with: . | Software synthesizers for audio output | MIDI utilities for further processing | MIDI Filter for extracting specific elements | External MIDI devices for hardware synthesis | . The pattern data can be generated by other processes, modified by control inputs, or stored as presets for recall during performance. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#integration-with-score",
    "relUrl": "/processes/melodial.html#integration-with-score"
  },"501": {
    "doc": "Melodial",
    "title": "Technical details",
    "content": "Built with musical quantization integration, ensuring patterns play back with proper timing relative to score’s timeline. The process maintains proper MIDI state management, handling note-on/off messages cleanly even when patterns change mid-playback. Pattern modification during playback is supported - change the pattern data and hear the results on the next pattern cycle. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#technical-details",
    "relUrl": "/processes/melodial.html#technical-details"
  },"502": {
    "doc": "Melodial",
    "title": "Related processes",
    "content": "Perfect companion to MIDI utilities for sequence processing, MIDI Filter for data extraction, or data generation processes that can create pattern structures for musical output. ",
    "url": "https://ossia.io/score-docs/processes/melodial.html#related-processes",
    "relUrl": "/processes/melodial.html#related-processes"
  },"503": {
    "doc": "MIDI File Reader",
    "title": "MIDI File Reader",
    "content": ". Play MIDI files in perfect sync with your score’s timeline. This process loads standard MIDI files and plays them back with sample-accurate timing, automatically following tempo changes and providing track selection. Perfect for incorporating existing MIDI compositions into your scores, backing tracks for live performance, or using MIDI files as control data sources for other processes. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html",
    "relUrl": "/processes/midi-file-reader.html"
  },"504": {
    "doc": "MIDI File Reader",
    "title": "How it works",
    "content": "MIDI File Reader loads a MIDI file and plays it back in sync with score’s musical timeline. It automatically handles tempo conversions and provides clean note-off messages when files change. MIDI file - Load any standard MIDI file (.mid/.midi) The process automatically monitors the file for changes, so you can edit MIDI files in external software and hear updates immediately. MIDI track (1-127, default 1) - Select which track to play Most MIDI files contain multiple tracks - drums on track 10, different instruments on other tracks. Choose the track you want to hear. The output is a clean MIDI stream that can feed into synthesizers, MIDI utilities, or other MIDI-processing tools. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html#how-it-works",
    "relUrl": "/processes/midi-file-reader.html#how-it-works"
  },"505": {
    "doc": "MIDI File Reader",
    "title": "Key features",
    "content": "Timeline sync: Playback follows score’s musical position exactly - pause, scrub, or loop and the MIDI stays in sync. File monitoring: Edit your MIDI file in your DAW while score is running - changes appear immediately without reloading. Clean transitions: When switching files or tracks, hanging notes are automatically stopped to prevent stuck notes. Tempo handling: Respects the MIDI file’s tempo information and converts it to score’s timeline. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html#key-features",
    "relUrl": "/processes/midi-file-reader.html#key-features"
  },"506": {
    "doc": "MIDI File Reader",
    "title": "Creative applications",
    "content": "Backing tracks: Use MIDI file backing tracks that sync perfectly with your live audio and video elements. Control sequences: Use MIDI files as complex control data - convert note patterns into parameter automation using MIDI Filter. Multi-track playback: Use multiple MIDI File Readers to play different tracks from the same file, each feeding different synthesizers or processes. Interactive arrangements: Switch between different MIDI tracks based on user input or system state for dynamic arrangements. Template integration: Import MIDI drum patterns, bass lines, or chord progressions as starting points for new compositions. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html#creative-applications",
    "relUrl": "/processes/midi-file-reader.html#creative-applications"
  },"507": {
    "doc": "MIDI File Reader",
    "title": "Technical details",
    "content": "The process uses the MIDI file’s “ticks per beat” information to calculate sample-accurate timing. It maintains a running list of active notes to ensure clean note-off messages when files change or tracks switch. File watching works on most filesystems - save your MIDI file in Logic, Live, or any other DAW and hear the changes in score immediately. Perfect for feeding into software synthesizers, MIDI utilities for message processing, or MIDI Filter for extracting specific control data from musical sequences. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html#technical-details",
    "relUrl": "/processes/midi-file-reader.html#technical-details"
  },"508": {
    "doc": "MIDI File Reader",
    "title": "Related processes",
    "content": "Chain with MIDI utilities for note processing, use MIDI Filter to extract control data, or combine with software synthesizers for complete MIDI playback systems. Works great with Audio Effects on the synthesized output. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-reader.html#related-processes",
    "relUrl": "/processes/midi-file-reader.html#related-processes"
  },"509": {
    "doc": "MIDI File Scaler",
    "title": "MIDI File Scaler",
    "content": ". Transform MIDI notes into microtonal frequencies using Scala tuning files. This process converts standard MIDI note numbers into precise frequency values based on custom scales and keyboard mappings. Essential for microtonal music, historical temperaments, just intonation, or any musical system that goes beyond 12-tone equal temperament. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html",
    "relUrl": "/processes/midi-file-scaler.html"
  },"510": {
    "doc": "MIDI File Scaler",
    "title": "How it works",
    "content": "MIDI File Scaler takes incoming MIDI notes and converts them to frequency values based on Scala (.scl) tuning files and optional keyboard mapping (.kbm) files. Instead of outputting MIDI, it produces arrays of frequencies for active notes. MIDI messages - Input MIDI data from keyboards, files, or other sources . SCL file - Scala tuning file (.scl) defining your custom scale These files contain mathematical ratios or cent values that define each scale degree. Thousands of historical and experimental scales are available from the Scala archive. KBM file - Keyboard mapping file (.kbm) for advanced tuning control Maps which scale degrees appear on which MIDI keys, allowing complex retuning schemes. Frequency adjust (-500 to +500 cents) - Fine-tuning offset for the entire scale . Frequency scale (0.5x to 2.0x) - Global frequency scaling for transposition . ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#how-it-works",
    "relUrl": "/processes/midi-file-scaler.html#how-it-works"
  },"511": {
    "doc": "MIDI File Scaler",
    "title": "Understanding Scala files",
    "content": "SCL files define scales as mathematical relationships: . ! major_just.scl Just Major Scale 7 ! 9/8 5/4 4/3 3/2 5/3 15/8 2/1 . KBM files define keyboard mappings: . ! Map C major to white keys only 12 0 7 1 60 1 2 3 4 5 6 7 8 9 10 11 12 . These files can be found in the Scala software archive or created with tuning software. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#understanding-scala-files",
    "relUrl": "/processes/midi-file-scaler.html#understanding-scala-files"
  },"512": {
    "doc": "MIDI File Scaler",
    "title": "Creative applications",
    "content": "Just intonation: Use mathematically pure intervals for harmonically rich music that’s impossible with equal temperament. Historical temperaments: Recreate Baroque, Renaissance, or other historical tuning systems for authentic period performance. Ethnic scales: Implement traditional scales from different cultures that don’t fit 12-tone systems. Experimental microtonality: Design custom scales for unique harmonic exploration. Frequency-based synthesis: Feed the frequency outputs to oscillators that can accept frequency control rather than MIDI. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#creative-applications",
    "relUrl": "/processes/midi-file-scaler.html#creative-applications"
  },"513": {
    "doc": "MIDI File Scaler",
    "title": "Integration with score",
    "content": "The frequency array output is perfect for controlling oscillators that accept frequency input rather than MIDI. This is common in: . | Faust synthesizers that use frequency parameters | Software synthesizers with frequency modulation inputs | Custom audio processes that work with frequency arrays | Granular synthesis systems that can retune grains | . ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#integration-with-score",
    "relUrl": "/processes/midi-file-scaler.html#integration-with-score"
  },"514": {
    "doc": "MIDI File Scaler",
    "title": "Technical details",
    "content": "Built on the Surge Synthesizer’s tuning library for precise, professional-grade microtonal processing. The system handles note-on/off tracking, interpolated tunings for missing scale degrees, and proper frequency calculation for real-time performance. When using both SCL and KBM files together, the system validates compatibility and provides error handling for mismatched configurations. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#technical-details",
    "relUrl": "/processes/midi-file-scaler.html#technical-details"
  },"515": {
    "doc": "MIDI File Scaler",
    "title": "Workflow tips",
    "content": "Start simple: Begin with basic just intonation scales before exploring complex microtonal systems. Test with familiar music: Apply new tunings to melodies you know well to hear the differences clearly. Scale libraries: Build a collection of interesting SCL files for different musical projects. Frequency visualization: Use tools to visualize the frequency relationships in your custom scales. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#workflow-tips",
    "relUrl": "/processes/midi-file-scaler.html#workflow-tips"
  },"516": {
    "doc": "MIDI File Scaler",
    "title": "Related processes",
    "content": "Perfect for use with Faust processes that accept frequency control, frequency-based synthesis systems, or any process that benefits from precise frequency relationships rather than tempered MIDI notes. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scaler.html#related-processes",
    "relUrl": "/processes/midi-file-scaler.html#related-processes"
  },"517": {
    "doc": "MIDI File Scroller",
    "title": "MIDI File Scroller",
    "content": ". Scrub through MIDI files manually with position control. Instead of playing back MIDI files in real-time, MIDI File Scroller lets you “seek” to any position and hear exactly what notes would be playing at that moment. Perfect for exploring MIDI file content, creating position-based interactions, or building systems where MIDI playback is controlled by sensors, gestures, or other continuous input. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html",
    "relUrl": "/processes/midi-file-scroller.html"
  },"518": {
    "doc": "MIDI File Scroller",
    "title": "How it works",
    "content": "MIDI File Scroller loads a MIDI file and maps its entire timeline to a 0-1 position control. Move the position parameter and hear the MIDI notes that should be active at that point in the file. MIDI file - Load any standard MIDI file (.mid/.midi) The process monitors for file changes, so you can edit externally and see updates immediately. MIDI track (1-127, default 1) - Select which track to scrub through Choose different tracks to explore different instruments or parts. Position (0.0-1.0) - Manual position control through the file 0.0 = beginning of file, 1.0 = end of file. This parameter can be automated, controlled by sensors, or manipulated in real-time. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#how-it-works",
    "relUrl": "/processes/midi-file-scroller.html#how-it-works"
  },"519": {
    "doc": "MIDI File Scroller",
    "title": "Key features",
    "content": "Instant seeking: Jump to any position in the MIDI file immediately - no waiting for playback to catch up. Note duration mapping: The process understands note lengths and maintains proper note-on/off states as you scrub through. Smooth transitions: Moving the position slider creates clean note transitions without stuck or overlapping notes. File monitoring: Edit your MIDI file in external software and changes appear immediately. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#key-features",
    "relUrl": "/processes/midi-file-scroller.html#key-features"
  },"520": {
    "doc": "MIDI File Scroller",
    "title": "Creative applications",
    "content": "Interactive exploration: Let users explore musical compositions by moving sliders, sensors, or controllers - each position reveals different musical content. Gesture-based playback: Map body tracking, camera input, or sensor data to MIDI file position for expressive, non-linear musical experiences. Visual synchronization: Synchronize MIDI content with video scrubbing, image sequences, or other position-based media. Composition analysis: Study complex MIDI compositions by slowly scrubbing through sections to understand harmonic progressions and voice leading. Performance control: Use as a “tape head” that can be positioned anywhere in a musical sequence for live performance manipulation. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#creative-applications",
    "relUrl": "/processes/midi-file-scroller.html#creative-applications"
  },"521": {
    "doc": "MIDI File Scroller",
    "title": "Integration techniques",
    "content": "Sensor control: Map the position parameter to sensor data - use distance sensors, light levels, or motion tracking to control playback position. Video synchronization: Link MIDI file position to video scrubbing for synchronized audiovisual experiences. Multi-file systems: Use multiple MIDI File Scrollers to scrub through different files or tracks simultaneously. Automation curves: Draw automation curves for the position parameter to create custom, non-linear playback sequences. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#integration-techniques",
    "relUrl": "/processes/midi-file-scroller.html#integration-techniques"
  },"522": {
    "doc": "MIDI File Scroller",
    "title": "Technical details",
    "content": "The process uses interval mapping to efficiently track which notes should be active at any position. It maintains proper MIDI state, ensuring clean note-on/off messages as you move through the file. The position mapping is linear - equal position changes create equal time movement through the file, regardless of tempo changes within the MIDI file. Works perfectly with MIDI Filter to extract specific types of data, MIDI utilities for processing the output, or software synthesizers for audio generation. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#technical-details",
    "relUrl": "/processes/midi-file-scroller.html#technical-details"
  },"523": {
    "doc": "MIDI File Scroller",
    "title": "Related processes",
    "content": "Chain with MIDI utilities for note processing, use MIDI Filter to extract control data, or combine with Mapping Tool to shape the position control response for more musical scrubbing behavior. ",
    "url": "https://ossia.io/score-docs/processes/midi-file-scroller.html#related-processes",
    "relUrl": "/processes/midi-file-scroller.html#related-processes"
  },"524": {
    "doc": "MIDI Filter",
    "title": "MIDI Filter",
    "content": ". Extract exactly the MIDI data you need from complex MIDI streams. This process acts like a precision tool for filtering, converting, and organizing MIDI messages, with multiple output formats and polyphonic note tracking. Essential when you’re dealing with multi-channel MIDI keyboards, complex controllers, or when you need to convert MIDI data into control signals for other processes. ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html",
    "relUrl": "/processes/midi-filter.html"
  },"525": {
    "doc": "MIDI Filter",
    "title": "How it works",
    "content": "MIDI Filter examines incoming MIDI messages and extracts specific types of data based on your filter settings. It can track running notes, convert between formats, and output data in several different ways simultaneously. Filter type - What kind of MIDI messages to extract: . | CC: Control Change messages (knobs, faders, mod wheels) | PitchBend: Pitch bend wheel data | AfterTouch: Channel pressure (mono aftertouch) | PolyPressure: Polyphonic aftertouch (per-note pressure) | NoteOn: Note-on messages only | NoteOff: Note-off messages only | NoteAny: Both note-on and note-off | NoteRunning: Currently held notes (polyphonic state) | . Channel (0-16) - Filter by MIDI channel (0 = all channels) . Index (0-128) - Filter by parameter number (0 = all, 1-128 for specific CC numbers, note numbers, etc.) . Mode - What data to output: . | Index: Output the parameter number (which CC, which note) | Value: Output the parameter value (CC value, velocity, etc.) | Both: Output both index and value | . Note off to zero - Convert note-off messages to zero velocity note-ons (useful for some synths) . ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html#how-it-works",
    "relUrl": "/processes/midi-filter.html#how-it-works"
  },"526": {
    "doc": "MIDI Filter",
    "title": "Multiple output formats",
    "content": "MIDI Filter provides several outputs simultaneously: . Filtered MIDI - Clean MIDI stream with only your selected message types Raw output - Integer values or note structures Normalized output - Floating-point values scaled 0-1 Polyphonic output - Arrays of all currently active notes (perfect for chord analysis) . ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html#multiple-output-formats",
    "relUrl": "/processes/midi-filter.html#multiple-output-formats"
  },"527": {
    "doc": "MIDI Filter",
    "title": "Practical uses",
    "content": "CC extraction: Set Filter to “CC”, Channel to 1, Index to 74 to extract filter cutoff from a specific synthesizer channel. Polyphonic analysis: Use “NoteRunning” mode to get arrays of all currently held notes - perfect for chord recognition or harmony analysis. Multi-channel routing: Filter by channel to separate different instruments from a single MIDI stream. Velocity to control: Extract note velocities and convert to 0-1 range for controlling audio effects intensity. Aftertouch control: Use “AfterTouch” or “PolyPressure” to control parameters based on key pressure. ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html#practical-uses",
    "relUrl": "/processes/midi-filter.html#practical-uses"
  },"528": {
    "doc": "MIDI Filter",
    "title": "Advanced techniques",
    "content": "Chord detection: Use NoteRunning mode with the polyphonic output to analyze chord progressions in real-time. Multi-parameter control: Run multiple MIDI Filters in parallel to extract different CC numbers for controlling different aspects of your score. Format conversion: Use this to convert between MIDI note formats and control signals - great for using keyboards to control non-musical parameters. Chain multiple filters with different settings to create complex MIDI processing workflows, or combine with Mapping Tool to shape the extracted data for perfect parameter control. ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html#advanced-techniques",
    "relUrl": "/processes/midi-filter.html#advanced-techniques"
  },"529": {
    "doc": "MIDI Filter",
    "title": "Related processes",
    "content": "Works great with MIDI utilities, Mapping Tool for parameter shaping, Calibrator for response curves, or Mapping Curve for simple scaling. Combine with Audio Effects that respond to MIDI data. ",
    "url": "https://ossia.io/score-docs/processes/midi-filter.html#related-processes",
    "relUrl": "/processes/midi-filter.html#related-processes"
  },"530": {
    "doc": "MIDI utilities",
    "title": "MIDI utilities",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html",
    "relUrl": "/processes/midi-utilities.html"
  },"531": {
    "doc": "MIDI utilities",
    "title": "Arpeggiator",
    "content": ". The classic arpeggiator effect. Play a chord on your keyboard and let the process create new notes from it. The currently implemented modes are: . | Forward: plays the notes in order (1-2-3-1-2-3) | Backwards: plays the notes in reverse order (3-2-1-3-2-1) | F-&gt;B: first forward then backwards (1-2-3-3-2-1) | B-&gt;F: first backwards then forward (3-2-1-1-2-3) | Chord: repeats the chord currently being held | . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#arpeggiator",
    "relUrl": "/processes/midi-utilities.html#arpeggiator"
  },"532": {
    "doc": "MIDI utilities",
    "title": "Chord",
    "content": ". This process transforms an input note into a chord. For instance, if “Major” is selected: C3 -&gt; C3 E3 G3 . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#chord",
    "relUrl": "/processes/midi-utilities.html#chord"
  },"533": {
    "doc": "MIDI utilities",
    "title": "MIDI scale",
    "content": ". This process allows to transpose and make the input MIDI fit into predetermined scales, to prevent wrong notes for instance. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#midi-scale",
    "relUrl": "/processes/midi-utilities.html#midi-scale"
  },"534": {
    "doc": "MIDI utilities",
    "title": "Quantifier",
    "content": ". This process quantifies input MIDI onto the musical grid. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#quantifier",
    "relUrl": "/processes/midi-utilities.html#quantifier"
  },"535": {
    "doc": "MIDI utilities",
    "title": "MIDI pitch",
    "content": ". This process allows to extract the pitch of a MIDI note as a simple value. ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#midi-pitch",
    "relUrl": "/processes/midi-utilities.html#midi-pitch"
  },"536": {
    "doc": "MIDI utilities",
    "title": "Pulse to note",
    "content": ". This process allows to convert input signals into MIDI. | If the input is of type impulse, then the default velocity and default pitch are used. | If the input is of type int, then it is used as pitch and the velocity is set with the default velocity. | If the input is of type vec2, then the first element is the pitch, the second is the velocity. | . ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#pulse-to-note",
    "relUrl": "/processes/midi-utilities.html#pulse-to-note"
  },"537": {
    "doc": "MIDI utilities",
    "title": "Example: using the step sequencer to drive MIDI inputs",
    "content": ". ",
    "url": "https://ossia.io/score-docs/processes/midi-utilities.html#example-using-the-step-sequencer-to-drive-midi-inputs",
    "relUrl": "/processes/midi-utilities.html#example-using-the-step-sequencer-to-drive-midi-inputs"
  },"538": {
    "doc": "MIDI support",
    "title": "MIDI communication",
    "content": "MIDI communication is provided by two kind of devices, available from the Device explorer: . | MIDI input device can be used to plug a MIDI keyboard to score. | MIDI output device can be used to send MIDI data from score to an external sequencer. | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-communication",
    "relUrl": "/in-depth/midi.html#midi-communication"
  },"539": {
    "doc": "MIDI support",
    "title": "MIDI processes",
    "content": "MIDI processes can write to a specific channel or directly to the root device through addresses. Simply drop either the MIDI node corresponding to the MIDI device, or the channel, to the port you want to connect to. The most important processes are: . | Piano roll | Patternist | MIDI utilities | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-processes",
    "relUrl": "/in-depth/midi.html#midi-processes"
  },"540": {
    "doc": "MIDI support",
    "title": "MIDI file support",
    "content": ". | The Piano roll process supports MIDI files. | . Simply drag’n’drop a MIDI file in the score, either on a scenario or on the interval, from the user library or from your file explorer ! . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-file-support",
    "relUrl": "/in-depth/midi.html#midi-file-support"
  },"541": {
    "doc": "MIDI support",
    "title": "MIDI processing",
    "content": ". | See MIDI utilities for a list of processes that can alter MIDI data: arpeggiator, etc. | You can write your custom MIDI processors, for instance with the Javascript or the [[C++ JIT]] process. | . # RTP MIDI / AppleMIDI To access MIDI devices over the network, it is recommended to use a custom RTP MIDI daemon. | On Linux: rtpmidid | On macOS: support is built-in to the operating system. | On Windows: rtpmidi | . ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html#midi-processing",
    "relUrl": "/in-depth/midi.html#midi-processing"
  },"542": {
    "doc": "MIDI support",
    "title": "MIDI support",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/midi.html",
    "relUrl": "/in-depth/midi.html"
  },"543": {
    "doc": "MIDI input device",
    "title": "MIDI input device",
    "content": "To setup a device using Midi input, select Midi input in the Protocols column of the Add device window. In the Devices middle column, you can select your desired Midi input device. If you plugged in your Midi controller after launching score, you may need to restart score so your controller appears in the Devices column. Optionally, you can set a custom name (or use the default one). On platform that support it (macOS and Linux), you can create a virtual MIDI device. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html",
    "relUrl": "/devices/midiin-device.html"
  },"544": {
    "doc": "MIDI input device",
    "title": "Create whole tree option",
    "content": "Under the name of your Midi input device, you can toggle on the Create whole tree option. This option will create all possible Midi messages as parameters of the device as illustrated below. Addresses in the namespace will be created using the following format: . &lt;device name&gt;/&lt;channel number&gt;/&lt;message type&gt;/message number&gt; . Should you want not to automatically create a whole Midi namespace (i.e. and use Midi learn instead), just leave the option unset. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html#create-whole-tree-option",
    "relUrl": "/devices/midiin-device.html#create-whole-tree-option"
  },"545": {
    "doc": "MIDI input device",
    "title": "Use Midi learn",
    "content": "You can use the learn function to build your Midi input namespace with only the needed Midi message (rather than setting up the whole Midi namespace). To do so, once added the Midi device with the Create whole tree option off, in the Device explorer, right-click on your Midi input device name and select Learn from the contextual menu. This opens score Midi learn window. From then, score will monitor any incoming Midi message and store it under an address following the pattern mentioned above. When you are done sending the needed Midi message, click Done on the Midi learn window. All received Midi messages should now appear under your Midi input device name in the Device explorer. ",
    "url": "https://ossia.io/score-docs/devices/midiin-device.html#use-midi-learn",
    "relUrl": "/devices/midiin-device.html#use-midi-learn"
  },"546": {
    "doc": "MIDI output device",
    "title": "Midi output device",
    "content": "To setup a device using Midi output, select Midi output in the Protocols column of the Add device window. In the Devices middle column, you can select your desired Midi input device. If you plugged in your Midi device after launching score, you may need to restart score so your it appears in the Devices column. Optionally, you can set a custom name (or use the default one). On platform that support it (macOS and Linux), you can create a virtual MIDI device. ",
    "url": "https://ossia.io/score-docs/devices/midiout-device.html#midi-output-device",
    "relUrl": "/devices/midiout-device.html#midi-output-device"
  },"547": {
    "doc": "MIDI output device",
    "title": "MIDI output device",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/midiout-device.html",
    "relUrl": "/devices/midiout-device.html"
  },"548": {
    "doc": "Minuit device",
    "title": "Minuit device",
    "content": ". Connect to other creative coding applications and automatically discover their parameter trees. Minuit enables rich bidirectional communication between score and other software, sharing not just values but complete parameter hierarchies with metadata like types, ranges, and descriptions. Perfect for collaborative setups, distributed installations, or any project where multiple applications need to share parameter data seamlessly. Note that Minuit has been superseded by OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html",
    "relUrl": "/devices/minuit-device.html"
  },"549": {
    "doc": "Minuit device",
    "title": "Setting up a Minuit device",
    "content": ". | Add device in the Device explorer and choose “Minuit” | Configure network settings - set host IP and ports for communication | Set device name - choose a unique identifier for this score instance | Connect to remote - the device automatically discovers the remote parameter tree | Monitor synchronization - watch as remote parameters appear in your device explorer | . Both applications need to support the Minuit protocol for full bidirectional communication. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#setting-up-a-minuit-device",
    "relUrl": "/devices/minuit-device.html#setting-up-a-minuit-device"
  },"550": {
    "doc": "Minuit device",
    "title": "How Minuit works",
    "content": "Minuit builds on OSC but adds automatic tree discovery and rich metadata exchange. Instead of manually creating parameter addresses, Minuit lets applications announce their entire parameter structure and automatically stay synchronized. Tree discovery - Applications broadcast their parameter hierarchies Metadata exchange - Share parameter types, ranges, units, and descriptions Real-time sync - Changes in one application instantly appear in others Bidirectional control - Both applications can control each other’s parameters . ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#how-minuit-works",
    "relUrl": "/devices/minuit-device.html#how-minuit-works"
  },"551": {
    "doc": "Minuit device",
    "title": "Network configuration",
    "content": "Host address: IP address of the remote application (use 127.0.0.1 for same computer) . Remote port: Port where the remote application receives data (default 9998) . Local port: Port where score listens for incoming data (default 13579) . Device name: Unique identifier for this score instance (default “score”) . Rate limiting: Optional throttling to prevent network flooding during rapid parameter changes . ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#network-configuration",
    "relUrl": "/devices/minuit-device.html#network-configuration"
  },"552": {
    "doc": "Minuit device",
    "title": "Automatic discovery features",
    "content": "Zeroconf integration: Minuit devices can automatically discover each other on the network without manual configuration. Dynamic tree updates: When the remote application adds or removes parameters, your score device tree updates automatically. Metadata synchronization: Parameter types, value ranges, units, and descriptions sync automatically from the remote application. Connection monitoring: The device detects when remote applications connect or disconnect. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#automatic-discovery-features",
    "relUrl": "/devices/minuit-device.html#automatic-discovery-features"
  },"553": {
    "doc": "Minuit device",
    "title": "Parameter types and metadata",
    "content": "Minuit handles rich parameter information beyond simple values: . Data types: Integers, floats, strings, booleans, vectors, and complex data structures . Value ranges: Minimum and maximum bounds with different clipping behaviors (clamp, wrap, fold) . Units and dataspaces: Physical units like frequencies, distances, colors with automatic conversion . Descriptions: Human-readable parameter descriptions for better interface understanding . Access modes: Parameters can be read-only, write-only, or bidirectional based on their function . ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#parameter-types-and-metadata",
    "relUrl": "/devices/minuit-device.html#parameter-types-and-metadata"
  },"554": {
    "doc": "Minuit device",
    "title": "Creative applications",
    "content": "Multi-app performances: Connect score with Max/MSP, Pure Data, TouchDesigner, or other creative tools for complex multi-system performances. Collaborative composition: Multiple composers can work with the same parameter set simultaneously, seeing each other’s changes in real-time. Distributed installations: Spread an installation across multiple computers while maintaining centralized parameter control. Educational environments: Students can connect their projects to shared parameter spaces for collaborative learning experiences. Cross-platform integration: Bridge different creative coding environments regardless of their native parameter systems. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#creative-applications",
    "relUrl": "/devices/minuit-device.html#creative-applications"
  },"555": {
    "doc": "Minuit device",
    "title": "Integration advantages",
    "content": "Automatic setup: No need to manually create parameter addresses or configure complex routing - Minuit handles discovery automatically. Rich metadata: Unlike plain OSC, you get parameter types, ranges, and descriptions, making integration much more robust. Bidirectional control: Both applications can control each other’s parameters, enabling true collaborative workflows. Network resilience: Built-in error handling and reconnection logic keeps distributed systems running smoothly. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#integration-advantages",
    "relUrl": "/devices/minuit-device.html#integration-advantages"
  },"556": {
    "doc": "Minuit device",
    "title": "Advanced features",
    "content": "Listen subscriptions: Subscribe only to parameters you actually need to reduce network traffic and improve performance. Tree exploration: Explore large parameter trees efficiently with asynchronous discovery and lazy loading. Connection management: Robust handling of network disconnections, timeouts, and reconnections. Multi-device support: Connect to multiple Minuit-enabled applications simultaneously for complex distributed setups. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#advanced-features",
    "relUrl": "/devices/minuit-device.html#advanced-features"
  },"557": {
    "doc": "Minuit device",
    "title": "Integration with score",
    "content": "Minuit devices appear in the Device explorer just like any other device, but with automatic parameter discovery. Parameter mapping: Use discovered parameters with Mapping Tool or Automation just like local parameters. Real-time control: Control remote application parameters in real-time during performances. State management: Parameter values and ranges are preserved in score projects for consistent setups. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#integration-with-score",
    "relUrl": "/devices/minuit-device.html#integration-with-score"
  },"558": {
    "doc": "Minuit device",
    "title": "Troubleshooting",
    "content": "Discovery failures: Check that both applications are on the same network and using compatible Minuit protocol versions. Port conflicts: Ensure the specified ports aren’t used by other applications - try different port numbers if connections fail. Firewall issues: Network firewalls may block UDP communication - configure firewall rules to allow Minuit traffic. Network latency: High network latency can affect real-time parameter control - use local networks for best performance. ",
    "url": "https://ossia.io/score-docs/devices/minuit-device.html#troubleshooting",
    "relUrl": "/devices/minuit-device.html#troubleshooting"
  },"559": {
    "doc": "Mixer",
    "title": "Mixing busses",
    "content": "Intervals can become mixing busses for all their child process. To use that feature, mark an interval as a bus in its inspector. The Audio panel then allows to change its volume / pan. Things with more than 2 channels will be available once we figure a proper UI for it - designers welcome as the code already supports it ! . ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#mixing-busses",
    "relUrl": "/panels/mixer.html#mixing-busses"
  },"560": {
    "doc": "Mixer",
    "title": "Mixing console",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#mixing-console",
    "relUrl": "/panels/mixer.html#mixing-console"
  },"561": {
    "doc": "Mixer",
    "title": "Audio in-out",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html#audio-in-out",
    "relUrl": "/panels/mixer.html#audio-in-out"
  },"562": {
    "doc": "Mixer",
    "title": "Mixer",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels/mixer.html",
    "relUrl": "/panels/mixer.html"
  },"563": {
    "doc": "Model display",
    "title": "Model display",
    "content": ". Model display is the base object for displaying 3D geometry: objects, point clouds, etc. ",
    "url": "https://ossia.io/score-docs/processes/model-display.html",
    "relUrl": "/processes/model-display.html"
  },"564": {
    "doc": "Model display",
    "title": "Related Processes",
    "content": ". | Object Loader - Loads 3D files. | Structure Synth - Generative procedural geometry | . ",
    "url": "https://ossia.io/score-docs/processes/model-display.html#related-processes",
    "relUrl": "/processes/model-display.html#related-processes"
  },"565": {
    "doc": "Model display",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/model-display.html#try-it",
    "relUrl": "/processes/model-display.html#try-it"
  },"566": {
    "doc": "Modular workflow",
    "title": "Modular workflow",
    "content": "ossia score is built upon an entirely modular foundation. At any point during edition, it is possible to switch from the temporal view, to the modular view, in order to patch processes together as easily as possible. The mode switching is operated by the buttons at the bottom of the software: . Some processes will always appear in patch view: audio effects, generators, and more generally any process for which the effect does not depend on time-relative data. Here is a small score viewed in temporal mode (the default): . Here is the same score viewed in modular mode: . It is also possible to disable the cables when the patching has been done and one wants to focus on the controls, the automations, etc: . This functionality is accessible through Alt+Shift+G. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html",
    "relUrl": "/in-depth/modular-workflow.html"
  },"567": {
    "doc": "Modular workflow",
    "title": "Interactions",
    "content": "Outside of simply drag’n’dropping or double-clicking from the process library, there are multiple interactions available to add a process directly at a specific position in the data flow. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html#interactions",
    "relUrl": "/in-depth/modular-workflow.html#interactions"
  },"568": {
    "doc": "Modular workflow",
    "title": "Adding a process in the middle of a cable",
    "content": "If a cable is selected, and one doubles-clicks in the process library, the object is if possible inserted in the middle of the cable. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html#adding-a-process-in-the-middle-of-a-cable",
    "relUrl": "/in-depth/modular-workflow.html#adding-a-process-in-the-middle-of-a-cable"
  },"569": {
    "doc": "Modular workflow",
    "title": "Adding a process before a specific port",
    "content": "If an input port or control is selected, and one doubles-clicks on a process in the process library, if the process’s first output is compatible with the port’s type then the process will be connected before the port. If there is an address in the port, it will be moved to the first input port of the newly-created process. Likewise for the “Propagate” attribute on audio ports. For instance, if a score contains an LFO object, with the address foo:/bar assigned to the LFO amplitude, and one selects the amplitude port and doubles-clicks on the Micromap object in the process library, the Micromap’s input will be set to foo:/bar, a cable will be created from the Micromap’s output to the LFO’s amplitude and the LFO’s amplitude won’t have the foo:/bar address set anymore. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html#adding-a-process-before-a-specific-port",
    "relUrl": "/in-depth/modular-workflow.html#adding-a-process-before-a-specific-port"
  },"570": {
    "doc": "Modular workflow",
    "title": "Adding a process after a specific port",
    "content": "The same than above applies for output ports. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html#adding-a-process-after-a-specific-port",
    "relUrl": "/in-depth/modular-workflow.html#adding-a-process-after-a-specific-port"
  },"571": {
    "doc": "Modular workflow",
    "title": "Adding a process after another",
    "content": "If an entire process is selected in the score, and one doubles-clicks on a new process to add in the library, score will try to connect to the first port. This is useful for instance when creating audio or video effect chains as one can quickly connect new effects as they always have an audio or video input and output as first port by convention. To make this workflow even faster, when a new process is created, it is selected, meaning that one does not even have to go to the score to add new objects. ",
    "url": "https://ossia.io/score-docs/in-depth/modular-workflow.html#adding-a-process-after-another",
    "relUrl": "/in-depth/modular-workflow.html#adding-a-process-after-another"
  },"572": {
    "doc": "How to monitor activity ?",
    "title": "How to monitor messages ?",
    "content": "With Logging option activated in score preferences, you can for example check messages coming in and out of a selected process in the Messages log panel (Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac)) . ",
    "url": "https://ossia.io/score-docs/faq/monitor-activity.html#how-to-monitor-messages-",
    "relUrl": "/faq/monitor-activity.html#how-to-monitor-messages-"
  },"573": {
    "doc": "How to monitor activity ?",
    "title": "How to monitor activity ?",
    "content": " ",
    "url": "https://ossia.io/score-docs/faq/monitor-activity.html",
    "relUrl": "/faq/monitor-activity.html"
  },"574": {
    "doc": "MQTT Device",
    "title": "MQTT Device",
    "content": ". MQTT (Message Queuing Telemetry Transport) is a lightweight messaging protocol designed for IoT and embedded systems. ossia score’s MQTT device enables seamless integration with IoT ecosystems, smart home systems, and industrial automation networks. ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html",
    "relUrl": "/devices/mqtt-device.html"
  },"575": {
    "doc": "MQTT Device",
    "title": "Overview",
    "content": "MQTT support in score enables: . | Publish/subscribe messaging patterns for distributed systems | IoT device integration with smart home and industrial networks | Cloud service communication (AWS IoT, Google Cloud IoT, Azure IoT) | Low-bandwidth, high-reliability messaging for resource-constrained devices | Real-time data collection from sensor networks | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#overview",
    "relUrl": "/devices/mqtt-device.html#overview"
  },"576": {
    "doc": "MQTT Device",
    "title": "Supported Transports",
    "content": "TCP (Default) . | Standard MQTT over TCP (port 1883, or 8883 for TLS) | Reliable, ordered message delivery | Most common deployment method | . WebSocket . | MQTT over WebSocket protocol | Browser compatibility and firewall-friendly | Useful for web-based integrations and cloud services | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#supported-transports",
    "relUrl": "/devices/mqtt-device.html#supported-transports"
  },"577": {
    "doc": "MQTT Device",
    "title": "Device Setup",
    "content": "Basic Configuration . | Add MQTT Device: Right-click Device Explorer → Add Device → MQTT | Configure Connection: . | Host: MQTT broker address (e.g., mqtt.broker.com or 127.0.0.1) | Port: Broker port (1883 for TCP, 8080 for WebSocket) | Transport: Select TCP or WebSocket | Client ID: Unique identifier (auto-generated if empty) | . | . Authentication &amp; Security . | Parameter | Description | Example | . | Username | MQTT username | user123 | . | Password | MQTT password | secret456 | . | Keep Alive | Heartbeat interval (seconds) | 60 | . | Clean Session | Start with clean state | Enabled | . | Use TLS | Enable encryption | For secure connections | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#device-setup",
    "relUrl": "/devices/mqtt-device.html#device-setup"
  },"578": {
    "doc": "MQTT Device",
    "title": "Topic Structure &amp; Discovery",
    "content": "MQTT uses hierarchical topics separated by forward slashes. Unlike OSC, MQTT has no automatic discovery mechanism - you must use the “Learn” feature or create topics manually. Topic Patterns &amp; Wildcards . | Single level wildcard (+): home/+/temperature matches home/kitchen/temperature | Multi-level wildcard (#): sensors/# matches all topics under sensors/ | Examples: . | home/livingroom/lights/brightness | industrial/sensor01/pressure/value | score/performance/cue_state | . | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#topic-structure--discovery",
    "relUrl": "/devices/mqtt-device.html#topic-structure--discovery"
  },"579": {
    "doc": "MQTT Device",
    "title": "Usage Examples",
    "content": "Smart Home Integration . Control smart home devices from score: . [Score Automation] → [MQTT: home/lights/living_room] → [Smart Bulb] [Sensor Input] → [MQTT: home/thermostat/target] → [HVAC System] . IoT Sensor Networks . Collect data from distributed sensors: . [MQTT: sensors/+/temperature] → [Score Processing] → [Visualization] [MQTT: sensors/+/humidity] → [Data Analysis] → [Environmental Control] . Cloud IoT Platforms . Connect to major cloud services: . AWS IoT Core . Host: your-endpoint.iot.us-east-1.amazonaws.com Port: 8883 (TLS required) Topics: $aws/things/device-name/shadow/update . Google Cloud IoT . Host: mqtt.googleapis.com Port: 8883 (TLS required) Topics: /devices/device-id/events . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#usage-examples",
    "relUrl": "/devices/mqtt-device.html#usage-examples"
  },"580": {
    "doc": "MQTT Device",
    "title": "Getting Started Example",
    "content": "To try MQTT locally, use Mosquitto: . 1. Start MQTT Broker . $ mosquitto . 2. Test with Command Line Tools . Publish test data: . $ mosquitto_pub -t /sensors/temperature -m 23.5 -h 127.0.0.1 . Subscribe to responses: . $ mosquitto_sub -t /controls/# -h 127.0.0.1 . 3. Configure in ossia score . | Add MQTT Device with host 127.0.0.1, port 1883 | Use “Learn” feature to discover /sensors/temperature topic | Add child node to send to /controls/lighting topic | Test bi-directional communication | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#getting-started-example",
    "relUrl": "/devices/mqtt-device.html#getting-started-example"
  },"581": {
    "doc": "MQTT Device",
    "title": "Important Considerations",
    "content": "Loop Prevention . Warning: Many MQTT brokers cannot handle loops (publishing and subscribing to the same topic). Unlike OSC, avoid creating feedback loops between publish and subscribe on identical topics. Message Persistence . | Use retained messages for state information | Configure QoS levels based on reliability needs: . | QoS 0: At most once (fire and forget) | QoS 1: At least once (acknowledged) | QoS 2: Exactly once (guaranteed) | . | . Performance Tips . | Batch updates for high-frequency data | Use appropriate keep-alive intervals (60-300 seconds) | Organize topics hierarchically for efficient wildcards | Consider message size limits (typically 256KB max) | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#important-considerations",
    "relUrl": "/devices/mqtt-device.html#important-considerations"
  },"582": {
    "doc": "MQTT Device",
    "title": "Related Documentation",
    "content": ". | OSC Device - Alternative real-time protocol | HTTP Device - REST API communication | WebSocket Device - Real-time web communication | Serial Device - Direct hardware communication | . ",
    "url": "https://ossia.io/score-docs/devices/mqtt-device.html#related-documentation",
    "relUrl": "/devices/mqtt-device.html#related-documentation"
  },"583": {
    "doc": "Multi-Cursor Manager",
    "title": "Multi-Cursor Manager (X-Y point arrays)\n",
    "content": "The Multi-Cursor manager is a process for generating an array of XY points in 2D space by modifying their position, adding new ones and deleting others. ",
    "url": "https://ossia.io/score-docs/processes/multicursor.html#multi-cursor-manager-x-y-point-arrays",
    "relUrl": "/processes/multicursor.html#multi-cursor-manager-x-y-point-arrays"
  },"584": {
    "doc": "Multi-Cursor Manager",
    "title": "Modifying points.",
    "content": ". | Points can be dragged with the mouse. | To create a new point, click on an empty space. | To delete a point, right-click on it. | . ",
    "url": "https://ossia.io/score-docs/processes/multicursor.html#modifying-points",
    "relUrl": "/processes/multicursor.html#modifying-points"
  },"585": {
    "doc": "Multi-Cursor Manager",
    "title": "Multi-Cursor Manager",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/multicursor.html",
    "relUrl": "/processes/multicursor.html"
  },"586": {
    "doc": "Musical metrics",
    "title": "Musical metrics",
    "content": "Processes and elements of a score can be quantized on musical metrics, and have independent tempo curves, &amp; time signatures. Musical metrics are propagated hierarchically: . | The tempo, and musical position in an interval is either relative to this interval (if the 4/4 button in the inspector is pressed) or it’s taking the musical information from its closest parent (recursively). | Processes take the quantization and metrics information from their parent. | . This means that polyrhythmic scores are possible: the root can be in 4/4 with a child interval in 3/4, 7/8. There are three “musical” controls available: time signatures, tempo curves, and quantization. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html",
    "relUrl": "/in-depth/musical.html"
  },"587": {
    "doc": "Musical metrics",
    "title": "Musical signatures",
    "content": "They are set on intervals and are used to delimit the start and end of bars, for quantization purposes. To change the musical signatures, go into an interval in full view and mark the interval as having its own metrics in the inspector if it does not already have some. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#musical-signatures",
    "relUrl": "/in-depth/musical.html#musical-signatures"
  },"588": {
    "doc": "Musical metrics",
    "title": "Quantization",
    "content": "The quantization setting on an interval allows to say at which musical interval child elements will be triggered if they rely on hierarchy for synchronization. For instance, if the quantization setting is set at one bar, it means that the event will be processed at the start of the next bar. Most places that can be quantized thus have a choice of quantization intervals (bars, quarter notes, …), plus the Parent (uses the parent quantization setting, recursively) and Free (no quantization, things start directly) settings. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#quantization",
    "relUrl": "/in-depth/musical.html#quantization"
  },"589": {
    "doc": "Musical metrics",
    "title": "Tempo",
    "content": "Likewise, by default the tempo is the global one. Intervals support tempo curves, which can give them a different speed behaviour. The interval’s children will all take this tempo unless another more precise tempo is given at a deeper nesting level by adding a tempo process to the interval. ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#tempo",
    "relUrl": "/in-depth/musical.html#tempo"
  },"590": {
    "doc": "Musical metrics",
    "title": "Usage",
    "content": ". | Processes which are able to use tempo &amp; metrics information (audio plug-ins, LFO, arpeggiator, etc) will do so automatically. | Triggers and intervals can be quantified to fall on the next quantification date from when they are triggered. | . ",
    "url": "https://ossia.io/score-docs/in-depth/musical.html#usage",
    "relUrl": "/in-depth/musical.html#usage"
  },"591": {
    "doc": "NDI devices",
    "title": "NDI",
    "content": "NDI is a network protocol for sharing video frames across applications. ossia score supports both RGBA and UYVY NDI frames, and is compatible with NDI 5 and 6. ",
    "url": "https://ossia.io/score-docs/devices/ndi-device.html#ndi",
    "relUrl": "/devices/ndi-device.html#ndi"
  },"592": {
    "doc": "NDI devices",
    "title": "NDI input device",
    "content": "This device allows receiving a video stream directly from a NDI-compatible input. Simply choose the wanted input in the list, and put the output at the end of the video chain. ",
    "url": "https://ossia.io/score-docs/devices/ndi-device.html#ndi-input-device",
    "relUrl": "/devices/ndi-device.html#ndi-input-device"
  },"593": {
    "doc": "NDI devices",
    "title": "NDI output device",
    "content": "This device allows to create a NDI stream that other NDI-compatible software will be able to display or modify. Simply choose the viewport options, a rendering rate, and a name for the output. You can then use the device as input to video filters. # PTZ support . A camera exposing PTZ controls will be able to get controlled by ossia. The following parameters are available if the camera provides access to them: . /ptz/zoom (float) /ptz/pan (float) /ptz/tilt (float) /ptz/pan/speed (float) /ptz/tilt/speed (float) /ptz/preset/store (int) /ptz/preset/recall (int) /ptz/focus/auto (impulse) /ptz/focus/manual (float) /ptz/focus/speed (float) /ptz/wb/auto (impulse) /ptz/wb/indoor (impulse) /ptz/wb/outdoor (impulse) /ptz/wb/oneshot (impulse) /ptz/wb/manual (rgb) /ptz/exposure/auto (impulse) /ptz/exposure/manual (float) . ",
    "url": "https://ossia.io/score-docs/devices/ndi-device.html#ndi-output-device",
    "relUrl": "/devices/ndi-device.html#ndi-output-device"
  },"594": {
    "doc": "NDI devices",
    "title": "NDI devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/ndi-device.html",
    "relUrl": "/devices/ndi-device.html"
  },"595": {
    "doc": "Nodes",
    "title": "Nodes",
    "content": ". This process is a graphical interface which allows to create and interpolate across a set of nodes. ",
    "url": "https://ossia.io/score-docs/processes/nodes.html",
    "relUrl": "/processes/nodes.html"
  },"596": {
    "doc": "Nodes",
    "title": "Usage",
    "content": "The Nodes process has two modes: circular and voronoi. An input cursors moves in a 2D space. Its distance to each node will be its contribution to the weight in the output. ",
    "url": "https://ossia.io/score-docs/processes/nodes.html#usage",
    "relUrl": "/processes/nodes.html#usage"
  },"597": {
    "doc": "Nodes",
    "title": "See also",
    "content": ". | Interpolator can be used to transform the weights of the Ndoes process into an actual interpolation. | AI Prompt Composer can be used to interpolate between multiple prompts targeting image generation models. | . ",
    "url": "https://ossia.io/score-docs/processes/nodes.html#see-also",
    "relUrl": "/processes/nodes.html#see-also"
  },"598": {
    "doc": "Nodes",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/nodes.html#try-it",
    "relUrl": "/processes/nodes.html#try-it"
  },"599": {
    "doc": "How to run score without GUI ?",
    "title": "How to run score without GUI ?",
    "content": "Score can run in the background while not opening its full UI (which may be handy for example when running score in a video installation). To do so, you can launch score from the Command line using the following: . $ ossia-score --no-gui --autoplay /home/oscar/my-score.score . You may find other useful commands in the command line reference page. ",
    "url": "https://ossia.io/score-docs/faq/nogui.html",
    "relUrl": "/faq/nogui.html"
  },"600": {
    "doc": "Non-linear timeline",
    "title": "Non-linear timeline",
    "content": "In previous example, we used trigger points to add variation during the execution of time-lined contents (device’s state recalling as well as automations) in the scenario. While trigger points bring flexibility in a timeline-based approach, things can be pushed a step further. You remember we noted in the Saving and recalling devices state page that score offers to connect dropped namespace selection to different preceding elements in the scenario. score also provides several ways to connect elements, one of them allowing to write and organize elements pretty much like you would do when designing a state machine. To learn about the various connections features, please refer to the in-depth topics as well as the reference manual to see how score engine works and the advanced authoring features it provides. In the scenario editor panel, you may create some elements by dragging a connection to a point in the timeline where you want to store a namespace state or start a process. This is where the create widget comes handy. In the illustration below, we can see that selecting a namespace state stored in the timeline brings the create widget: the yellow, blue and red crosses icons. We will focus here on the red one: it allows to escape the timeline constraint and automatically trigger elements attached to that connection. As seen above, clicking the red cross allows us to drag a connection up to anywhere in the timeline. From there, we may adjust our device settings and drag a namespace selection from the Device explorer to store its state as seen earlier. What’s happening here? Well, we are starting to scratch the surface of score’s special strength. When playing our scenario, score will recall our parameters’ stored states and execute automations as the play-head runs through the timeline, just like we saw earlier. But when reaching the starting point of this dashed connection, the play-head will kind of jump to the connected elements and continue the reading as time regularly passes by. This might look weird coming from a timeline-based approach but is actually extremely useful. While score can help to author elements of precise duration and evolution over time using its timeline as a default grid, it also allows to author state machine-like scenarios by patching timed processes. ",
    "url": "https://ossia.io/score-docs/quick-start/non-linear-timelines.html",
    "relUrl": "/quick-start/non-linear-timelines.html"
  },"601": {
    "doc": "Non-linear timeline",
    "title": "From timeline-based scenario to state machine",
    "content": "This way of patching blocks of timed elements offers to construct your scenario in much more flexible ways that traditional DAW or timeline-based sequencers. As illustrated below, it allows to write scenarios running in loop for example, especially useful in interactive installations. In the simple scenario above, score will execute the scenario as an infinite loop alternating a simple fade in, then jumping to the fade-out automations then jump back to fade-in automations. Of course, you can still use some trigger points so the scenario waits before jumping to the next point. ",
    "url": "https://ossia.io/score-docs/quick-start/non-linear-timelines.html#from-timeline-based-scenario-to-state-machine",
    "relUrl": "/quick-start/non-linear-timelines.html#from-timeline-based-scenario-to-state-machine"
  },"602": {
    "doc": "Object filter",
    "title": "Object filter",
    "content": ". This object implements a subset of the jq syntax, which is a small and very straightfoward language to filter objects in a complex hierarchy involving lists, dictionaries (maps), strings, numbers, etc. For instance: given this object (using Javascript syntax: [1, 4, \"foo\"] is a list, { \"a\": 123, \"b\": 456 } is a map): . [ 1, 2, sl.value, [ [ sl.value, 0.6 ], \"foo\", [ true, false, true, false ] ], \"hiii\", [\"hello\", 123, \"foo\", 456], { \"test\": 123, \"another\": \"variant\"} ] . The jq program: .[6].test will give 123. Given: . { \"foo\": [ { \"bar\": 1 }, { \"bar\": 3 }, { \"bar\": 4 }, { \"bar\": 2 }, { \"bar\": 5 }, { \"bar\": 2 } ] } . Then [ .foo[2:5].bar ] will give as output the list [4, 2, 5]. ",
    "url": "https://ossia.io/score-docs/processes/object-filter.html",
    "relUrl": "/processes/object-filter.html"
  },"603": {
    "doc": "Object filter",
    "title": "Supported syntax and example programs",
    "content": "## The dot just copies the entire input to the output # Example: [ 123, \"foo\" ] -&gt; [ 123, \"foo\" ] . ## Iterates through all the values of an array or map # Example: [ 123, \"foo\" ] -&gt; first the value 123 is output, then the value \"foo\" # Example: { \"a\": 123, \"b\": 456 } -&gt; first the value 123 is output, then the value 456 .[] ## Selects an element of an array # Example: [ 123, 456 ] -&gt; 123 .[0] # Example: [ 123, 456 ] -&gt; 456 .[1] ## Selects multiple elements of an array # Example: [ 123, 456, 789 ] -&gt; [123, 789] [ .[0, 2] ] ## Selects a range of elements of an array # Example: [ 123, 456, 789, 10 ] -&gt; [456, 789, 10] [ .[1:3] ] ## Put the values in an array [ (expression) ] # Example: [ 123, 456 ] -&gt; [ [ 123, 456] ] [ . ] # Example: [ 123, 456 ] -&gt; [ 123, 456 ] [ .[] ] # Example: { \"a\": 123, \"b\": 456 } -&gt; [ 123, 456 ] [ .[] ] ## Select a member of an object .member_name # Example: { \"a\": 123, \"b\": 456 } -&gt; 456 .b # Example: { \"a\": 123, \"b\": [ { \"foo\": \"x\", \"bar\": \"y\" } ] } -&gt; \"x\" .b[0].foo ## Sequence operations one after each other (expression 1) | (expression 2) # Example: # [ { \"name\": \"Shashimi\", \"age\": 6 }, { \"name\": \"Flocky\", \"age\": 3 } ] # -&gt; [\"Shashimi\", \"Flocky\"] [ .[] | .name ] . ",
    "url": "https://ossia.io/score-docs/processes/object-filter.html#supported-syntax-and-example-programs",
    "relUrl": "/processes/object-filter.html#supported-syntax-and-example-programs"
  },"604": {
    "doc": "Object loader",
    "title": "Object loader",
    "content": ". Ossia score provides comprehensive support for loading and processing 3D mesh data through the Object Loader process, supporting both traditional mesh formats and point cloud data. The Object Loader process loads 3D geometry from external files and makes it available for rendering in ossia score’s graphics pipeline. Supported Formats . OBJ Files (.obj) . | Complete Wavefront OBJ specification support | Vertex positions, normals, color, texture coordinates | Multi-geometry support | . PLY Files (.ply) . | Stanford PLY format support | Point cloud data with positions and colors | Mesh data with connectivity information | Binary and ASCII PLY formats | Vertex properties: position, normal, color, texture coordinates | . Parameters . 3D File . Type: File input Supported Extensions: *.obj, *.ply . Select the 3D file to load. The process will automatically detect the format and parse the geometry data accordingly. Position . Type: 3D Vector (X, Y, Z) Default: (0, 0, 0) . Sets the world position of the loaded mesh in 3D space. Rotation . Type: 3D Vector (X, Y, Z) - Euler angles Default: (0, 0, 0) . Sets the rotation of the loaded mesh around each axis in degrees. Scale . Type: 3D Vector (X, Y, Z) Default: (1, 1, 1) . Sets the scale factor for the mesh along each axis. Output . Geometry . Type: Dynamic 3D geometry collection . ",
    "url": "https://ossia.io/score-docs/processes/object-loader.html",
    "relUrl": "/processes/object-loader.html"
  },"605": {
    "doc": "Object loader",
    "title": "Related Processes",
    "content": ". | Model Display - Displays a 3D model | Structure Synth - Generative procedural geometry | . ",
    "url": "https://ossia.io/score-docs/processes/object-loader.html#related-processes",
    "relUrl": "/processes/object-loader.html#related-processes"
  },"606": {
    "doc": "Object loader",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/object-loader.html#try-it",
    "relUrl": "/processes/object-loader.html#try-it"
  },"607": {
    "doc": "OSC device",
    "title": "OSC device",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html",
    "relUrl": "/devices/osc-device.html"
  },"608": {
    "doc": "OSC device",
    "title": "Setting up communication with OSC device",
    "content": "Once opened a new score project, right-click in the Device explorer on the left of score window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. From the Protocols column, choose OSC and setup IP address your device is running on as well in &amp; out ports. You may also specify a name for your device. For the demo purpose here, we will use the default OSCdevice name. When done, the Device explorer pane should display our device top node. Note: Should you need to change settings of your OSC device, the setup panel can be brought back by choosing Edit in the device contextual menu. We can then setup our device’s OSC addresses we want to automate within score. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-communication-with-osc-device",
    "relUrl": "/devices/osc-device.html#setting-up-communication-with-osc-device"
  },"609": {
    "doc": "OSC device",
    "title": "Setting up OSC addresses",
    "content": "Using OSC learn . In the Device explorer pane, choose Learn in our device contextual menu. This opens up score’s OSC learning window. score will now monitor any OSC incoming value. For demo purpose here, we will use Vidvox’s handy OSC Test application. As soon as we send values to score from our OSC Test application, addresses get learned and displayed in the OSC learning window. When done, the Device explorer pane should display all learned OSC addresses. You can browse your device namespace, fold/unfold any node in the namespace hierarchy by clicking the arrow prepending each node. You can also see a parameter current value in your OSC device by selecting this parameter in score Device explorer and check its bottom section. Adding addresses manually . Should you need to setup your score project without having your OSC device opened, addresses can be added in the device explorer manually. Once having created an OSC device as explained above, choose Add child in the device contextual menu. As of score 3.0.0, each level of your parameter’s OSC address is to be declared separately. Assuming we want to add the address OSCdevice/track/1/volume, we first need to create the ‘track’ node. From the OSC editor window, type track in the Name text field and leave default type container (that is: a node in the namespace above other nodes or parameters). Then from the freshly created track node contextual menu, choose Add child to create a 1 node, then from this node, choose Add child again to create our volume parameter. For our volume parameter, we want to set the type as something else than container. For example, we will set up our parameter as a float value. You may also edits some of the parameter’s attributes as detailed in next step. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-osc-addresses",
    "relUrl": "/devices/osc-device.html#setting-up-osc-addresses"
  },"610": {
    "doc": "OSC device",
    "title": "Setting up parameters’ attributes",
    "content": "Once declared either using learn function or manually, parameter’s general behaviour can be further defined by setting up its various attributes. When selecting a parameter in the Device explorer pane, its attributes can be displayed and edited in the bottom section of the pane. A dedicated window can also be opened by choose Edit in the parameter contextual menu. For each value type, a number of attributes can be defined, such as: value domain (min. and max. value), clip mode (parameter handling of value exceeding its domain), repetition filter, etc. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#setting-up-parameters-attributes",
    "relUrl": "/devices/osc-device.html#setting-up-parameters-attributes"
  },"611": {
    "doc": "OSC device",
    "title": "Saving OSC device for later use",
    "content": "When properly set up, your OSC device namespace can be exported and saved to disk for latter use. To do so, choose Export device in the device contextual menu. ",
    "url": "https://ossia.io/score-docs/devices/osc-device.html#saving-osc-device-for-later-use",
    "relUrl": "/devices/osc-device.html#saving-osc-device-for-later-use"
  },"612": {
    "doc": "OSCQuery device",
    "title": "OSCQuery device",
    "content": "score can communicate with devices using the OSCQuery protocol. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html",
    "relUrl": "/devices/oscquery-device.html"
  },"613": {
    "doc": "OSCQuery device",
    "title": "What is OSCQuery ?",
    "content": "As presented by Vidvox, the OSC Query Protocol is an agreed-upon specification that extends the base functionality of OSC to make it easier to construct impromptu or improvisational interfaces between different systems. The OSCQuery Protocol builds on top of OSC to provide a standardized way for systems to publish descriptions of their OSC Address Spaces in such a way that other environments can automatically interface with them with little or no setup. Within OSCQuery, a server is a host that provides a JSON data blob that describes the hierarchy of an OSC Address Space in a format that is both easy for humans and machine to interpret. Descriptions can include the type of data that is expected, the range of values that are accepted and other information about each container and method within the address space. Within OSCQuery, a client refers to a piece of software that browses and interacts with a remote server’s OSC address space. Read Vidvox’s detailed article to learn more about OSCQuery. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html#what-is-oscquery-",
    "relUrl": "/devices/oscquery-device.html#what-is-oscquery-"
  },"614": {
    "doc": "OSCQuery device",
    "title": "Adding OSCQuery device",
    "content": "Once opened a new score project, right-click in the Device explorer on the left of score window and choose Add device from the Device explorer contextual menu. This brings score’s device setup window. From the Protocols column, choose OSCQuery. You should see in the Devices column all OSCQuery compatibles devices available on the network. Select the desired one from the list and click Add. score will then query the selected device and receive its full namespace. All nodes and parameters of the device should now appear in the Device explorer. ",
    "url": "https://ossia.io/score-docs/devices/oscquery-device.html#adding-oscquery-device",
    "relUrl": "/devices/oscquery-device.html#adding-oscquery-device"
  },"615": {
    "doc": "Package manager",
    "title": "Package manager",
    "content": "TODO . ",
    "url": "https://ossia.io/score-docs/package-manager.html",
    "relUrl": "/package-manager.html"
  },"616": {
    "doc": "Panels",
    "title": "Panels",
    "content": " ",
    "url": "https://ossia.io/score-docs/panels.html",
    "relUrl": "/panels.html"
  },"617": {
    "doc": "Path Generator",
    "title": "Path Generator (X-Y automation)",
    "content": ". The Path Generator is a process used to automate 2D X-Y positions over time by selecting predefined movement paths and manipulating cursors in the user interface. Each source in the path generator has two cursors: . | The green cursor indicates the starting point. | The red cursor indicates the end point of the movement. | . ",
    "url": "https://ossia.io/score-docs/processes/pathgenerator.html#path-generator-x-y-automation",
    "relUrl": "/processes/pathgenerator.html#path-generator-x-y-automation"
  },"618": {
    "doc": "Path Generator",
    "title": "Modifying Points",
    "content": "You can customize a path by editing its control points directly in the interface: . | Points can be dragged with the mouse. | To create a new point, click on an empty space. | To delete a point, right-click on it. | . ",
    "url": "https://ossia.io/score-docs/processes/pathgenerator.html#modifying-points",
    "relUrl": "/processes/pathgenerator.html#modifying-points"
  },"619": {
    "doc": "Path Generator",
    "title": "Parameters",
    "content": ". | Speed : The speed of the movement can be modified by adjusting the speed parameter. Points move faster or slower depending on the parameter. NOTE : Speed at 1 = movement takes 15 seconds to complete (one treatment cycle) . | Ping Pong : The PingPong option generates a continuous back-and-forth movement, avoiding a reset to the initial position. Instead of starting from the beginning, the animation naturally returns to the starting point. | Path : Path selection is made in this parameter. For the moment, straight line, circle and spiral paths are available. The linear path allows you to move in a straight line between the start point (green) and the end point (red). The circle path allows circular movement around the center point (green), depending on the radius defined in another parameter. The red cursor is useless in this case. The spiral path works in the same way as the circle, but generates a spiral movement. | Radius : The Radius parameter defines the X and Y radii of the circle or spiral to be followed. For a spiral, it corresponds to the final radius. NOTE : This parameter does not apply to the linear path. | . ",
    "url": "https://ossia.io/score-docs/processes/pathgenerator.html#parameters",
    "relUrl": "/processes/pathgenerator.html#parameters"
  },"620": {
    "doc": "Path Generator",
    "title": "How to combine paths",
    "content": "To give you more creative freedom when creating movements, you can combine several movements together. In this short tutorial, we’ll look at how to combine the following two movements. Once you’ve created the various movements using the path generator, you can connect each of them to an array flattener, and then connect them to an array of Combinators. In input count, you must indicate the number of path generators you wish to combine. Then choose Append mode, so as not to modify the initial movements. Result : . ",
    "url": "https://ossia.io/score-docs/processes/pathgenerator.html#how-to-combine-paths",
    "relUrl": "/processes/pathgenerator.html#how-to-combine-paths"
  },"621": {
    "doc": "Path Generator",
    "title": "Path Generator",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/pathgenerator.html",
    "relUrl": "/processes/pathgenerator.html"
  },"622": {
    "doc": "Pattern Applier",
    "title": "Pattern Applier",
    "content": ". Given an input list, this applies each element of a list to the individual addresses matching an address pattern expression. For instance, given the list: . [ 1, 6, 4, 5, 12, 4, 56 ] . and the device: . leds:/brightness/0 leds:/brightness/1 leds:/brightness/2 ... etc . Then the following will write 1 to leds:/brightness/0, 6 to leds:/brightness/1, etc. ",
    "url": "https://ossia.io/score-docs/processes/pattern-applier.html",
    "relUrl": "/processes/pattern-applier.html"
  },"623": {
    "doc": "Pattern Combiner",
    "title": "Pattern Combiner",
    "content": ". This object combines the (numeric) values of a set of address matched by an address pattern expression. For instance, given a set of OSC sensors which all have a value: . sensors:/temperature.* # 23° sensors:/temperature.* # 17° sensors:/temperature.* # 26° . Then the following will output the mean of the three temperature sensors, 22°: . ",
    "url": "https://ossia.io/score-docs/processes/pattern-combiner.html",
    "relUrl": "/processes/pattern-combiner.html"
  },"624": {
    "doc": "Pattern matching",
    "title": "Pattern matching",
    "content": "It is possible to control a set of addresses with pattern matching. For instance, given the following OSC device: . It is possible to send an automation to . OSCdevice:/sub/*/level . to control all the levels with a single curve. The complete reference of the supported pattern matching syntax is available here. ",
    "url": "https://ossia.io/score-docs/in-depth/pattern-matching.html",
    "relUrl": "/in-depth/pattern-matching.html"
  },"625": {
    "doc": "Pattern matching",
    "title": "Examples",
    "content": ". | device:/foo/bar . | Matches device:/foo/bar and nothing else | . | device:/foo/bar* . | Matches device:/foo/bar, device:/foo/bar.100, device:/foo/baron | . | device:/{foo,boo}/bar . | Matches device:/foo/bar, device:/boo/bar | . | device:/foo.{5..23} . | Matches device:/foo.5, device:/foo.6, … to device:/foo.23 | Won’t match device:/foo.230 | . | device:/foo.{5..23..7} . | Matches device:/foo.5, device:/foo.12, foo.17 | . | device:/foo[a-z] . | Matches device:/fooa, device:/foob, … device:/fooz | . | device:/foo[1-5] . | Matches device:/foo1, device:/foo2, … device:/foo5 | . | device://bar . | Matches device:/foo/bar, device:/foo/bar.123/bar, etc. | . | device://bob/../foo . | Given device:/foo/bob and device:/foo/bar.123/bob, matches device:/foo | . | device:/foo! . | Matches device:/foo, device:/foo.1, device:/foo.123, device:/foo.bob | . | . ",
    "url": "https://ossia.io/score-docs/in-depth/pattern-matching.html#examples",
    "relUrl": "/in-depth/pattern-matching.html#examples"
  },"626": {
    "doc": "Patternal",
    "title": "Patternal",
    "content": ". Turn rhythmic patterns into MIDI drums and percussion. Feed it arrays of velocities and it spits out perfectly timed MIDI notes - think of it as your digital drum machine that synchronizes to score’s musical timing. Perfect for drum programming, rhythmic experimentation, or any situation where you want to convert pattern data into MIDI percussion tracks. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html",
    "relUrl": "/processes/patternal.html"
  },"627": {
    "doc": "Patternal",
    "title": "How it works",
    "content": "Patternal takes pattern arrays where each pattern represents one drum sound (MIDI note) and a sequence of velocity values representing the rhythm. When it plays, each step in the pattern triggers at the right musical timing. Pattern input - Arrays of [note_number, [velocity, velocity, velocity...]] Musical sync - Automatically quantizes to musical timing MIDI output - Note-on/note-off messages sent to MIDI bus Multiple drums - Handle several drum sounds simultaneously . ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#how-it-works",
    "relUrl": "/processes/patternal.html#how-it-works"
  },"628": {
    "doc": "Patternal",
    "title": "Pattern format",
    "content": "Each pattern is a simple array with a MIDI note number and velocity sequence: . [ [36, [127, 0, 0, 0]], // Kick drum: hit on beat 1 [38, [0, 0, 64, 0]], // Snare: hit on beat 3 [42, [32, 0, 32, 0]] // Hi-hat: hits on beats 1 and 3 ] . Note numbers: Standard MIDI drum map (36 = kick, 38 = snare, 42 = hi-hat, etc.) Velocities: 0-127 where 0 = silent, 127 = maximum volume Pattern length: Can be any length - 4 steps, 8 steps, 16 steps, whatever you need . A simple example of script that generates patterns in the required format is available: the claves Javascript preset. It showcases how one can use the Total Serialism library shipped with score to support generation of stochastic rhythms. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#pattern-format",
    "relUrl": "/processes/patternal.html#pattern-format"
  },"629": {
    "doc": "Patternal",
    "title": "Creative applications",
    "content": "Drum programming: Create classic drum patterns - four-on-the-floor, breakbeats, latin rhythms, or experimental polyrhythms. Algorithmic composition: Generate patterns procedurally and feed them to Patternal for instant rhythmic results. Live performance: Change patterns in real-time during performances for dynamic drum arrangement. Polyrhythmic experiments: Use different pattern lengths for different drums to create complex interlocking rhythms. Pattern sequencing: Combine with Scenario to switch between different pattern sets over time. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#creative-applications",
    "relUrl": "/processes/patternal.html#creative-applications"
  },"630": {
    "doc": "Patternal",
    "title": "Musical timing and sync",
    "content": "Patternal automatically synchronizes to score’s musical timing system, which means: . Tempo sync: Pattern playback follows the project tempo - change the BPM and patterns speed up or slow down accordingly. Quantization: Pattern steps align perfectly to musical timing. Frame-accurate: MIDI messages are generated at precisely the right sample to maintain tight timing. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#musical-timing-and-sync",
    "relUrl": "/processes/patternal.html#musical-timing-and-sync"
  },"631": {
    "doc": "Patternal",
    "title": "Integration with score",
    "content": "Works seamlessly with score’s MIDI system - connect the output to MIDI devices, software synthesizers, or other MIDI processes. MIDI routing: Connect to any MIDI device or application that receives MIDI input. Effect processing: Send the generated patterns through various MIDI Effects for additional processing. Multiple instances: Run several Patternal processes for different drum kits or layered rhythmic elements. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#integration-with-score",
    "relUrl": "/processes/patternal.html#integration-with-score"
  },"632": {
    "doc": "Patternal",
    "title": "Advanced techniques",
    "content": "Variable pattern lengths: Mix 4-step kicks with 3-step hi-hats for interesting polyrhythmic effects. Velocity programming: Use different velocity levels to create realistic drum dynamics and accents. Ghost notes: Add subtle low-velocity hits between main beats for more human-like drum patterns. Pattern morphing: Gradually change pattern arrays to create smooth transitions between different rhythmic feels. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#advanced-techniques",
    "relUrl": "/processes/patternal.html#advanced-techniques"
  },"633": {
    "doc": "Patternal",
    "title": "Related processes",
    "content": "Patternal pairs perfectly with Melodial for complete drum and melody programming, works alongside MIDI devices for output routing, and integrates with Automation for dynamic pattern changes over time. ",
    "url": "https://ossia.io/score-docs/processes/patternal.html#related-processes",
    "relUrl": "/processes/patternal.html#related-processes"
  },"634": {
    "doc": "Patternist",
    "title": "MIDI Pattern Sequencer",
    "content": ". A classic MIDI pattern sequencer. On the left of the sequencer, there is the actual note of the lane with a corresponding number. Each step correspond to a measure. If the step is activated (yellow), the note will be played. The note corresponding to each lane can be changed by clicking on it and dragging. This process can have multiple distinct patterns which can be switched. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#midi-pattern-sequencer",
    "relUrl": "/processes/patternist.html#midi-pattern-sequencer"
  },"635": {
    "doc": "Patternist",
    "title": "Channel",
    "content": "On which MIDI channel the output goes. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#channel",
    "relUrl": "/processes/patternist.html#channel"
  },"636": {
    "doc": "Patternist",
    "title": "Current Pattern",
    "content": "The index of the current pattern. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#current-pattern",
    "relUrl": "/processes/patternist.html#current-pattern"
  },"637": {
    "doc": "Patternist",
    "title": "Lanes",
    "content": "Each lane corresponds to one MIDI note. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#lanes",
    "relUrl": "/processes/patternist.html#lanes"
  },"638": {
    "doc": "Patternist",
    "title": "Step",
    "content": "How many steps there are in a pattern. The minimal amount of steps is 4 and the maximum is 32. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#step",
    "relUrl": "/processes/patternist.html#step"
  },"639": {
    "doc": "Patternist",
    "title": "Rate",
    "content": "To which musical declination corresponds a step: quarter note, 16th note, etc. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#rate",
    "relUrl": "/processes/patternist.html#rate"
  },"640": {
    "doc": "Patternist",
    "title": "Workflow tips",
    "content": "Start simple: Begin with basic 4-step patterns before experimenting with complex polyrhythms. Think in layers: Build patterns one drum sound at a time rather than trying to program everything at once. Use standard drum maps: Stick to General MIDI drum note numbers for compatibility with most drum software and hardware. Test timing: Verify that your patterns align correctly with the musical timing before building complex arrangements. ",
    "url": "https://ossia.io/score-docs/processes/patternist.html#workflow-tips",
    "relUrl": "/processes/patternist.html#workflow-tips"
  },"641": {
    "doc": "Patternist",
    "title": "Patternist",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/patternist.html",
    "relUrl": "/processes/patternist.html"
  },"642": {
    "doc": "Piano roll",
    "title": "Piano roll",
    "content": ". The piano roll allows to output MIDI notes according to a score. MIDI files can be loaded by drag’n’drop, either on a scenario, interval, or on the piano roll process directly. Adding a note is done by double-clicking ; the note can be stretched with the mouse. When dropping a MIDI file, if Shift is held, the tracks are put in sequence instead of in parallel. Velocity of MIDI notes can now be changed with Shift+Click - the more saturated the note, the higher the velocity. ",
    "url": "https://ossia.io/score-docs/processes/piano-roll.html",
    "relUrl": "/processes/piano-roll.html"
  },"643": {
    "doc": "Pixel Utilities",
    "title": "Pixel Utilities",
    "content": ". Work with individual pixels and pixel-level operations for precise graphics control and analysis. These utilities let you examine, manipulate, and extract data from images at the pixel level for detailed visual processing. Perfect for LED installations, pixel mapping, color analysis, or any application where you need precise control over individual picture elements. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html",
    "relUrl": "/processes/pixel-utilities.html"
  },"644": {
    "doc": "Pixel Utilities",
    "title": "Available utilities",
    "content": "The Pixel Utilities collection includes specialized tools for different aspects of pixel-level work: . Lightness Computer . Extract luminance and brightness information from visual content for control purposes. This utility analyzes pixel brightness to generate control signals. Color analysis: Convert RGB pixel data to luminance values for brightness-based control. Region sampling: Extract brightness from specific areas of images or video for targeted control. Averaging modes: Various methods for combining pixel data - mean, maximum, weighted averages. Real-time processing: Fast pixel analysis suitable for live video processing and control generation. LED View . Specialized display for LED installations and pixel-mapped lighting systems. Pixel mapping: Direct mapping between image pixels and physical LED arrays. Color correction: Per-pixel color adjustment for accurate LED reproduction. Brightness scaling: Automatic scaling for different LED brightness characteristics. Layout configuration: Support for various LED strip layouts and configurations. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#available-utilities",
    "relUrl": "/processes/pixel-utilities.html#available-utilities"
  },"645": {
    "doc": "Pixel Utilities",
    "title": "Creative applications",
    "content": "LED installations: Drive LED strips, matrices, or architectural lighting directly from visual content with pixel-perfect accuracy. Color extraction: Extract color information from live video or images to control lighting, audio parameters, or other systems. Visual analysis: Analyze visual content for brightness patterns, color distribution, or movement detection. Pixel art: Create and manipulate pixel-art content with precise control over individual picture elements. Data visualization: Convert numerical data into pixel patterns for visual representation and analysis. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#creative-applications",
    "relUrl": "/processes/pixel-utilities.html#creative-applications"
  },"646": {
    "doc": "Pixel Utilities",
    "title": "Integration techniques",
    "content": "Video to control: Use pixel analysis to convert visual content into control signals for Audio Effects, spatial audio positioning, or other parameter control. LED synchronization: Synchronize LED displays with audio content by analyzing visual representations of sound. Interactive visuals: Create systems where pixel-level analysis of camera input drives visual or audio responses. Color mapping: Extract color palettes from images and apply them to other visual or lighting systems. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#integration-techniques",
    "relUrl": "/processes/pixel-utilities.html#integration-techniques"
  },"647": {
    "doc": "Pixel Utilities",
    "title": "Technical features",
    "content": "High-performance processing: Optimized algorithms for real-time pixel operations even with high-resolution content. Multiple color spaces: Support for RGB, HSV, LAB, and other color representations for flexible pixel analysis. Sampling patterns: Various methods for selecting and analyzing pixel data - random sampling, grid patterns, region-based analysis. Memory efficiency: Smart caching and processing to handle large images without excessive memory usage. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#technical-features",
    "relUrl": "/processes/pixel-utilities.html#technical-features"
  },"648": {
    "doc": "Pixel Utilities",
    "title": "LED installation workflow",
    "content": ". | Configure your LED layout - Define the physical arrangement of your LEDs | Set up pixel mapping - Map image pixels to physical LED positions | Calibrate colors - Adjust for LED color characteristics and brightness | Test the installation - Verify pixel-accurate mapping and color reproduction | Optimize performance - Adjust processing settings for smooth real-time operation | . ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#led-installation-workflow",
    "relUrl": "/processes/pixel-utilities.html#led-installation-workflow"
  },"649": {
    "doc": "Pixel Utilities",
    "title": "Performance considerations",
    "content": "Resolution scaling: Higher resolution content requires more processing power - balance quality with performance needs. Update rates: Consider LED refresh rates and processing capabilities when setting update frequencies. Color accuracy: Different LEDs have different color characteristics - calibration is essential for accurate reproduction. Power management: Large LED installations can consume significant power - plan electrical requirements accordingly. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#performance-considerations",
    "relUrl": "/processes/pixel-utilities.html#performance-considerations"
  },"650": {
    "doc": "Pixel Utilities",
    "title": "Related processes",
    "content": "Pixel Utilities work with Video for content source, Graphics Utilities for image processing, Display Utilities for output management, and can drive Audio Effects or spatial audio through extracted control data. ",
    "url": "https://ossia.io/score-docs/processes/pixel-utilities.html#related-processes",
    "relUrl": "/processes/pixel-utilities.html#related-processes"
  },"651": {
    "doc": "Plug-ins",
    "title": "Prerequisites",
    "content": "This guide assumes that a development environment with all required dependencies has been set-up. Check the “hacking on score” guide for more information on how to do that. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#prerequisites",
    "relUrl": "/development/plug-ins.html#prerequisites"
  },"652": {
    "doc": "Plug-ins",
    "title": "Choosing the plug-in API to use",
    "content": "ossia score provides two plug-in APIs: . ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#choosing-the-plug-in-api-to-use",
    "relUrl": "/development/plug-ins.html#choosing-the-plug-in-api-to-use"
  },"653": {
    "doc": "Plug-ins",
    "title": "Avendish API",
    "content": "A simple API that can be used to implement quick audio / midi / control effects and generators in a single file. This is the API to use if you want to provide for instance a new audio or video processor to use as an ossia object. The documentation of the Avendish API is available here: note in particular that the plug-ins written with Avendish are independent from ossia score and can also be exported to other systems, such as VST, etc. ossia score is however the implementation that provides most of the features :-) . Read the score avendish plug-in documentation to get started. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#avendish-api",
    "relUrl": "/development/plug-ins.html#avendish-api"
  },"654": {
    "doc": "Plug-ins",
    "title": "Score API",
    "content": "A more advanced API that allows to customize pretty much every aspect of the software, but requires more work. The major part of the software is built with that API: every process in score comes from plug-ins. These plug-ins are located in the score git repository. The addon tutorial is an example of usage of the score API to showcase its capabilities. It is documented here. To develop new plug-ins that way, we provide a set of Github templates. Simply create a repository from the template, and follow the steps in the README. ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html#score-api",
    "relUrl": "/development/plug-ins.html#score-api"
  },"655": {
    "doc": "Plug-ins",
    "title": "Plug-ins",
    "content": " ",
    "url": "https://ossia.io/score-docs/development/plug-ins.html",
    "relUrl": "/development/plug-ins.html"
  },"656": {
    "doc": "Point2D View",
    "title": "Point2D View",
    "content": ". Visualize control signals in real-time for monitoring, debugging, and performance feedback. Point2D View is a monitoring tool specialized for visualizing the position of groups of 2D positions. ",
    "url": "https://ossia.io/score-docs/processes/point2d-view.html",
    "relUrl": "/processes/point2d-view.html"
  },"657": {
    "doc": "Point2D View",
    "title": "Related processes",
    "content": "score comes with multiple processes for monitoring input data LED View, Signal Display, Value display. ",
    "url": "https://ossia.io/score-docs/processes/point2d-view.html#related-processes",
    "relUrl": "/processes/point2d-view.html#related-processes"
  },"658": {
    "doc": "Poles",
    "title": "Poles",
    "content": ". The Poles process generates smooth Gaussian curve distributions centered around adjustable positions. Perfect for creating natural-feeling transitions, smooth value distributions, and organic control curves in interactive systems. ",
    "url": "https://ossia.io/score-docs/processes/poles.html",
    "relUrl": "/processes/poles.html"
  },"659": {
    "doc": "Poles",
    "title": "Parameters",
    "content": "Pos (Position) . Type: Knob (float) Range: -1.0 to 1.0 Default: 0.0 . Sets the center position of the Gaussian curve along the output array. The curve peak will be positioned at this location: . | -1.0 = Peak at the left end of the array | 0.0 = Peak at the center of the array | 1.0 = Peak at the right end of the array | . Length . Type: Spinbox (integer) Range: 1 to 1000 Default: 20 . Determines the number of output values in the generated array. Higher values provide smoother curves but use more memory and processing. Sigma . Type: Knob (float, logarithmic) Range: 0.001 to 1.0 Default: 0.01 . Controls the width (standard deviation) of the Gaussian curve: . | Smaller values = Narrow, sharp peaks | Larger values = Wide, gentle curves | Logarithmic mapping = Better control over small values | . Range . Type: Knob (float) Range: 0.0 to 1.0 Default: 1.0 . Multiplier for the output values, controlling the maximum height of the curve: . | 0.0 = Flat output (all zeros) | 0.5 = Half-height curve | 1.0 = Full-height curve | . ",
    "url": "https://ossia.io/score-docs/processes/poles.html#parameters",
    "relUrl": "/processes/poles.html#parameters"
  },"660": {
    "doc": "Poles",
    "title": "Output",
    "content": "Out . Type: Array of floats Content: Gaussian curve values . Provides an array of floating-point values representing the Gaussian curve distribution. ",
    "url": "https://ossia.io/score-docs/processes/poles.html#output",
    "relUrl": "/processes/poles.html#output"
  },"661": {
    "doc": "Poles",
    "title": "Mathematical Foundation",
    "content": "The Poles process implements the Gaussian probability density function: . f(x) = (1 / (σ√(2π))) × e^(-½((x-μ)/σ)²) . Where: . | μ (mu) = mean (position parameter) | σ (sigma) = standard deviation (width parameter) | x = position along the curve | . ",
    "url": "https://ossia.io/score-docs/processes/poles.html#mathematical-foundation",
    "relUrl": "/processes/poles.html#mathematical-foundation"
  },"662": {
    "doc": "Poles",
    "title": "Usage Examples",
    "content": "Smooth Value Distribution . [Poles] → [Array to Multiple Outputs] → [LED Strip Control] ↑ [Position Automation] . Create smooth lighting transitions across LED strips with the peak following an animation. Audio Envelope Generation . [Poles] → [Array Processor] → [Audio Amplitude Control] ↑ [Note Trigger] → [Position Control] . Generate smooth audio envelopes with controllable attack and decay characteristics. Spatial Audio Panning . [Poles] → [Speaker Array Mapping] → [Multi-channel Audio] ↑ [Motion Tracker] → [Position Input] . Create smooth spatial audio transitions where sound intensity follows a Gaussian distribution across speakers. Visual Effects . [Poles] → [Shader Parameters] → [Gaussian Blur Effect] ↑ [Mouse Position] → [Real-time Control] . Control visual effects with smooth, natural-feeling parameter distributions. ",
    "url": "https://ossia.io/score-docs/processes/poles.html#usage-examples",
    "relUrl": "/processes/poles.html#usage-examples"
  },"663": {
    "doc": "Poles",
    "title": "Curve Shape Examples",
    "content": "Narrow Peak (Small Sigma) . Sigma = 0.01, Length = 20: [0.0, 0.0, 0.0, 0.1, 0.8, 1.0, 0.8, 0.1, 0.0, 0.0, 0.0, ...] Sharp peak at center . Wide Curve (Large Sigma) . Sigma = 0.3, Length = 20: [0.2, 0.4, 0.6, 0.8, 0.9, 1.0, 0.9, 0.8, 0.6, 0.4, 0.2, ...] Gentle, wide distribution . Position Offset . Pos = -0.5, Sigma = 0.1: [1.0, 0.8, 0.3, 0.1, 0.0, 0.0, 0.0, ...] Peak shifted to left side . ",
    "url": "https://ossia.io/score-docs/processes/poles.html#curve-shape-examples",
    "relUrl": "/processes/poles.html#curve-shape-examples"
  },"664": {
    "doc": "Poles",
    "title": "Advanced Applications",
    "content": "Multi-pole Systems . Combine multiple Poles processes for complex distributions: . [Poles 1] → [Array Combiner] ← [Poles 2] ↓ ↓ [Position A] [Position B] ↓ ↓ [Dual-peak Distribution] . Dynamic Curve Morphing . [Poles] → [Output Array] ↑ [LFO] → [Sigma Modulation] [Position Automation] . Create morphing curves by simultaneously animating position and width. Scientific Data Visualization . [Poles] → [Data Visualization] → [Research Display] ↑ [Measured Values] → [Statistical Modeling] . Model experimental data distributions or create probability visualizations. Interactive Installations . [Motion Sensor] → [Poles] → [Light Installation] ↑ [Distance Mapping] → [Sigma Control] . Create installations where viewer proximity controls both position and spread of effects. ",
    "url": "https://ossia.io/score-docs/processes/poles.html#advanced-applications",
    "relUrl": "/processes/poles.html#advanced-applications"
  },"665": {
    "doc": "Poles",
    "title": "Related Processes",
    "content": ". | LFO: Generate periodic control signals | . ",
    "url": "https://ossia.io/score-docs/processes/poles.html#related-processes",
    "relUrl": "/processes/poles.html#related-processes"
  },"666": {
    "doc": "Polyphonic behaviours",
    "title": "Polyphonic behaviours",
    "content": "ossia supports some amount of polyphony especially for audio process. Note that the polyphony has only been implemented with Faust at the moment and select Avendish processes. To support polyphony: . | The audio processor must be a mono one. For instance, in a Faust process, make sure that you only have one input and one output: process = _ : _;. | From now on, the right number of channels will be instantiated: sending 3 channels in will result in 3 processed channels out. | In addition, it is possible to control the parameters on each channel individually: instead of sending a float to the port, sending a list will map each value to each individual channel. | . ",
    "url": "https://ossia.io/score-docs/docs/advanced/polyphony.html",
    "relUrl": "/docs/advanced/polyphony.html"
  },"667": {
    "doc": "Score preferences",
    "title": "Audio",
    "content": "Audio settings allow to configure which sound card score is going to use for playback. If no sound is needed, it is possible to set the “Dummy” engine which won’t output sound. ",
    "url": "https://ossia.io/score-docs/reference/preferences.html#audio",
    "relUrl": "/reference/preferences.html#audio"
  },"668": {
    "doc": "Score preferences",
    "title": "Execution",
    "content": "Note that every execution settings change require stopping and restarting the playback of the current score. Enable listening during execution . This controls whether the Device Explorer panel updates its UI when the score is running. If there are thousands of parameters being updated all the time, monitoring them and updating the UI to show their new value can take some CPU usage which is not always required. Logging . When “Logging” is selected in the settings, if you click on the title of a process, then the Messages panel (Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac)) will show all the messages getting in and out of that process. Benchmark . When “Benchmark” is selected in the settings, the relative computation time of each process will be computed. This is useful for instance to find if there is a super intensive process taking too much CPU. Advanced execution settings . Parallel . Runs the processes on separate CPU cores as far as possible. Value compilation . When doing a “play from here”, this will try to guesstimate in which state the score should be at that point, by looking for the closest previous sent messages in the score and sending them to the devices. Transport value compilation . Same as value compilation, but redoes it every time you do a transport while the score is playing, with the “play” tool. ",
    "url": "https://ossia.io/score-docs/reference/preferences.html#execution",
    "relUrl": "/reference/preferences.html#execution"
  },"669": {
    "doc": "Score preferences",
    "title": "Score preferences",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference/preferences.html",
    "relUrl": "/reference/preferences.html"
  },"670": {
    "doc": "Presets",
    "title": "Presets",
    "content": " ",
    "url": "https://ossia.io/score-docs/presets.html",
    "relUrl": "/presets.html"
  },"671": {
    "doc": "Presets",
    "title": "Process presets",
    "content": "Not available yet. ",
    "url": "https://ossia.io/score-docs/presets.html#process-presets",
    "relUrl": "/presets.html#process-presets"
  },"672": {
    "doc": "Presets",
    "title": "Scenario presets",
    "content": ". | Select a part of the score. | Drag it with Alt pressed into the user library, in some folder. | The selected part is now saved on the disk, in a .scenario file. | It can now be put in the score again by dragging it from the inspector. | . ",
    "url": "https://ossia.io/score-docs/presets.html#scenario-presets",
    "relUrl": "/presets.html#scenario-presets"
  },"673": {
    "doc": "Process Launcher",
    "title": "Process Launcher",
    "content": ". The Process Launcher allows you to launch and manage external system processes directly from your ossia score timeline. This powerful utility lets you integrate external scripts, commands, or applications into your interactive performances. ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html",
    "relUrl": "/processes/process-launcher.html"
  },"674": {
    "doc": "Process Launcher",
    "title": "Overview",
    "content": "The Process Launcher process executes external commands or scripts for the lifetime of the process object. When the process starts in the timeline, the external command is launched. When the process stops or is removed, the external command is terminated. Process Launcher enables: . | External application execution with command-line arguments | System process integration for complex workflows | Script execution (Python, shell scripts, etc.) | Process lifetime management tied to score timeline | Cross-platform compatibility (Windows, macOS, Linux) | . Perfect for: . | Integrating external tools and utilities | Running analysis scripts and data processing | Launching companion applications | System administration tasks | Custom automation workflows | Educational and research applications | . ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html#overview",
    "relUrl": "/processes/process-launcher.html#overview"
  },"675": {
    "doc": "Process Launcher",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Command | String | Executable command and arguments | . ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html#inputs",
    "relUrl": "/processes/process-launcher.html#inputs"
  },"676": {
    "doc": "Process Launcher",
    "title": "Technical Implementation",
    "content": "The Process Launcher uses Qt’s QProcess internally, ensuring proper cross-platform process management. The external process is launched in a separate thread and managed through Qt’s event loop system. ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html#technical-implementation",
    "relUrl": "/processes/process-launcher.html#technical-implementation"
  },"677": {
    "doc": "Process Launcher",
    "title": "Related Processes",
    "content": ". | Shell Command - Bash shell script | JavaScript - Scripting within score | HTTP Device - Web service integration | . ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html#related-processes",
    "relUrl": "/processes/process-launcher.html#related-processes"
  },"678": {
    "doc": "Process Launcher",
    "title": "Try it!",
    "content": "Try it by downloading this simple example!. Note that the example requires the xeyes binary. On windows you can replace with explorer.exe and on Mac, something in your /Applications. ",
    "url": "https://ossia.io/score-docs/processes/process-launcher.html#try-it",
    "relUrl": "/processes/process-launcher.html#try-it"
  },"679": {
    "doc": "Processes",
    "title": "Processes",
    "content": "score comes with a number of included processes. These cover various needs of action for advanced parameter control. This section of the manual covers the general usage of Processes as well a detailed documentation of each included Processes. ",
    "url": "https://ossia.io/score-docs/processes.html",
    "relUrl": "/processes.html"
  },"680": {
    "doc": "Processes",
    "title": "General description",
    "content": "score allows to handle a number of actions evolving either through some amount of time, or at a single instant. These processes can either be actions evolving during a given duration, such as automation of a given device’s parameter, or actions activated only in a defined duration, such as mapping or LFO modulations. Processes are attached to an interval in the scenario when they represent an evolving behaviour, and to a state when they are instantaneous. ",
    "url": "https://ossia.io/score-docs/processes.html#general-description",
    "relUrl": "/processes.html#general-description"
  },"681": {
    "doc": "Processes",
    "title": "Basics",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#basics",
    "relUrl": "/processes.html#basics"
  },"682": {
    "doc": "Processes",
    "title": "Create processes on intervals",
    "content": "Using drag &amp; drop . From the Device explorer . Processes can be created by drag &amp; dropping parameters from the Device explorer onto an existing interval in the scenario. The interval to which processes will be attached turns to yellow as the mouse with selection hovers it. The Device explorer selection may contain one or several parameters. When multiple parameters are dropped, processes get stacked in different layers. From the libraries . Processes can also be created by drag &amp; dropping the desired process from the Process library or the User library in the scenario. When doing so, score automatically creates the interval to which process will get attached. You may as well drop a process onto an existing interval. Note that both namespace selection and processes selection can be dropped onto an interval to which some processes are already attached. Depending on the type of processes, these may be created on top of processes already in place or at a slot below. Audio, video and script files (Faust DSP, GLSL fragment shader, JS script…) can also be drag’n’dropped inside a scenario from your desktop’s file manager. By default, dropping several processes at the same time stacks them in the same interval. Holding the Maj key while dropping will create sequential intervals for each item in the selection. If a process is currently selected in the score, it is also possible to create a new process afterwards by double-clicking on it in the library. This will only work if the processes are compatible: the first output port of the selected process must be of the same type than the first input port of the process double-clicked in the library. A connection between the two ports will automatically be made. This allows to easily chain effects: . Likewise, if an output port is currently selected in the score, double-clicking on a process in the list will create and connect it afterwards if compatible. ",
    "url": "https://ossia.io/score-docs/processes.html#create-processes-on-intervals",
    "relUrl": "/processes.html#create-processes-on-intervals"
  },"683": {
    "doc": "Processes",
    "title": "Create processes on a state",
    "content": "Adding processes on a state is a way to run a computation at a single, precise point in the timeline. The processes will not be directly visible in the timeline ; the state has to be selected to edit their properties through the inspector. It is done by right-clicking on the state in the object inspector, and selecting the Add process option. ",
    "url": "https://ossia.io/score-docs/processes.html#create-processes-on-a-state",
    "relUrl": "/processes.html#create-processes-on-a-state"
  },"684": {
    "doc": "Processes",
    "title": "Remove existing processes",
    "content": "Using keyboard . To remove a process, select it (for example by clicking on the slot background) and choose Remove from the Object menu (Suppr/Backspace key). Make sure the process you want to remove is properly selected when bringing it to front (for example, check the inspector) ! . From Graph inspector . Processes can also be deleted from the Graph inspector at the top of score’s right panel. In the scenario, select the interval the process to remove is attached to. In the Graph inspector, browse through the attached processes and select the one to remove. Right-click to open the contextual menu and choose Remove (or use Suppr/Backspace key). ",
    "url": "https://ossia.io/score-docs/processes.html#remove-existing-processes",
    "relUrl": "/processes.html#remove-existing-processes"
  },"685": {
    "doc": "Processes",
    "title": "Edit processes",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#edit-processes",
    "relUrl": "/processes.html#edit-processes"
  },"686": {
    "doc": "Processes",
    "title": "Fullsize edit",
    "content": "Processes can be edited in full size. This is especially handy when you want to precisely edit a process such as an automation or mapping function. To display the process in full size, double-click on the interval the process is attached to. Process is now displayed using score central panel full width. Note that if several processes are attached to an interval, open them in full size will display all at once juxtaposed as shown below (see the Multiple processes interval). To exit full size mode (go back to parent scenario), click the desired node of the path displayed at the top or use the Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac) shortcut. ",
    "url": "https://ossia.io/score-docs/processes.html#fullsize-edit",
    "relUrl": "/processes.html#fullsize-edit"
  },"687": {
    "doc": "Processes",
    "title": "Process Loops",
    "content": "Time-based processes such as automations, media and sub-scenarios can be looped for as long as their parent interval is active. When selecting a process, either from the object panel or by clicking on process header, the loop option will appear in the Inspector. ",
    "url": "https://ossia.io/score-docs/processes.html#process-loops",
    "relUrl": "/processes.html#process-loops"
  },"688": {
    "doc": "Processes",
    "title": "Manage processes",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes.html#manage-processes",
    "relUrl": "/processes.html#manage-processes"
  },"689": {
    "doc": "Processes",
    "title": "Fold/unfold attached processes",
    "content": "Processes attached to an interval can easily be fold/unfold. This comes up especially usefull when working with a lot of processes while still maintaining some screen space and the scenario readable. To do so, click the blue arrow on top of the processes to fold/unfold. When selecting an interval, attached processes can also be fold/unfold using the Show processes &amp; Hide processes entries from the Object menu. ",
    "url": "https://ossia.io/score-docs/processes.html#foldunfold-attached-processes",
    "relUrl": "/processes.html#foldunfold-attached-processes"
  },"690": {
    "doc": "Processes",
    "title": "Stacked slots",
    "content": "Time-based processes (that is, processes whose x represents time, such as automations, media files) can be stacked on a same slot. This is the default presentation when dragging some parameters onto an interval or dragging a process from library onto an interval. In that case, top-most process is displayed in full color while processes in other layers or displayed in semi transparent color. You can of course re-arrange them as you want. Bring to front . To change which process to display top-most, mouse over to the top of the process slot displaying the destination address. Clicking the address bar opens up a contextual menu listing all layered processes. Selecting one in the menu brings it to front. Move to new slot . Processes can also be juxtaposed in several slots rather than stacked on top of the other. Grab the handle at the top left corner of the slot and drag &amp; drop it on another slot to move it above another process or between different slots to insert it. Processes can also be dragged &amp; attached to a new interval . ",
    "url": "https://ossia.io/score-docs/processes.html#stacked-slots",
    "relUrl": "/processes.html#stacked-slots"
  },"691": {
    "doc": "Supported protocols and formats",
    "title": "Operating systems",
    "content": "score works on Linux, macOS, Windows, and partially on the web platform. Its development mainly happens on an ArchLinux system. As score is built with Qt, it should be portable to any system where Qt runs. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#operating-systems",
    "relUrl": "/reference/protocols-and-formats.html#operating-systems"
  },"692": {
    "doc": "Supported protocols and formats",
    "title": "Network protocols",
    "content": ". | OSC (Open Sound Control): the standard intermedia protocol. It is implemented through a heavily modified version of Ross Bencina’s oscpack library. | Documented here. | . | OSCQuery: . | Documented here. | . | Minuit. | Documented here. | . | HTTP. | Documented here. | . | WebSockets. | Documented here. | . | CoAP. | Documented here. | . | MQTT. | Documented here. | . | LSL (Lab Streaming Layer). | Documented here. | . | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#network-protocols",
    "relUrl": "/reference/protocols-and-formats.html#network-protocols"
  },"693": {
    "doc": "Supported protocols and formats",
    "title": "Lighting protocols",
    "content": ". | Art-Net / DMX: the standard for lighting fixtures. Support is implemented through libartnet, which has been integrated inside libossia. score is able to load fixtures definitions in the open-fixture-library format. | Documented here. | . | LED Strip Support: Comprehensive support for LED strips including NeoPixel (WS2812), individual LED control, and strip/pane/volume layouts through Art-Net. Supports RGB, RGBW, and specialized diode configurations (Warm/Cold White, Amber, UV). | s.ACN / E1.31 is supported. | ENTTEC DMX USB Pro devices are supported (Mk1 and Mk2). | DMX input and output are both supported. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#lighting-protocols",
    "relUrl": "/reference/protocols-and-formats.html#lighting-protocols"
  },"694": {
    "doc": "Supported protocols and formats",
    "title": "Hardware protocols",
    "content": ". | Serial port: score can read/write directly through serial ports, either directly or through Bluetooth. Support is currently based on the Qt SerialPort library but is being ported to ASIO to allow it to run in environments that cannot use Qt. | Documented here. | . | Game pads: they are supported through the SDL2 gamepad library. Most gamepads and joysticks should work without issue. | Documented here. | . | Wiimotes: they are supported through the WiiUse library. | Documented here. | . | LeapMotion / UltraLeap: they are supported through the UltraLeap SDK (Gemini / Hyperion) which must be installed on the target computer. | Documented here. | . | GPIOs, ADCs, PWMs etc.: they are supported through the SimpleIO library which is a simple wrapper over the raw kernel access. This feature is only available on Linux with the relevant hardware, for instance on Raspberry Pi. | Documented here. | . | BLE: Bluetooth Low Energy devices are supported through the SimpleBLE. Both reading advertisments / beacons / manufacturer data and GATT services is supported. | Documented here. | . | GPS: score can connect to a gpsd server and expose the GPS data. | Documented here. | . | Phidgets: they are supported through an implementation in libossia. Note that score must be built from source with the Phidgets API for the Phidgets protocol to be enabled. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#hardware-protocols",
    "relUrl": "/reference/protocols-and-formats.html#hardware-protocols"
  },"695": {
    "doc": "Supported protocols and formats",
    "title": "Audio systems",
    "content": ". | JACK: support is implemented in libossia. | PulseAudio: experimental support is implemented in libossia. | PipeWire: implemented in libossia and in score. | ALSA, the native Linux backend, supported through PortAudio. A direct implementation is also provided for instance for working with as low latency as possible on embedded devices, but it only supports output, not duplex / input. | CoreAudio: the native macOS backend, supported through PortAudio. | MME, WASAPI, WDMKS: the native Windows backends, supported through PortAudio. | ASIO: the low-latency pro-audio Windows backend developed by Steinberg, supported through PortAudio. | SDL: support is implemented in libossia. It is mainly used to provide audio for the WebAssembly build of score. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-systems",
    "relUrl": "/reference/protocols-and-formats.html#audio-systems"
  },"696": {
    "doc": "Supported protocols and formats",
    "title": "Video protocols",
    "content": ". | Spout is supported on Windows. | Documented here. | . | Syphon is supported on macOS. | Documented here. | . | Shmdata is supported on Linux and macOS. | Documented here. | . | Sh4lt: Advanced shared memory video/audio streaming protocol supporting any data type (multichannel audio, video frames, 3D models, messages). Provides zero-copy, server-less communication between applications with dynamic buffer resizing and hot connection/disconnection. Available for input and output. | NDI is supported on Windows, Linux and macOS. | NDI PTZ is supported for controlling cameras with PTZ feature. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#video-protocols",
    "relUrl": "/reference/protocols-and-formats.html#video-protocols"
  },"697": {
    "doc": "Supported protocols and formats",
    "title": "Transport synchronisation",
    "content": ". | JACK transport: score can act as a master or a slave. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#transport-synchronisation",
    "relUrl": "/reference/protocols-and-formats.html#transport-synchronisation"
  },"698": {
    "doc": "Supported protocols and formats",
    "title": "MIDI",
    "content": "All the MIDI support in score comes from the libremidi library: . For real-time communication, the following implementations are provided: . | ALSA, through either the raw or sequencer API. | JACK. | PipeWire. | The native operating systems MIDI API: MME for Windows, CoreMIDI for macOS. | WebMIDI. | . In addition, score is able to load Standard MIDI files (SMF). See the MIDI documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#midi",
    "relUrl": "/reference/protocols-and-formats.html#midi"
  },"699": {
    "doc": "Supported protocols and formats",
    "title": "Audio file formats",
    "content": "score uses FFMPEG for its audio needs. It should support most codecs and formats listed at this page. Every standard format (WAV, W64, AIFF, MP3, OGG Vorbis, FLAC, etc.) are supported without issues. score handles WAV files in a specific way, through the dr_wav library, to allow for memory-mapping the data for large files. score is able to read ACID tags to devise for instance BPM info from sound files. See the sound file process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#audio-file-formats"
  },"700": {
    "doc": "Supported protocols and formats",
    "title": "Video file formats",
    "content": "score uses FFMPEG for its video needs. It should support most codecs and formats listed at this page. In particular, H.264, H.265, Apple ProRes, AVCHD, etc. should be supported. HAP codecs are handled in a different way: for maximum performance, decoding is done by score (which allows doing it on the graphics card, while FFMPEG’s HAP decoding happens on the CPU which defeats the point of the codec). See the video process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#video-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#video-file-formats"
  },"701": {
    "doc": "Supported protocols and formats",
    "title": "Hardware decoding",
    "content": "score can use OS video decoding APIs through FFMPEG. This allows for instance to decode H264 video on a Raspberry Pi 4 and apply live effects on it with only 15% CPU usage. Supported APIs are: . | DXVA2 / D3D11 on Window. | VideoToolbox on macOS. | V4L2-M2M on Raspberry Pi and embedded. | . If one builds score from source with a custom FFMPEG version, or through a Linux distribution, it is also possible to have CUDA and QuickSync support. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#hardware-decoding",
    "relUrl": "/reference/protocols-and-formats.html#hardware-decoding"
  },"702": {
    "doc": "Supported protocols and formats",
    "title": "Hardware rendering",
    "content": "score will try to render some common video texture formats on the GPU with shaders instead of converting them to RGB on the CPU, for maximum performance. Make sure that your video frames are in one of these pixel formats: if so, decoding won’t take CPU time. | RGB, RGBA, ARGB, ABGR and any variation thereof, planar or packed, 8 bits (int) or 32 bits (float) | YUV420P | YUV420P10 | YUV420P12 | YUV422P | YUV422P10 | YUV422P12 | NV12 | YUYV422, UYVY422 | HAP, HAP-Q, HAP-M | . Supported color spaces for source videos are BT.601, BT.709 and BT.2020. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#hardware-rendering",
    "relUrl": "/reference/protocols-and-formats.html#hardware-rendering"
  },"703": {
    "doc": "Supported protocols and formats",
    "title": "Image file formats",
    "content": "score uses Qt’s QImage for decoding images. The supported formats are PNG, GIF, JPEG. See the image process documentation for more information. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#image-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#image-file-formats"
  },"704": {
    "doc": "Supported protocols and formats",
    "title": "3D file formats",
    "content": "score can load .obj and .ply files through the Object Loader process. In addition, the JS object allows to leverage Qt3D and QtQuick3D which both support loading many more formats (most importantly glTF / GLB). ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#3d-file-formats",
    "relUrl": "/reference/protocols-and-formats.html#3d-file-formats"
  },"705": {
    "doc": "Supported protocols and formats",
    "title": "Graphics APIs",
    "content": "score uses Qt RHI as graphics abstraction for the video pipeline. It is able to use OpenGL ES 2.0, Vulkan, Metal, Direct3D 11 and Direct3D 12 in a very efficient way. score shaders are written with the Interactive Shader Format specification. See the shader process documentation for more information on how to write score shaders. See the general video documentation for general information on the score graphics rendering pipeline. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#graphics-apis",
    "relUrl": "/reference/protocols-and-formats.html#graphics-apis"
  },"706": {
    "doc": "Supported protocols and formats",
    "title": "Audio plug-ins",
    "content": "score supports the following audio plug-in systems: . | AirWindows on all platforms. | Documented here. | . | CLAP on all platforms. | Documented here. | . | Steinberg VST3 on all platforms. | Documented here. | . | LV2 on Linux. Note that currently this requires building score on your own computer or use a Linux distro package. | Documented here. | . | JSFX is embedded in score through ysfx. | Documented here. | . | Faust, the Faust programming language developed by GRAME. score embeds the Faust compiler and libraries. | Documented here. | . | Pure Data is embedded in score through libpd. | Documented here. | . | It is possible to write simple audio instruments and effects with the various math-expression processes. | It is possible to write simple audio instruments and effects with the JavaScript process. | It is possible to write more advanced instruments and effects in C++ with the C++ JIT process. | . ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html#audio-plug-ins",
    "relUrl": "/reference/protocols-and-formats.html#audio-plug-ins"
  },"707": {
    "doc": "Supported protocols and formats",
    "title": "Supported protocols and formats",
    "content": "This page lists all the systems, file formats, etc… that score is able to inter-operate with. ",
    "url": "https://ossia.io/score-docs/reference/protocols-and-formats.html",
    "relUrl": "/reference/protocols-and-formats.html"
  },"708": {
    "doc": "Pure Data integration",
    "title": "Pure Data support",
    "content": "ossia score supports running Pure Data patches as processes. Simply drop a patch in the score to add it. This is done thanks to libpd. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#pure-data-support",
    "relUrl": "/processes/puredata.html#pure-data-support"
  },"709": {
    "doc": "Pure Data integration",
    "title": "Example",
    "content": "The following Pure Data patch: . Will look like this when loaded in score: . This particular example can be downloaded in the user library. Feel free to contribute your own useful patches here ! . ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#example",
    "relUrl": "/processes/puredata.html#example"
  },"710": {
    "doc": "Pure Data integration",
    "title": "Limitations",
    "content": "For now do not use the “Parallel” execution mode when running Pd patches. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#limitations",
    "relUrl": "/processes/puredata.html#limitations"
  },"711": {
    "doc": "Pure Data integration",
    "title": "Usage",
    "content": "score will detect: . | Audio inlets/outlets: [adc~], [dac~] and create a corresponding audio input and output port. | Important ! You have to set in the inspector how many audio channels are needed, as they are multiplexed into a single port. | . | MIDI inlets/outlets: [midiin], [notein], [ctlin], [midiout], [noteout], [ctlout] and will create a MIDI input and / or output port. | Value inlets/outlets: [s] / [send], [r] / [receive]. | . It is possible (but still work-in-progress) to use the libossia ossia.parameter syntax for the receives, so that score is able to create nice GUI controls. Additionally, a widget attribute can be used, which will directly create the expected widget, among: . | intslider | floatslider | logfloatslider | intspinbox | toggle | button | lineedit | xyslider | hsvslider | . Valid cases would be (not all of them work yet): . [r myInput @type float @range -1 1] [r myInput @widget intslider @min 0 1000] [r myInput @type impulse] [r myInput @type bool @default true] [r myInput @unit color.hsv] . ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#usage",
    "relUrl": "/processes/puredata.html#usage"
  },"712": {
    "doc": "Pure Data integration",
    "title": "Editing the patch",
    "content": "If a Pure Data binary is detected on the host computer (by looking into their default installations folders and in the PATH), then it will be possible to open the patch directly from score. There is one caveat that may be fixed in a future version of the integration: one must not close the main Pd UI window by quitting it like other OS windows. Instead, the window should be closed by pressing the “window” button in the score node. ",
    "url": "https://ossia.io/score-docs/processes/puredata.html#editing-the-patch",
    "relUrl": "/processes/puredata.html#editing-the-patch"
  },"713": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/puredata.html",
    "relUrl": "/processes/puredata.html"
  },"714": {
    "doc": "Pure Data integration",
    "title": "Pure Data integration",
    "content": "This documentation has moved. ",
    "url": "https://ossia.io/score-docs/docs/advanced/puredata.html",
    "relUrl": "/docs/advanced/puredata.html"
  },"715": {
    "doc": "Quick start",
    "title": "Quick start",
    "content": "ossia score 3.7.1 . This is the ossia score quick start manual. The following pages will guide you through score interface and general workflow. They also cover some of the basic elements available to author advanced scenarios such as snapshots saving and recalling, automations, as well as using audio and video files. These will get you started with the various ways score can be used to author flexible and structured scenarios for live performances, art installations or other media-based works. Enjoy advanced scenario authoring for your intermedia creation ! . ",
    "url": "https://ossia.io/score-docs/quick-start",
    "relUrl": "/quick-start"
  },"716": {
    "doc": "Qwen LLM",
    "title": "Qwen LLM",
    "content": ". The Qwen LLM process enables local inference of Qwen language models for text generation, conversation, and creative applications within score. ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html",
    "relUrl": "/processes/qwen-llm.html"
  },"717": {
    "doc": "Qwen LLM",
    "title": "Overview",
    "content": "Qwen (通义千问) is a series of large language models that can be run locally for: . | Text generation and completion | Interactive conversations | Code generation | Creative writing | Real-time text processing in performances | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#overview",
    "relUrl": "/processes/qwen-llm.html#overview"
  },"718": {
    "doc": "Qwen LLM",
    "title": "Inputs",
    "content": "| Port | Type | Description | Default | Range | . | Prompt | String | Input text or question | - | - | . | Model | File Selector | Path to Qwen ONNX model | - | .onnx files | . | Tokenizer | File Selector | Path to Qwen tokenizer | - | .json files | . | Temperature | Float | Randomness control | - | - | . | Top P | Float | Nucleus sampling | 0.9 | 0.0-1.0 | . | Max Tokens | Integer | Maximum response length | - | - | . | Top K | Integer | Top-k sampling | 50 | 1-100 | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#inputs",
    "relUrl": "/processes/qwen-llm.html#inputs"
  },"719": {
    "doc": "Qwen LLM",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Response | String | Generated text | . | Tokens/second | Float | Number of tokens processed | . | Generation Info | Float | Generation statistics | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#outputs",
    "relUrl": "/processes/qwen-llm.html#outputs"
  },"720": {
    "doc": "Qwen LLM",
    "title": "Model Variants",
    "content": "There are multiple variants of Qwen, all with different tradeoffs. For instance, you can download the smallest, 0.6B, on HuggingFace. Qwen-1.8B . | Lightweight, fast inference | Suitable for real-time applications | Lower memory requirements | . Qwen-7B . | Better quality responses | More creative capabilities | Higher resource usage | . Qwen-14B . | Best quality | Advanced reasoning | Requires significant resources | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#model-variants",
    "relUrl": "/processes/qwen-llm.html#model-variants"
  },"721": {
    "doc": "Qwen LLM",
    "title": "Usage Examples",
    "content": "Interactive Text Generation . Create dynamic text based on sensor input: . [Sensor Data] → [Prompt Composer] → [Qwen LLM] → [Text Display] ↓ [Text to Speech] . Live Performance Assistant . Generate performance cues and text: . [MIDI Input] → [Note to Text] → [Qwen LLM] → [Projection] ↑ [Performance Context] . Automated Storytelling . Create evolving narratives: . [Scene Analysis] → [Qwen LLM] → [Story Text] ↑ ↓ [FastVLM] [Memory Buffer] . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#usage-examples",
    "relUrl": "/processes/qwen-llm.html#usage-examples"
  },"722": {
    "doc": "Qwen LLM",
    "title": "Prompt Engineering",
    "content": "System Messages . Set the model’s behavior and context: . | “You are a poetic narrator describing visual scenes” | “Generate short, rhythmic responses suitable for music” | “Respond only with stage directions” | . Effective Prompting . | Be specific about desired output format | Provide examples when possible | Use consistent formatting | Include relevant context | . Creative Applications . | Poetry generation from sensor data | Dynamic subtitles for performances | Interactive narrative experiences | Generative dialogue systems | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#prompt-engineering",
    "relUrl": "/processes/qwen-llm.html#prompt-engineering"
  },"723": {
    "doc": "Qwen LLM",
    "title": "Performance Optimization",
    "content": "Model Loading . | Load models at startup to avoid delays | Use quantized models for better performance | Consider model size vs. quality tradeoffs | . Streaming Mode . Enable streaming for: . | Real-time text display | Reduced latency perception | Progressive text revelation | . Caching . | Cache common responses | Implement context windowing | Reuse computation where possible | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#performance-optimization",
    "relUrl": "/processes/qwen-llm.html#performance-optimization"
  },"724": {
    "doc": "Qwen LLM",
    "title": "Integration Examples",
    "content": "Multi-Modal Performance . Combine with other AI processes: . [Camera] → [FastVLM] → [Scene Description] ↓ [Qwen LLM] ↓ [Poetic Interpretation] → [Display] . Code Generation . Generate live code for other processes: . [Musical Input] → [Analysis] → [Qwen LLM] → [JavaScript Code] ↓ [JS Process] . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#integration-examples",
    "relUrl": "/processes/qwen-llm.html#integration-examples"
  },"725": {
    "doc": "Qwen LLM",
    "title": "Best Practices",
    "content": ". | Model Selection : Choose model size based on quality/performance needs | Temperature Tuning : Lower for consistency, higher for creativity | Context Length : Balance context with performance | Error Handling : Implement fallbacks for failed generations | Resource Monitoring : Watch memory and CPU/GPU usage | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#best-practices",
    "relUrl": "/processes/qwen-llm.html#best-practices"
  },"726": {
    "doc": "Qwen LLM",
    "title": "Troubleshooting",
    "content": "Slow Generation . | Use smaller models | Reduce max token length | . Poor Quality Output . | Adjust temperature and sampling parameters | Improve prompt clarity | Provide better examples | Check model compatibility | . Memory Issues . | Use quantized models | Reduce batch size | Clear context regularly | Monitor system resources | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#troubleshooting",
    "relUrl": "/processes/qwen-llm.html#troubleshooting"
  },"727": {
    "doc": "Qwen LLM",
    "title": "Creative Use Cases",
    "content": "Performance . | Generate live subtitles | Create dynamic poetry | Produce stage directions | Generate character dialogue | . Installation . | Visitor interaction systems | Generative text displays | Responsive narratives | Educational experiences | . Experimentation . | Text-based compositions | Language exploration | Conceptual art generation | Hybrid human-AI creation | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#creative-use-cases",
    "relUrl": "/processes/qwen-llm.html#creative-use-cases"
  },"728": {
    "doc": "Qwen LLM",
    "title": "Related Processes",
    "content": ". | AI Prompt Composer - Build complex prompts | Text - Text display | JavaScript - Process generated code | . ",
    "url": "https://ossia.io/score-docs/processes/qwen-llm.html#related-processes",
    "relUrl": "/processes/qwen-llm.html#related-processes"
  },"729": {
    "doc": "Range filter",
    "title": "Range filter",
    "content": ". This object filters the incoming values that are outside of the input range. Example: if the input messages are: . 5 3.6 1457 -50000 3.7 NaN . then given a min of 2 and max of 4, the outputs will be . 3.6 3.7 . ",
    "url": "https://ossia.io/score-docs/processes/range-filter.html",
    "relUrl": "/processes/range-filter.html"
  },"730": {
    "doc": "Rate Limiter",
    "title": "Rate Limiter",
    "content": ". The rate limiter can be used to synchronise the input stream to a subdivision of the tempo. When “None” is selected in the quantification spin box, an incoming value will only be output every N miliseconds, as specified by the ms slider. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html",
    "relUrl": "/processes/rate-limiter.html"
  },"731": {
    "doc": "Rate Limiter",
    "title": "Quantification",
    "content": "Set the subdivision of the tempo to synchronise to. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html#quantification",
    "relUrl": "/processes/rate-limiter.html#quantification"
  },"732": {
    "doc": "Rate Limiter",
    "title": "ms.",
    "content": "You can change the value between 0 and 1000 milliseconds. ",
    "url": "https://ossia.io/score-docs/processes/rate-limiter.html#ms",
    "relUrl": "/processes/rate-limiter.html#ms"
  },"733": {
    "doc": "Raw I/O device",
    "title": "Configuring the operating system",
    "content": "Usually, on Linux, the raw devices aren’t accessible to a non-root user. It is necessary to perform the following steps: . # 1. If the gpio group doesn't exist, add it $ groupadd gpio # 2. Add your username to the group gpio $ usermod -a -G gpio $USER # 3. Create an udev rules file to automatically set # gpio devices to the gpio group if they aren't already. # To check that: # $ cd /dev; ls -l | grep gpio # # The second column will indicate the group of the /dev/gpiochip0...N files # which should be \"gpio\". # # Create the file: /etc/udev/rules.d/99-com.rules # With the following content: SUBSYSTEM==\"gpio\", GROUP=\"gpio\", MODE=\"0660\" # 4. Log-out and log-in again, gpio chips will now be available directly from ossia. ",
    "url": "https://ossia.io/score-docs/devices/rawio-device.html#configuring-the-operating-system",
    "relUrl": "/devices/rawio-device.html#configuring-the-operating-system"
  },"734": {
    "doc": "Raw I/O device",
    "title": "Raw I/O device",
    "content": ". The Raw I/O device allows to leverage the hardware features of an embedded Linux system directly: . | GPIOs | ADCs | DACs | PWMs | . and more to come! . This feature is only meaningful when running score on a Raspberry Pi or embedded board with accessible pin headers. As such, it is only available on Linux. Just like for the ArtNet devices, one adds the used GPIOs, ADCs, etc. : they will show up as accessible addresses. ",
    "url": "https://ossia.io/score-docs/devices/rawio-device.html",
    "relUrl": "/devices/rawio-device.html"
  },"735": {
    "doc": "Recording",
    "title": "Recording",
    "content": ". | Select addresses in the Device explorer. | Right-click in the score. | Select “Record automations from here”. | Press play: recording will start as soon as a message is received. This behaviour can be toggled in the Preferences. | . ",
    "url": "https://ossia.io/score-docs/in-depth/recording.html",
    "relUrl": "/in-depth/recording.html"
  },"736": {
    "doc": "Reference",
    "title": "\nscore reference manual",
    "content": "This section of the manual goes through the various sections of score and bring detailed explanations. ",
    "url": "https://ossia.io/score-docs/reference#score-reference-manual",
    "relUrl": "/reference#score-reference-manual"
  },"737": {
    "doc": "Reference",
    "title": "Reference",
    "content": " ",
    "url": "https://ossia.io/score-docs/reference",
    "relUrl": "/reference"
  },"738": {
    "doc": "Regressor",
    "title": "Regressor",
    "content": ". The Regressor process provides real-time machine learning regression capabilities using RapidLib algorithms. Unlike classification which predicts discrete classes, regression predicts continuous values - perfect for mapping complex sensor data to smooth control parameters. It is very close to the Classifier process: the difference is that Regressor interpolates while Classifier outputs the exact input value that was set during training. ",
    "url": "https://ossia.io/score-docs/processes/regressor.html",
    "relUrl": "/processes/regressor.html"
  },"739": {
    "doc": "Regressor",
    "title": "Overview",
    "content": "The Regressor enables: . | Multi-dimensional input to output mapping | Smooth interpolation between training points | Real-time continuous value prediction | Non-linear relationship learning | Adaptive parameter control | . Perfect for: . | Gesture-to-sound mapping | Environmental sensor control | Complex motion tracking | Adaptive audio/visual parameters | Smooth interactive responses | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#overview",
    "relUrl": "/processes/regressor.html#overview"
  },"740": {
    "doc": "Regressor",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Features | Float Array | Input feature vector | . | Record | Impulse | Record training example | . | Train | Impulse | Train the model | . | Reset | Impulse | Clear all training data | . | Target | Float inlets | Target values for recording | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#inputs",
    "relUrl": "/processes/regressor.html#inputs"
  },"741": {
    "doc": "Regressor",
    "title": "Outputs",
    "content": "| Port | Type | Description | . | Prediction | Float | Predicted output values | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#outputs",
    "relUrl": "/processes/regressor.html#outputs"
  },"742": {
    "doc": "Regressor",
    "title": "Usage Workflow",
    "content": "1. Define Mapping . Decide what you want to map: . | Inputs : Sensor values, analysis data, control positions | Outputs : Audio parameters, visual controls, device values | . 2. Data Collection . For each training point: . | Set inputs to desired state | Set Target to desired outputs | Trigger Record | Repeat across your mapping space | . 3. Training and Use . Training Phase: [Input State] → [Set Target] → [Record] → [Collect Examples] → [Train] Runtime Phase: [Live Input] → [Regressor] → [Smooth Output] → [Parameter Control] . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#usage-workflow",
    "relUrl": "/processes/regressor.html#usage-workflow"
  },"743": {
    "doc": "Regressor",
    "title": "Example Applications",
    "content": "Gesture-to-Sound Mapping . Map hand position to audio parameters: . [Hand Tracker] → [X, Y Position] → [Regressor] → [Volume, Pitch, Filter] ↓ [Audio Synthesis] . Training process: . | Move hand to top-left: Record [high volume, low pitch, open filter] | Move to bottom-right: Record [low volume, high pitch, closed filter] | Add more points to define the mapping space | Train the model for smooth interpolation | . Environmental Control . Map multiple sensors to lighting parameters: . [Temperature] → [Feature Vector] → [Regressor] → [Hue, Saturation, Brightness] [Humidity] → ↓ [Light Level] → [LED Controller] [Occupancy] → . Expressive Instrument . Create nuanced musical control: . [Pressure Sensors] → [Regressor] → [Synthesis Parameters] [Tilt Sensors] → ↓ [Proximity] → [Multi-dimensional Control] . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#example-applications",
    "relUrl": "/processes/regressor.html#example-applications"
  },"744": {
    "doc": "Regressor",
    "title": "Advanced Mapping Techniques",
    "content": "Multi-dimensional Spaces . Create complex mappings with multiple inputs and outputs: . Input Space: [x, y, pressure, tilt] Output Space: [volume, pitch, timbre, reverb, delay] . This creates a 4D → 5D mapping for rich expressive control. Temporal Features . Include time-based features: . [Current Values] → [Feature Vector] → [Regressor] → [Predicted Next Values] [Rate of Change] → [Acceleration] → [History Window] → . Hierarchical Mapping . Use multiple regressors for different aspects: . [Gesture Data] → [Regressor 1] → [Musical Structure] → [Regressor 2] → [Timbral Control] → [Regressor 3] → [Spatial Position] . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#advanced-mapping-techniques",
    "relUrl": "/processes/regressor.html#advanced-mapping-techniques"
  },"745": {
    "doc": "Regressor",
    "title": "Training Strategies",
    "content": "Sparse Training . Efficiently cover the input space: . | Corner Points : Train at extremes first | Grid Sampling : Regular samples across space | Important Regions : More points where behavior changes rapidly | Edge Cases : Handle boundary conditions | . Iterative Refinement . Improve the mapping over time: . | Initial Training : Basic mapping with key points | Test and Evaluate : Find areas needing improvement | Targeted Collection : Add examples where needed | Retrain : Update model with new data | . Quality Control . Ensure good training data: . | Consistency : Similar inputs should have similar outputs | Coverage : Sample across the full input range | Smoothness : Avoid sudden jumps in output values | Validation : Test with holdout data | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#training-strategies",
    "relUrl": "/processes/regressor.html#training-strategies"
  },"746": {
    "doc": "Regressor",
    "title": "Performance Optimization",
    "content": "Real-time Considerations . For live performance: . | Latency : Neural networks add minimal latency | Update Rate : Match prediction rate to control needs | Stability : Ensure smooth outputs during rapid input changes | . Data Management . Efficient training: . | Dataset Size : More data generally improves quality | Memory Usage : Large datasets consume more memory | Training Time : Neural networks take longer to train | Model Storage : Save trained models for reuse | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#performance-optimization",
    "relUrl": "/processes/regressor.html#performance-optimization"
  },"747": {
    "doc": "Regressor",
    "title": "Integration Examples",
    "content": "Interactive Art Installation . [Visitor Position] → [Regressor] → [Ambience Parameters] [Movement Speed] → ↓ [Group Size] → [Audio Layers] [Time of Day] → [Visual Intensity] [Color Temperature] . Adaptive Music System . [Audio Analysis] → [Regressor] → [Generative Parameters] [User Behavior] → ↓ [Context Data] → [Melody Complexity] [Harmonic Density] [Rhythmic Variation] . Responsive Architecture . [Environmental Sensors] → [Regressor] → [Building Response] [Occupancy Patterns] → ↓ [Energy Usage] → [Lighting Levels] [External Conditions] → [Ventilation Rate] [Space Configuration] . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#integration-examples",
    "relUrl": "/processes/regressor.html#integration-examples"
  },"748": {
    "doc": "Regressor",
    "title": "Best Practices",
    "content": "Data Collection . | Plan Your Space : Map out input/output relationships beforehand | Systematic Sampling : Use structured approaches to cover space | Test As You Go : Validate mappings during collection | Document Examples : Keep notes on training points | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#best-practices",
    "relUrl": "/processes/regressor.html#best-practices"
  },"749": {
    "doc": "Regressor",
    "title": "Related Processes",
    "content": ". | Classifier - For discrete category prediction | Interpolator - Simple linear interpolation | Mapping - Basic parameter mapping | Analysis - Feature extraction | . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#related-processes",
    "relUrl": "/processes/regressor.html#related-processes"
  },"750": {
    "doc": "Regressor",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/regressor.html#try-it",
    "relUrl": "/processes/regressor.html#try-it"
  },"751": {
    "doc": "Remote Control",
    "title": "Remote Control",
    "content": "The two main ways to remote control score from the network are: . | Through OSC and OSCQuery with the Local device. | Through a WebSocket API. The WebSocket API has been used to build a nice graphical remote application. | . This page describes the low-level WebSocket API used by score, so that anyone can build their custom remotes similar to the one mentioned above.. ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html",
    "relUrl": "/in-depth/remote.html"
  },"752": {
    "doc": "Remote Control",
    "title": "Description",
    "content": "Exposes some properties of the score over WebSockets: . | Transport. | Viewing and controlling triggers. | Sending &amp; receiving messages through the Device Explorer. | Executing JS code in the console. | . ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html#description",
    "relUrl": "/in-depth/remote.html#description"
  },"753": {
    "doc": "Remote Control",
    "title": "WebSocket API description",
    "content": "The message format is JSON. Score -&gt; client . { \"Message\": \"DeviceTree\" } . When a trigger starts executing: . { \"Message\": \"TriggerAdded\", \"Path\": \"/path/to/the/trigger\" } . When a trigger has finished executing: . { \"Message\": \"TriggerRemoved\", \"Path\": \"/path/to/the/trigger\" } . When an interval starts executing: . { \"Message\": \"IntervalAdded\", \"Path\": \"/path/to/the/interval\", \"Name\": \"machine_readable.name\", \"Label\": \"User-readable label\", \"Comment\": \"User-readable comment\", \"Speed\": 1.2345 } . When an interval has finished executing: . { \"Message\": \"IntervalRemoved\", \"Path\": \"/path/to/the/interval\" } . Heartbeat sent every few milliseconds: . { \"Intervals\": [ { \"Path\": \"/path/to/the/interval\", \"Progress\": 0.5, \"Speed\": 1., \"Gain\": 0.8 }, ... ] } . Client -&gt; score . Transport messages: . { \"Message\": \"Play\" } { \"Message\": \"Pause\" } { \"Message\": \"Stop\" } { \"Message\": \"Transport\", \"Milliseconds\": 40000 } . Console control: . See the Console API for the allowed operations. { \"Message\": \"Console\", \"Code\": \"someJSCodeToExecute()\" } . To trigger a trigger: . { \"Message\": \"Trigger\", \"Path\": \"/path/to/the/trigger\" } . To slow down or speed up an interval: . { \"Message\": \"IntervalSpeed\", \"Path\": \"/path/to/the/interval\", \"Speed\": 0.5 } . To change the gain of an interval: . { \"Message\": \"IntervalGain\", \"Path\": \"/path/to/the/interval\", \"Gain\": 0.5 } . To send a control message: . { \"Message\": \"Message\", \"Address\": \"device:/foo/bar@[color.rgb.r]\", \"Value\": { \"Float\": 1.23 } } . or, to showcase all possible types: . { \"Message\": \"Message\", \"Address\": \"device:/foo/bar\", \"Value\": { \"Tuple\": [ { \"Int\": 1 }, { \"Bool\": true }, { \"Char\": c }, { \"Vec2f\": [0.0, 1.1] }, { \"Vec3f\": [0.0, 1.1, 1.2] }, { \"Vec4f\": [0.0, 1.1, 1.3, 1.4] }, { \"Float\": 1.23 }, { \"String\": \"foo\" }, { \"Impulse\": null }, ] } } . To enable / disable listening . Listening to an address means that when an address’s value changes, the new value is forwarded to the remote client. { \"Message\": \"EnableListening\", \"Address\": \"device:/foo/bar\" } . and . { \"Message\": \"DisableListening\", \"Address\": \"device:/foo/bar\" } . Control surface . See Control surface. ",
    "url": "https://ossia.io/score-docs/in-depth/remote.html#websocket-api-description",
    "relUrl": "/in-depth/remote.html#websocket-api-description"
  },"754": {
    "doc": "Saving & recalling devices' state",
    "title": "Saving and recailling your device’s state",
    "content": "ossia score provides a number of tools to author precise control of the various devices involved in your project. Here we will focus on two basic elements: . | saving some devices’ state (aka making snapshots) to be recalled during the execution of your scenario | writing automations for some parameters | . These illustrate a small part of the possibilities detailed later in the manual, but should get you started with score basic workflow. ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html#saving-and-recailling-your-devices-state",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html#saving-and-recailling-your-devices-state"
  },"755": {
    "doc": "Saving & recalling devices' state",
    "title": "Storing your current device state",
    "content": "Saving your device current state on the timeline is as easy as dragging parameters you want to save from the Device explorer to where you will want them to be recalled in the timeline. You can store at one place all parameters of a device or only part of, as well as parameters from different devices. Note that when selecting a node in the namespace, all parameters below get selected. You may also select a single or many parameters using standard key combinations: . | Shift+click: Select all parameters between clicked parameter and previously selected one | Ctrl+click(Win / Linux) or⌘+click(Mac): Add selected parameter to the current selection | . In the illustration below, we will select just the gain parameters from our ossia compatible Max synth patch and store their current value at the 5th bar of our scenario. As you drop these gain parameters on the timeline, you can see a blue disc circled in white gets created. Clicking this state icon, you can see in the inspector panel both parameters and their value listed as a tree-like view. If you start playing your scenario using the play button from the transport (space key), this state will get recalled and sent to your device as the play-head crosses its position on the timeline. Should you need this state to be recalled earlier or later, just stop execution of the scenario (using stop button from the transport bar or ↵ key), then select and drag it along the timeline. If your device does not echo back its parameters changes to score, you can still grab the parameters to store from the Device explorer and drop them on the Timeline. Then from the state inspector panel, type the desired value next to each parameter. You may as well type the desired values in the Device explorer first, then drag &amp; drop the parameters on the timeline. You may now make some changes to your device, then store this new state using the same drag &amp; drop workflow. Note that when storing our device’s second state in the timeline, score proposes to bind this snapshot to different elements in the timeline, as displayed with a dashed gray line. For now, we will just make sure this snapshot is bound to the first one we placed on the timeline. But be sure to check dedicated section in the manual to see the features score provides to help you structure elements in your scenario. You can now start sequencing your devices’ states in your scenario or read detailed information about managing states and automations. ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html#storing-your-current-device-state",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html#storing-your-current-device-state"
  },"756": {
    "doc": "Saving & recalling devices' state",
    "title": "Saving & recalling devices' state",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/saving-and-recalling-devices-state.html",
    "relUrl": "/quick-start/saving-and-recalling-devices-state.html"
  },"757": {
    "doc": "Scenario",
    "title": "Scenario",
    "content": "The main view in score. The Scenario process allows to put a score inside another score, and to nest at an arbitrarily depth: think of it as the traditional DAW groups, on steroids. Execution . | Putting stuff on the top start state for it to run with Reinitialize | Putting stuff on the top end state for it to run when stop is pressed. | . Keyboard shortcuts . | In a scenario with the navigation keys ( ↑, ↓, →, ←). | To the parent scenario with Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac). | Unroll all intervals’ racks in a scenario Ctrl+Alt+U(Win / Linux) or⌘+Alt+U(Mac) | Fold all intervals’ racks in a scenario Ctrl+Alt+F(Win / Linux) or⌘+Alt+F(Mac) | . Speed control . Speed sliders appear on intervals while playing. To reset it: Ctrl+Right Click(Win / Linux) or⌘+Right Click(Mac) . List of drag’n’drops possible . On intervals . | Drop from the device explorer to an interval: create an automatoin curve. | Drop from the library explorer to an interval: create a process. | Drop a media from the library or the system to an interval: create a process. | Drop from the object list into a slot or in the interval | . Moving processes around . | Drag the little ☰ icon somewhere else in the timeline. | In the same interval: reorders | In another interval: moves the process | In a blank space: creates a new interval from there and moves the process | . | . On processes . | Generally, dropping a media on a process changes the content of the process. | dropping a new sound file on a sound process | dropping a new address from the explorer on an automation | etc… | file bugs if you see a case not implemented ! | . | . On states . | Message list: add messages to the state | .cues files (created by dropping a state into the library) | .layer files | . From states . | It is possible to select messages in a state and drop them either in the scenario, or on another state | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html",
    "relUrl": "/processes/scenario.html"
  },"758": {
    "doc": "Scenario",
    "title": "Intervals",
    "content": "Execution controls: intervals can be started, stopped, and muted. Interpolate states . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#intervals",
    "relUrl": "/processes/scenario.html#intervals"
  },"759": {
    "doc": "Scenario",
    "title": "Graph links",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#graph-links",
    "relUrl": "/processes/scenario.html#graph-links"
  },"760": {
    "doc": "Scenario",
    "title": "Conditions",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#conditions",
    "relUrl": "/processes/scenario.html#conditions"
  },"761": {
    "doc": "Scenario",
    "title": "Keyboard shortcuts",
    "content": "Pressing suppr / backspace when a condition is selected removes it. ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#keyboard-shortcuts-1",
    "relUrl": "/processes/scenario.html#keyboard-shortcuts-1"
  },"762": {
    "doc": "Scenario",
    "title": "Triggers",
    "content": ". | It is possible to choose the desired behaviour for off-time triggers : either triggering them stops and restarts the subgraph immediately, or it stops the subgraph and will only restart it after a new triggering. This choice is done in the trigger inspector. | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#triggers",
    "relUrl": "/processes/scenario.html#triggers"
  },"763": {
    "doc": "Scenario",
    "title": "Keyboard shortcuts",
    "content": "Pressing suppr / backspace when a trigger is selected removes it. ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#keyboard-shortcuts-2",
    "relUrl": "/processes/scenario.html#keyboard-shortcuts-2"
  },"764": {
    "doc": "Scenario",
    "title": "Sequences",
    "content": ". | Auto-sequence settings | . ",
    "url": "https://ossia.io/score-docs/processes/scenario.html#sequences",
    "relUrl": "/processes/scenario.html#sequences"
  },"765": {
    "doc": "Scripting API",
    "title": "Utility functions",
    "content": "// Reads the entire content of a file let data = Util.readFile(\"/path/to/file.txt\"); // Layouts a text so that it fits a rect of a given width by // adding line breaks. Naive algorithm. // Arguments are: // - text to lay out // - font to use // - font size // - maximum width in pixels let text = Util.layoutTextLines(\"some long text\", \"Monospace\", 24, 100); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#utility-functions",
    "relUrl": "/in-depth/scripting-api.html#utility-functions"
  },"766": {
    "doc": "Scripting API",
    "title": "Undo-redo and general helpers",
    "content": "// Find an object by name let obj = Score.find(\"Interval.foobar\"); // Get a reference to the object first selected in the score let obj = Score.selectedObject(); // Get a reference to all the objects currently selected in the score let objs = Score.selectedObjects(); // Get a reference to the current root document object let doc = Score.document(); // Undo-redo: Score.undo(); Score.redo(); // Undo-redo macros: // this is so that commands that do multiple // changes to the score, e.g. by adding multiple processes, // only show up as one single action in the undo-redo panel. // Every action that changes the score must be between these two calls. Score.startMacro(); Score.endMacro(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#undo-redo-and-general-helpers",
    "relUrl": "/in-depth/scripting-api.html#undo-redo-and-general-helpers"
  },"767": {
    "doc": "Scripting API",
    "title": "UI",
    "content": "// This function allows to show a prompt to the user. // The object passed in argument allows to configure the UI to show. // They will be shown as a UI form. // The return value will be the list of values that the user has set on every widget if the prompt was accepted, and 'undefined' otherwise. const res = Score.prompt({ title: \"Input JSON\", widgets: [ { name:\"Name\", type: \"lineedit\", init: \"Hello\" }, { name:\"JSON\", type: \"textfield\" }, { name:\"Foo\", type: \"spinbox\", min: 0, max: 100, init: 10 }, { name:\"Bar\", type: \"slider\", min: 0.5, max: 10.2, init: 1.0 }, { name:\"Baz\", type: \"checkbox\", init: false } ] }); // Res could look like: // [\"text\", \"long text\", 30, 4.6, true] . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#ui",
    "relUrl": "/in-depth/scripting-api.html#ui"
  },"768": {
    "doc": "Scripting API",
    "title": "Transport",
    "content": "// Plays the score Score.play(); // Plays a specific object let an_interval = Score.find(\"my_interval\"); Score.play(an_interval); // Stops playback Score.stop(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#transport",
    "relUrl": "/in-depth/scripting-api.html#transport"
  },"769": {
    "doc": "Scripting API",
    "title": "Functions operating on devices",
    "content": "// Converts a device tree to JSON. // Useful for e.g. preset snapshotting, sending over the internet... let json = Score.deviceToJson(\"deviceName\"); // Create a WebSocket device from QML code. // See the QML code examples in the library. Score.createQMLWebSocketDevice(\"name\", \"QML Code\"); // Create a Serial device from QML code. // See the QML code examples in the library. Score.createQMLSerialDevice(\"name\", \"/dev/ttyUSB1\", \"QML Code\"); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-devices",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-devices"
  },"770": {
    "doc": "Scripting API",
    "title": "Functions operating on the score",
    "content": "// Create a new process in an interval. // The process names are those in the library. // Third argument is reserved for future use. let new_process = Score.createProcess(an_interval, \"Automation (float)\", null); // Change the name of an object Score.setName(an_interval, \"Foo\"); // Create a new free-floating interval // Arguments: // - parent scenario // - At which time the interval is created (e.g. \"00:01:15.345\" for 1 minute 15 seconds 345 millis) // - How long it lasts (same format) // - Which vertical position (between [0;1] (top;bottom)) let new_itv = Score.createBox(scenar, \"00:00:10.000\", \"00:01:15.000\", 0.2); // Create a new interval after a state let new_itv = Score.createIntervalAfter(state, duration, y); // Get a port by name given a process let port = Score.port(my_lfo, \"Frequency\"); // Get an inlet / outlet by index given a process. // Here \"port1\" would be the \"Offset\" port of a LFO process let port1 = Score.inlet(my_lfo, 2); // Here \"port2\" would be the \"Outlet\" port of a LFO process let port2 = Score.outlet(my_lfo, 0); // Returns how many inlets / outlets there are in a given process let count = Score.inlets(my_lfo); let count = Score.outlets(my_lfo); // Set the address of a port Score.setAddress(port1, \"midi:/1/control/34\"); // Set the value of a port (only relevant for ports with UI controls) Score.setValue(port1, 0.34); Score.setValue(portA, \"foo\"); Score.setValue(portB, true); // etc... // Get the type of a port as a string. Float, Int, String, etc. let type = Score.valueType(port1); // Get the min/max range of a port if it has one let min = Score.min(port1); let max = Score.max(port1); // Get the list of values if the port is an enum / combo box / chooser ... let vals = Score.enumValues(port1); // Access the metadata object of an object. Allows to see the label, comments, etc let meta = Score.metadata(scenario); console.log(meta.name, meta.label, meta.comment) // Access the start / end elements of an interval let st = Score.startState(itv); let st = Score.endState(itv); let ev = Score.startEvent(itv); let ev = Score.endEvent(itv); let ts = Score.startSync(itv); let ts = Score.endSync(itv); // Remove an object from the score Score.remove(itv); // Create an automation on the given interval from an address Score.automate(itv, \"foo:/bar\"); // Create an automation on the given interval from a port object Score.automate(itv, port1); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-the-score",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-the-score"
  },"771": {
    "doc": "Scripting API",
    "title": "Functions operating on curves",
    "content": "// Set a curve from a list of points: // [ [ x1, y1 ], [ x2, y2 ], ... ] let points = [ [0, 0.5], [0.2, 1.], [0.5, 0.9], [1.0, 0.0], ]; Score.setCurvePoints(an_automation_process, points); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-curves",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-curves"
  },"772": {
    "doc": "Scripting API",
    "title": "Functions operating on step sequencer",
    "content": "// Sets the step on a Step Sequencer Score.setSteps(a_step_sequencer_process, [0.1, 0, 1., 0.4, 0.5]); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html#functions-operating-on-step-sequencer",
    "relUrl": "/in-depth/scripting-api.html#functions-operating-on-step-sequencer"
  },"773": {
    "doc": "Scripting API",
    "title": "Scripting API",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/scripting-api.html",
    "relUrl": "/in-depth/scripting-api.html"
  },"774": {
    "doc": "Scripting",
    "title": "Scripting",
    "content": "The software can be scripted with Javascript (ES7). The available functions are defined by the following C++ class: EditJsContext. Click here for the complete reference. These functions will be available under the global Score object in the JS contexts. Additional utility functions are available under the Util object. let data = Util.readFile(\"/Users/me/foo.txt\"); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html",
    "relUrl": "/in-depth/scripting.html"
  },"775": {
    "doc": "Scripting",
    "title": "Putting scripts in the User Library",
    "content": "Scripts ending in .js in the user library can be double-clicked: they will be run in the global application context. A script can introduce a function which can then be leveraged by the Javascript processes. ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#putting-scripts-in-the-user-library",
    "relUrl": "/in-depth/scripting.html#putting-scripts-in-the-user-library"
  },"776": {
    "doc": "Scripting",
    "title": "Scripting in the console panel",
    "content": "The Console (shortcut: Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac)) allows to quickly test scripts in a REPL fashion. It is also useful as a simple calculator :-) . For instance, here is how a small console session may look: . // Gets the first selected object. &gt; var obj = Score.selectedObject(); // Print it to check what we got. &gt; obj; Scenario::IntervalModel(0x555556411330, \"Scenario::IntervalModel\") // Play it. &gt; Score.play(obj); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#scripting-in-the-console-panel",
    "relUrl": "/in-depth/scripting.html#scripting-in-the-console-panel"
  },"777": {
    "doc": "Scripting",
    "title": "Making scripts available as GUI actions",
    "content": "It is possible to put scripts in the “Scripts” menu at the top of the software. Scripts must be valid Javascript modules, and be present somewhere in the system library. Here is an example, which should go in for instance Documents/ossia/score/packages/user/my_scripts/Hello.mjs. It will add an “Example &gt; Hello” sub-menu in the “Scripts” menu. The script will also be triggable at any point with the Alt+A, Alt+H keyboard shortcut. A single script module can register multiple actions in one go. // This will be called whenever the action is triggered in the menu. function your_custom_function() { console.log(\"Triggered\"); } export function initialize() { // This will be called when the module is loaded on startup. console.log(\"Hello world !\") } // This is used to register actions in the Scripts menu in score export const actions = [ { name: \"Example/Hello\" , context: ActionContext.Menu , shortcut: \"Alt+A, Alt+H\" , action: your_custom_function } ] . A video example is available here ; here is an example of script that randomizes a process’s controls. ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#making-scripts-available-as-gui-actions",
    "relUrl": "/in-depth/scripting.html#making-scripts-available-as-gui-actions"
  },"778": {
    "doc": "Scripting",
    "title": "Examples",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#examples",
    "relUrl": "/in-depth/scripting.html#examples"
  },"779": {
    "doc": "Scripting",
    "title": "Simple example",
    "content": "// Creates an OSC device named foo. Messages will be sent from score to 127.0.0.1:5678. // Score will listen to messages on port 1234. Score.createOSCDevice(\"foo\", \"127.0.0.1\", 5678, 1234); // Creates an OSC address on the device foo, named /bar/baz. It will receive color.rgba types. // All the usual ossia unit names are accessible, // as well as useful names such as the ones found in [addresses](addresses doc) Score.createAddress(\"foo:/bar/baz\", \"color.rgba\"); // Finds an object in the current score. // The name is the object name, put in the inspector var myObject = Score.find(\"the object name\"); // Creates an automation. The first argument must be a valid pointer to an interval // found by Score.find(...). Score.automate(myInterval, \"foo:/my/address\"); // Undo-redo Score.undo(); Score.redo(); // Transport Score.play(); Score.stop(); . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#simple-example",
    "relUrl": "/in-depth/scripting.html#simple-example"
  },"780": {
    "doc": "Scripting",
    "title": "Advanced example 1",
    "content": "This example shows how to generate a sequence of randomized processes: automations, step sequencer, LFO which will control an address starting from a state. It declares a function that can then be called like this: . gengis_gen(\"my_state\", \"foo:/bar\") . // This function randomizes all the parameters of an LFO process // (or any process with inlets) function randomizeLFO(lfo) { // First count the number of inlets const N = Score.inlets(lfo); // For each inlet: for (let i = 0; i &lt; N; ++i) { // Get it const inl = Score.inlet(lfo, i); // Get what its type is (\"Float\", \"Int\", \"String\", etc) const val_type = Score.valueType(inl); if (val_type === \"Float\" || val_type === \"Int\") { // In that case check the range of the control const min = Score.min(inl); const max = Score.max(inl); // Generate a value in that range const val = min + Math.random() * (max - min); // Apply it to the control Score.setValue(inl, val); } else if (val_type === \"String\") { // If the input is a string it's likely an enumeration const values = Score.enumValues(inl); // [\"Sin\", \"Square\", ...] // Pick an enum value at random const val = Math.round(Math.random() * (N - 1)); const N = values.length; // Apply it Score.setValue(inl, values[val]); } } } // This function creates a random automation. // Automations are defined like this: // [ // [0, 0.2], // [0.5, 0.7], // [1., 0.4] // ] // will make a curve that starts at 0.2, goes up to 0.7 at the half of the curve, // and reaches 0.4 at the end. // The y values should be between 0 and 1, // the x values can go beyond 1 (to write past the default length of the automation). function randomizeAutomation(autom) { let arr = []; for (let i = 0; i &lt;= 10; i++) { let x = i / 10; let y = Math.random(); arr.push([x, y]); } Score.setCurvePoints(autom, arr); } // This function creates a random series of steps for the step sequencer. function randomizeStep(step) { let arr = []; for (let i = 0; i &lt;= 10; i++) { arr.push(Math.random()); } Score.setSteps(step, arr); } // Takes the name of a state and an address to set to each process's output. function gengis_gen(startState, address) { // Look for our state object. let ss = Score.find(startState); if (ss === null) { console.log(`${startState} not found`); return; } // We'll create 16 processes. const num = 16; const y = ss.heightPercentage; var cur_state = ss; // Start recording undo / redo commands. Score.startMacro(); for (let i = 0; i &lt; num; i++) { const seconds = Math.floor(Math.random() * 10); const duration = `00:00:0${seconds}`; // Create an interval after the state let new_itv = Score.createIntervalAfter(cur_state, duration, 0.1); // Create processes by name. var p; switch (Math.floor(Math.random() * 3) % 3) { case 0: { p = Score.createProcess(new_itv, \"LFO\", \"\"); randomizeLFO(p); break; } case 1: { p = Score.createProcess(new_itv, \"Automation (float)\", \"\"); randomizeAutomation(p); break; } case 2: { p = Score.createProcess(new_itv, \"Step sequencer\", \"\"); randomizeStep(p); break; } } if (p) { // Get the outlet of the process. let main_outlet = Score.outlet(p, 0); // Set its address. Score.setAddress(main_outlet, address); } // The next interval will start from the end state of the current interval. cur_state = Score.endState(new_itv); } // Apply the macro so that it can be un-done in one step. Score.endMacro(); } . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#advanced-example-1",
    "relUrl": "/in-depth/scripting.html#advanced-example-1"
  },"781": {
    "doc": "Scripting",
    "title": "Advanced example 2",
    "content": "This example creates images process, plays them and remove them. The function bullet can be added to a Javascript process. For instance, this will create a Javascript process that makes an image sub-scenario be created randomly, every time it gets an input value: . import Score 1.0 Script { ValueInlet { id: in1 } tick: (token, state) =&gt; { if (typeof in1.value !== 'undefined') { Device.exec(\"bullet(Score.find('Scenario.1'))\") } } } . function bullet(scenario) { if(scenario === null) return; Score.startMacro(); // Create a new box const start_seconds = Math.floor(Math.random() * 10); const start_duration = `00:00:0${start_seconds}`; const len_seconds = Math.floor(1 + Math.random() * 2); const len_duration = `00:00:0${len_seconds}`; let itv = Score.createBox(scenario, start_duration, len_duration, Math.random() * 0.4 + 0.2); // Add an image process within { let img = Score.createProcess(itv, \"Images\", \"\"); // Set the bullet image let files = Score.port(img, \"Images\"); Score.setValue(files, [\"/home/jcelerier/genuary/bullet.png\"]); // Set the output address let outlet = Score.outlet(img, 0); Score.setAddress(outlet, \"window:/\"); // Set a random position let pos = Score.port(img, \"Position\"); Score.setValue(pos, [4*(Math.random()-0.5), 4*(Math.random()-0.5)]); // Set a random scale let scaleX = Score.port(img, \"Scale X\"); let scaleY = Score.port(img, \"Scale Y\"); let sc = 0.5 + Math.random() * 0.3; Score.setValue(scaleX, sc); Score.setValue(scaleY, sc); // Add an automation on the opacity { let opacity = Score.port(img, \"Opacity\"); let autom = Score.automate(itv, opacity); Score.setCurvePoints(autom, [ [0., 1.], [1., 0.] ]); } } // In the end state, add a small script, which will destroy that box { let end = Score.endState(itv); const script = `import Score 1.0 Script { start: () =&gt; Device.exec(\"Score.remove(Score.find('${Score.metadata(itv).name}'))\"); } ` Score.createProcess(end, \"Javascript\", script); } // Save as an undo-redo command Score.endMacro(); // Play it Score.play(itv); } . ",
    "url": "https://ossia.io/score-docs/in-depth/scripting.html#advanced-example-2",
    "relUrl": "/in-depth/scripting.html#advanced-example-2"
  },"782": {
    "doc": "Serial device",
    "title": "Serial device",
    "content": ". This protocol allows to communicate through custom serial port protocols defined in QML. Multiple examples are available in the user library. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html",
    "relUrl": "/devices/serial-device.html"
  },"783": {
    "doc": "Serial device",
    "title": "QML API",
    "content": "Assuming a serial device which, whenever bytes are written to it, sends back a sensor reading with the following textual protocol: . 10\\r\\n12\\r\\n17\\r\\n5\\r\\n... To fetch the sensor value, a get message must be written by the computer to the serial port ; a complete communication session, in a serial console could for instance look like this: . get 10 get 12 get 17 . A basic QML script for processing that serial device and making the sensor value available to score under a /sensor address in the device explorer would look like this: . import Ossia 1.0 as Ossia Ossia.Serial { function onMessage(message) { return [ { address: \"/sensor\", value: parseInt(message) } ]; } function createTree() { return [ { name: \"request\", type: Ossia.Type.Pulse, access: Ossia.Access.Set, request: \"get\" }, { name: \"sensor\", type: Ossia.Type.Int, access: Ossia.Access.Get, min: 0, max: 255, bounding: Ossia.Bounding.Clip, repetition_filter: Ossia.Repetitions.Filtered } ]; } } . Here is the complete syntax available for reading messages: the most important thing to note is that: . | onMessage is to be used to process messages in text-based protocols. | onBinary is to be used to process messages in binary protocols. | onRead is to be used to process the raw byte stream. | property string delimiter: \"\\n\\n\" and property string framing: \"&lt;FRAMING&gt;\" can be used to configure the framing of messages. | . Supported framing protocols are: . | “none” | “slip” | “osc-slip” | “size” | “delimiter” (the default, set as “\\r\\n”) | . import Ossia 1.0 as Ossia Ossia.Serial { /// Message-based processing /// // Option A: this function is called whenever a \\r\\n-delineated message is read. // \"message\" will be a string, thus this function is what you need to use for text-based protocols. function onMessage(message) { // Will log in score's message window console.log(message); // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 123 } ]; } // Option B: this function is called whenever a message is read. // \"message\" will be an ArrayBuffer containing the raw bytes. function onBinary(message) { // Will log in score's message window console.log(message); // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 456 } ]; } // The delineation can be overriden with: property string delimiter: \"\\n\\n\" // It's possible to use other framing methods for message-based processing. // The following are supported: // SLIP encoding: property string framing: \"slip\" // Size-prefix encoding. // Each message starts with a big-endian int32 which is the size of the next message. property string framing: \"size\" // Delimiter (the default) property string framing: \"delimiter\" // No framing at all. It's up to the user to reconstitute messages, in the \"onRead\" method (see below). property string framing: \"none\" /// Raw processing /// // Option C: // If doing the following, the serial processing code will not attempt to frame // incoming and outgoing data as messages. The function is called with whatever bytes are available // and it is up to the user to reassemble them with the custom protocol being used. // \"bytes\" will be an ArrayBuffer containing the raw bytes. function onRead(bytes) { // Will set the value 123 to the address my_device:/sensor return [ { address: \"/sensor\", value: 789 } ]; } /// Creation of the tree /// // This function defines the shape of this device tree. // Note that it is static and defined at creation. function createTree() { return [ // This creates a node \"my_device:/request\" of type \"impulse\" { name: \"request\", type: Ossia.Type.Pulse, access: Ossia.Access.Set, /// request: can be used to customize the serial communication. // Option A: the string \"$val\" will be replaced textually by the value of the message sent by score request: \"message sent whenever a message is sent to this address in score\" // Option B: the given function will be called, which will return a string which behaves the same request: () =&gt; { return Math.random() + \" foo \" } // Option C: same thing with an argument: // it will be an object { value: /* current value */, type: /* type of the value */ } request: (val) =&gt; { return val.value + \" foo \" } }, // This creates a node \"my_device:/sensor\" of type \"int\" { name: \"sensor\", type: Ossia.Type.Int, access: Ossia.Access.Get, min: 0, max: 255, bounding: Ossia.Bounding.Clip, repetition_filter: Ossia.Repetitions.Filtered // Here without \"request:\" specified, the int value of the address will be textually written to the serial port } ]; } // These functions are called when score needs to actively listen on changes on some addresses function openListening(address) { } function closeListening(address) { } } . ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#qml-api",
    "relUrl": "/devices/serial-device.html#qml-api"
  },"784": {
    "doc": "Serial device",
    "title": "Writing binary data",
    "content": "By default, the values returned from request in the device tree are treated as strings and will be written to the serial port in textual, ASCII format. For instance, an “int” parameter with value 1234 will cause the actual integer to be written textually in the serial port: 123 as the bytes 0x31 0x32 0x33, and not the single-byte value for 123, 0x7B. If one wants actual binary data to be written, it is necessary to use a Javascript Typed Array, such as Uint8Array. Note that in this case the framing also must be handled manually, to enable for more control. Here is an example which will write a single byte delimited by \\r\\n. { name: \"request\", type: Ossia.Type.Int, access: Ossia.Access.Set, min: 0, max: 127, request: (val) =&gt; { let auint8 = new ArrayBuffer(3); let uint8 = new Uint8Array(auint8); uint8[0] = val.value; // An integer between 0 and 127 uint8[1] = '\\r'; uint8[2] = '\\n'; return auint8; } } . ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#writing-binary-data",
    "relUrl": "/devices/serial-device.html#writing-binary-data"
  },"785": {
    "doc": "Serial device",
    "title": "OSC support",
    "content": "If the target device reads OSC natively on its serial port, it is possible to implement support for it quite easily: . import Ossia 1.0 as Ossia Ossia.Serial { function createTree() { return [ { name: \"foo\", type: Ossia.Type.Int, access: Ossia.Access.Set, osc_address: \"/foo\" }, { name: \"foo_but_as_list\", type: Ossia.Type.List, access: Ossia.Access.Set, osc_address: \"/foo\" } ]; } } . In the above case, sending messages to foo and foo_but_as_list will both be translated directly as OSC messages, for instance /foo 1 or /foo 10 \"blah\" True. If setting extended_type to for instance u8Blob then a list would be translated in a blob containing a sequence of u8 values. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#osc-support",
    "relUrl": "/devices/serial-device.html#osc-support"
  },"786": {
    "doc": "Serial device",
    "title": "Coalescing messages",
    "content": "In case the serial port is too slow and overflows, one can add the property: . property real coalesce: 15 . to the Serial object, to coalesce messages every 15 milliseconds for instance. If a specific parameter must not be coalesced, but always sent, one can simply set critical: true on the node. One will generally want to use coalescing on parameters such as lights, drives, or anything that more-or-less maps to an electrical voltage, and not for parameters that would trigger the start of an action. In case messages use the OSC feature, then non-critical messages will get coalesced as a single bundle. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#coalescing-messages",
    "relUrl": "/devices/serial-device.html#coalescing-messages"
  },"787": {
    "doc": "Serial device",
    "title": "Examples",
    "content": "Arduino’s built-in examples proposes two similar sketches for serial communication: SerialCallResponse and SerialCallResponseASCII. You can find their companion QML scripts in the user library, illustrating the use of the onRead and onMessage functions respectively. ",
    "url": "https://ossia.io/score-docs/devices/serial-device.html#examples",
    "relUrl": "/devices/serial-device.html#examples"
  },"788": {
    "doc": "Sh4lt devices",
    "title": "Sh4lt",
    "content": "Sh4lt, the successor of the Shmdata protocol originally developed at the SAT Metalab, is a Unix-oriented protocol for sharing memory between applications easily. It is mainly used to share video frames. Thanks to it, score can easily send and receive video data from and to GStreamer for instance. ",
    "url": "https://ossia.io/score-docs/devices/sh4lt-device.html#sh4lt",
    "relUrl": "/devices/sh4lt-device.html#sh4lt"
  },"789": {
    "doc": "Sh4lt devices",
    "title": "Compiling and installing Sh4lt",
    "content": "Refer to the latest instructions on the Sh4lt Readme. Score comes built-in with Sh4lt support on Linux and macOS (Windows does not support the necessary Unix primitives). Test that it works correctly with the gst-launch commands given in that Readme. ",
    "url": "https://ossia.io/score-docs/devices/sh4lt-device.html#compiling-and-installing-sh4lt",
    "relUrl": "/devices/sh4lt-device.html#compiling-and-installing-sh4lt"
  },"790": {
    "doc": "Sh4lt devices",
    "title": "Using Sh4lt in score",
    "content": "Sh4lt can currently be used as a video input and output device. Simply create the devices you need, and set your video input / output to the Sh4lt device’s name. These examples assume that the Sh4lt GStreamer plug-in is installed in /opt/sh4lt: . Sending data from GStreamer to score: . $ gst-launch-1.0 --gst-plugin-path=/opt/sh4lt videotestsrc pattern=snow ! queue ! videoconvert ! sh4ltsink socket-path=/tmp/score_sh4lt_input . Sending data from score to GStreamer: . $ gst-launch-1.0 --gst-plugin-path=/opt/sh4lt sh4ltsrc socket-path=/tmp/score_sh4lt_output ! videoconvert ! xvimagesink . Here is a score that would process the input and write it to the output. | Input device (receives the GStreamer feed): . | Output device (sends the feed to GStreamer): . | The score and the GStreamer output which shows the processing done by score: . | . ",
    "url": "https://ossia.io/score-docs/devices/sh4lt-device.html#using-sh4lt-in-score",
    "relUrl": "/devices/sh4lt-device.html#using-sh4lt-in-score"
  },"791": {
    "doc": "Sh4lt devices",
    "title": "Recording score’s video output",
    "content": "Here is a GStreamer command-line which will encode the sh4lt output as .mkv with relatively low quality: . $ gst-launch-1.0 -e \\ sh4ltsrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! x264enc \\ ! matroskamux \\ ! filesink location=foo.mkv . Or as .mov encoded in Apple ProRes (warning: very, very CPU hungry): . $ gst-launch-1.0 -e \\ sh4ltsrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! avenc_prores_ks \\ ! qtmux \\ ! filesink location=foo.mov . ",
    "url": "https://ossia.io/score-docs/devices/sh4lt-device.html#recording-scores-video-output",
    "relUrl": "/devices/sh4lt-device.html#recording-scores-video-output"
  },"792": {
    "doc": "Sh4lt devices",
    "title": "Sh4lt devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/sh4lt-device.html",
    "relUrl": "/devices/sh4lt-device.html"
  },"793": {
    "doc": "ISF Shaders",
    "title": "ISF Shaders",
    "content": ". The shader process allow you to add and live-code your own shader to an image or video. A shader is a visual effect or generator program, which is processed with the graphics card for maximum performance. Shaders are written with the Interactive Shader Format (ISF), using GLSL. A lot of nice shaders are already provided as part of the user library, courtesy of Vidvox. They can be drag’n’dropped from the library, or from the explorer ; controls and inputs will be created automatically. ISF filters apply to the whole texture used as their input, which is then rendered to a texture used as output (or directly to the viewport). ",
    "url": "https://ossia.io/score-docs/processes/shaders.html",
    "relUrl": "/processes/shaders.html"
  },"794": {
    "doc": "ISF Shaders",
    "title": "Editing shaders",
    "content": "We recommend using the official ISF editor to edit shaders for production work ; but it is possible to edit the shader code live during execution of the score, by pressing Ctrl+Enter(Win / Linux) or⌘+Enter(Mac) when in the code editor ; the shader will be updated automatically. The shader editor allows to edit both the fragment and the vertex shader. It is really important to leverage the ISF built-in functions to access textures: since score’s graphics pipeline can leverage OpenGL, Vulkan, Metal and Direct3D, which all have different coordinates system, using the low-level primitives such as gl_FragCoord will yield Y direction inversions when using your shaders on different operating systems or grahpics backend. ",
    "url": "https://ossia.io/score-docs/processes/shaders.html#editing-shaders",
    "relUrl": "/processes/shaders.html#editing-shaders"
  },"795": {
    "doc": "ISF Shaders",
    "title": "Related Processes",
    "content": ". | VSA Shader: Similar to ISF shaders but for vertex instead of fragment shaders. | Compute Shader: Similar to ISF shaders but for compute instead of fragment shaders. | Model Display: To apply the shader onto a 3D surface. | Lightness Computer: To convert texture data into pixel arrays, for instance for LED design. ",
    "url": "https://ossia.io/score-docs/processes/shaders.html#related-processes",
    "relUrl": "/processes/shaders.html#related-processes"
  },"796": {
    "doc": "ISF Shaders",
    "title": "Try it!",
    "content": "| . Try it by downloading this simple example! Note that the example requires gzdoom to work. ",
    "url": "https://ossia.io/score-docs/processes/shaders.html#try-it",
    "relUrl": "/processes/shaders.html#try-it"
  },"797": {
    "doc": "Shell command",
    "title": "Shell command",
    "content": ". The Shell command allows you to launch and manage external system processes directly from your ossia score timeline. This powerful utility lets you integrate external scripts, commands, or applications into your interactive performances. ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html",
    "relUrl": "/processes/shell-command.html"
  },"798": {
    "doc": "Shell command",
    "title": "Overview",
    "content": "The Shell Command starts a script when its execution start. When the process starts in the timeline, the external command is launched. It is possible to use the Shell Command as part of a state to run a script as part of a cue. If you need precise control over the process’s duration and lifetime, use a Process Launcher instead. Shell Command enables: . | External application execution with command-line arguments | System process integration for complex workflows | Script execution (Python, shell scripts, etc.) | Process lifetime management tied to score timeline | Cross-platform compatibility (macOS, Linux, Windows if bash is in $PATH) | . Perfect for: . | Integrating external tools and utilities | Running analysis scripts and data processing | Launching companion applications | System administration tasks | Custom automation workflows | Educational and research applications | . ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#overview",
    "relUrl": "/processes/shell-command.html#overview"
  },"799": {
    "doc": "Shell command",
    "title": "Script Parameter Details",
    "content": "The command line to execute. This can be: . | A simple command: echo \"Hello World\" | A script with arguments: python3 /path/to/script.py --arg1 value1 | A complex shell command: ls -la | grep .txt | . The command is saved as a bash script and then executed. ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#script-parameter-details",
    "relUrl": "/processes/shell-command.html#script-parameter-details"
  },"800": {
    "doc": "Shell command",
    "title": "Inputs",
    "content": "| Port | Type | Description | . | Script | String | Executable bash script | . ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#inputs",
    "relUrl": "/processes/shell-command.html#inputs"
  },"801": {
    "doc": "Shell command",
    "title": "Technical Implementation",
    "content": "The Process Launcher uses Qt’s QProcess internally, ensuring proper cross-platform process management. The external process is launched in a separate thread and managed through Qt’s event loop system. ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#technical-implementation",
    "relUrl": "/processes/shell-command.html#technical-implementation"
  },"802": {
    "doc": "Shell command",
    "title": "Related Processes",
    "content": ". | Process Launcher | JavaScript - Scripting within score | HTTP device - Web service integration | . ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#related-processes",
    "relUrl": "/processes/shell-command.html#related-processes"
  },"803": {
    "doc": "Shell command",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! Note that the example requires gzdoom to work. ",
    "url": "https://ossia.io/score-docs/processes/shell-command.html#try-it",
    "relUrl": "/processes/shell-command.html#try-it"
  },"804": {
    "doc": "Shmdata devices",
    "title": "Shmdata",
    "content": "Shmdata, developed at the SAT Metalab, is a Unix-oriented protocol for sharing memory between applications easily. It is mainly used to share video frames. Thanks to it, score can easily send and receive video data from and to GStreamer for instance. ",
    "url": "https://ossia.io/score-docs/devices/shmdata-device.html#shmdata",
    "relUrl": "/devices/shmdata-device.html#shmdata"
  },"805": {
    "doc": "Shmdata devices",
    "title": "Compiling and installing shmdata",
    "content": "Refer to the latest instructions on the shmdata Readme. Score comes built-in with shmdata support on Linux and macOS (Windows does not support the necessary Unix primitives). Test that it works correctly with the gst-launch commands given in that Readme. ",
    "url": "https://ossia.io/score-docs/devices/shmdata-device.html#compiling-and-installing-shmdata",
    "relUrl": "/devices/shmdata-device.html#compiling-and-installing-shmdata"
  },"806": {
    "doc": "Shmdata devices",
    "title": "Using shmdata in score",
    "content": "Shmdata can currently be used as a video input and output device. Simply create the devices you need, and set your video input / output to the shmdata device’s name. These examples assume that the shmdata GStreamer plug-in is installed in /opt/shmdata: . Sending data from GStreamer to score: . $ gst-launch-1.0 --gst-plugin-path=/opt/shmdata videotestsrc pattern=snow ! queue ! videoconvert ! shmdatasink socket-path=/tmp/score_shmdata_input . Sending data from score to GStreamer: . $ gst-launch-1.0 --gst-plugin-path=/opt/shmdata shmdatasrc socket-path=/tmp/score_shmdata_output ! videoconvert ! xvimagesink . Here is a score that would process the input and write it to the output. | Input device (receives the GStreamer feed): . | Output device (sends the feed to GStreamer): . | The score and the GStreamer output which shows the processing done by score: . | . ",
    "url": "https://ossia.io/score-docs/devices/shmdata-device.html#using-shmdata-in-score",
    "relUrl": "/devices/shmdata-device.html#using-shmdata-in-score"
  },"807": {
    "doc": "Shmdata devices",
    "title": "Recording score’s video output",
    "content": "Here is a GStreamer command-line which will encode the shmdata output as .mkv with relatively low quality: . $ gst-launch-1.0 -e \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! x264enc \\ ! matroskamux \\ ! filesink location=foo.mkv . Or as .mov encoded in Apple ProRes (warning: very, very CPU hungry): . $ gst-launch-1.0 -e \\ shmdatasrc socket-path=/tmp/score_shm_video \\ ! queue \\ ! videoconvert \\ ! videorate \\ ! video/x-raw,framerate=60/1 \\ ! avenc_prores_ks \\ ! qtmux \\ ! filesink location=foo.mov . ",
    "url": "https://ossia.io/score-docs/devices/shmdata-device.html#recording-scores-video-output",
    "relUrl": "/devices/shmdata-device.html#recording-scores-video-output"
  },"808": {
    "doc": "Shmdata devices",
    "title": "Shmdata devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/shmdata-device.html",
    "relUrl": "/devices/shmdata-device.html"
  },"809": {
    "doc": "Shortcuts",
    "title": "General",
    "content": ". | Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac): Show Device explorer panel | Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac): Show Processes library panel | Ctrl+Shift+B(Win / Linux) or⌘+Shift+B(Mac): Show System library panel | Ctrl+Shift+L(Win / Linux) or⌘+Shift+L(Mac): Show Project library panel | Ctrl+Shift+C(Win / Linux) or⌘+Shift+C(Mac): Show Console panel | Ctrl+Shift+G(Win / Linux) or⌘+Shift+G(Mac): Show Messages log panel | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#general",
    "relUrl": "/reference/shortcuts.html#general"
  },"810": {
    "doc": "Shortcuts",
    "title": "Conditions",
    "content": ". | Suppr/Backspace: Delete selected condition | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#conditions",
    "relUrl": "/reference/shortcuts.html#conditions"
  },"811": {
    "doc": "Shortcuts",
    "title": "Device explorer",
    "content": ". | Esc: De-select node | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#device-explorer",
    "relUrl": "/reference/shortcuts.html#device-explorer"
  },"812": {
    "doc": "Shortcuts",
    "title": "Timeline",
    "content": ". | ↑, ↓, →, ←: Navigate through the various linked elements on the Timeline | Ctrl+Alt+↑(Win / Linux) or⌘+Alt+↑(Mac): Go back to parent scenario | Ctrl+Alt+U(Win / Linux) or⌘+Alt+U(Mac): Unroll all processes attached to an interval | Ctrl+Alt+F(Win / Linux) or⌘+Alt+F(Mac): Fold all processes attached to an interval | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#timeline",
    "relUrl": "/reference/shortcuts.html#timeline"
  },"813": {
    "doc": "Shortcuts",
    "title": "Trigger",
    "content": ". | Suppr/Backspace: Delete selected trigger | . ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html#trigger",
    "relUrl": "/reference/shortcuts.html#trigger"
  },"814": {
    "doc": "Shortcuts",
    "title": "Shortcuts",
    "content": "Below is a list of shortcuts available in score listed by scope of usage. ",
    "url": "https://ossia.io/score-docs/reference/shortcuts.html",
    "relUrl": "/reference/shortcuts.html"
  },"815": {
    "doc": "Signal Display",
    "title": "Signal Display",
    "content": ". Visualize control signals in real-time for monitoring, debugging, and performance feedback. Signal Display shows you exactly what’s happening with your parameter data, making it easy to understand signal flow and troubleshoot issues. Essential for understanding complex control systems, monitoring sensor inputs, or providing visual feedback during performances and installations. ",
    "url": "https://ossia.io/score-docs/processes/signal-display.html",
    "relUrl": "/processes/signal-display.html"
  },"816": {
    "doc": "Signal Display",
    "title": "Related processes",
    "content": "score comes with multiple processes for monitoring input data LED View, Point2D View, Value display. ",
    "url": "https://ossia.io/score-docs/processes/signal-display.html#related-processes",
    "relUrl": "/processes/signal-display.html#related-processes"
  },"817": {
    "doc": "Signal Display",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/signal-display.html#try-it",
    "relUrl": "/processes/signal-display.html#try-it"
  },"818": {
    "doc": "Smooth",
    "title": "Smooth",
    "content": ". The Smooth process can be used to tame a noisy input stream, coming from a very sensitive sensor for example. The output of this process may be more usable than the raw stream to control other parameters. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html",
    "relUrl": "/processes/smooth.html"
  },"819": {
    "doc": "Smooth",
    "title": "Continuous",
    "content": "This setting will keep smoothing the signal at a regular rate even if there is no input, by assuming that the last input value is being continuously fed in. This allows to transform a signal with a slow data rate, for instance with a new value every two seconds, into a smooth control signal. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#continuous",
    "relUrl": "/processes/smooth.html#continuous"
  },"820": {
    "doc": "Smooth",
    "title": "Amount",
    "content": "0 applies the least amount of filtering, 1 the most. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#amount",
    "relUrl": "/processes/smooth.html#amount"
  },"821": {
    "doc": "Smooth",
    "title": "Type",
    "content": "There are 4 different filters available: . | OneEuro for the 1€ filter. | LowPass that only uses the low pass implementation from the one euro filter. | Average for a floating average. | Median for a floating median. | . ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#type",
    "relUrl": "/processes/smooth.html#type"
  },"822": {
    "doc": "Smooth",
    "title": "Freq (1e/LP)",
    "content": "Minimum cutoff frequency for OneEuro and LowPass, between 0 and 300. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#freq-1elp",
    "relUrl": "/processes/smooth.html#freq-1elp"
  },"823": {
    "doc": "Smooth",
    "title": "Cutoff (1e/LP)",
    "content": "Cutoff frequency of the derivative for OneEuro and LowPass, between 0 and 10. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#cutoff-1elp",
    "relUrl": "/processes/smooth.html#cutoff-1elp"
  },"824": {
    "doc": "Smooth",
    "title": "Beta (1e only)",
    "content": "Cutoff slope for OneEuro, between 0 and 10. ",
    "url": "https://ossia.io/score-docs/processes/smooth.html#beta-1e-only",
    "relUrl": "/processes/smooth.html#beta-1e-only"
  },"825": {
    "doc": "Soundfiles",
    "title": "Sound file process",
    "content": "To add a sound file, the easiest way is to drag’n’drop it either from the operating system, or from the library. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#sound-file-process",
    "relUrl": "/processes/soundfile.html#sound-file-process"
  },"826": {
    "doc": "Soundfiles",
    "title": "Timestretching",
    "content": "ossia score supports 4 modes of playback: . | No stretching at all (Raw). | Re-pitching through resampling thanks to the libsamplerate library. | Time-stretching (pitch does not change) thanks to the Rubberband library, in a mode optimized for drums and another for tonal instruments. | . If a file has any tempo information (either through ACID tags or a BPM present in the filename), it is automatically assumed to be a loop and put in loop mode with the timestretch enabled. The tempo of the soundfile can be adjusted through the inspector ; the ratio between its tempo and the current playback tempo will be used to timestretch / repitch accordingly. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#timestretching",
    "relUrl": "/processes/soundfile.html#timestretching"
  },"827": {
    "doc": "Soundfiles",
    "title": "RAM / disk playback",
    "content": "score will stream .wav / .aiff files at the same samplerate than the project from disk directly. All the other files will be decoded first and read from RAM. | Until a choice is implemented, we recommend users who have large .wav files and slow hard drives to set-up a RAMDisk manually. | . ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#ram--disk-playback",
    "relUrl": "/processes/soundfile.html#ram--disk-playback"
  },"828": {
    "doc": "Soundfiles",
    "title": "Supported formats",
    "content": "score should be able to read any file supported by FFMPEG. Current releases are built with FFMPEG 4.4. The list of supported audio format is available here. ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html#supported-formats",
    "relUrl": "/processes/soundfile.html#supported-formats"
  },"829": {
    "doc": "Soundfiles",
    "title": "Soundfiles",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/soundfile.html",
    "relUrl": "/processes/soundfile.html"
  },"830": {
    "doc": "Spammer",
    "title": "Spammer",
    "content": ". Spammer allows to bypass the message send rate of score. It will send messages at arbitrary precision and will smooth across values over time. It is useful when a specific external device or software can handle much higher message resolution than usual software. ",
    "url": "https://ossia.io/score-docs/processes/spammer.html",
    "relUrl": "/processes/spammer.html"
  },"831": {
    "doc": "SpatGris device",
    "title": "SpatGris device",
    "content": ". ossia supports talking to SpatGris and wraps its OSC API as an easy-to-use list of spatialized sound objects. ",
    "url": "https://ossia.io/score-docs/devices/spatgris-device.html",
    "relUrl": "/devices/spatgris-device.html"
  },"832": {
    "doc": "Matrix Spatialization",
    "title": "Matrix spatialization",
    "content": ". This object applies a series of weights to input audio channels. ",
    "url": "https://ossia.io/score-docs/processes/matrix-spatialization.html#matrix-spatialization",
    "relUrl": "/processes/matrix-spatialization.html#matrix-spatialization"
  },"833": {
    "doc": "Matrix Spatialization",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/matrix-spatialization.html#try-it",
    "relUrl": "/processes/matrix-spatialization.html#try-it"
  },"834": {
    "doc": "Matrix Spatialization",
    "title": "Matrix Spatialization",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/matrix-spatialization.html",
    "relUrl": "/processes/matrix-spatialization.html"
  },"835": {
    "doc": "Spout devices",
    "title": "Spout",
    "content": "Spout is a Windows-only protocol and library for sharing video textures across applications. ",
    "url": "https://ossia.io/score-docs/devices/spout-device.html#spout",
    "relUrl": "/devices/spout-device.html#spout"
  },"836": {
    "doc": "Spout devices",
    "title": "Spout input device",
    "content": "This device allows receiving a video stream directly from a Spout-compatible input. Simply choose the wanted input in the list, and put the output at the end of the video chain. ",
    "url": "https://ossia.io/score-docs/devices/spout-device.html#spout-input-device",
    "relUrl": "/devices/spout-device.html#spout-input-device"
  },"837": {
    "doc": "Spout devices",
    "title": "Spout output device",
    "content": "This device allows to create a Spout stream that other sPout-compatible software will be able to display or modify. Simply choose the viewport options, a rendering rate, and a name for the output. You can then use the device as input to video filters. ",
    "url": "https://ossia.io/score-docs/devices/spout-device.html#spout-output-device",
    "relUrl": "/devices/spout-device.html#spout-output-device"
  },"838": {
    "doc": "Spout devices",
    "title": "Spout devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/spout-device.html",
    "relUrl": "/devices/spout-device.html"
  },"839": {
    "doc": "Sprite Reader",
    "title": "Sprite Reader",
    "content": ". The Sprite Reader process extracts individual sprites from sprite sheets, enabling retro-style animations and efficient texture usage. Perfect for game development aesthetics, pixel art animations, and nostalgic visual effects. ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html",
    "relUrl": "/processes/sprite-reader.html"
  },"840": {
    "doc": "Sprite Reader",
    "title": "Overview",
    "content": "Sprite Reader enables: . | Sprite sheet parsing - Extract individual frames from grid-based sprite sheets | Animation control - Navigate through sprites with percentage-based control | Retro gaming aesthetics - Perfect for 8-bit and 16-bit style visuals | Efficient texture usage - Pack multiple sprites into single texture files | Real-time animation - Drive sprite selection with automations or external controls | . ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#overview",
    "relUrl": "/processes/sprite-reader.html#overview"
  },"841": {
    "doc": "Sprite Reader",
    "title": "Parameters",
    "content": "Image . Type: File input Supported formats: PNG, JPEG, GIF, BMP Description: The sprite sheet image file containing the grid of sprites . Sprite Size . Type: XY Spinboxes (integers) Default: 32x32 Range: 1-1024 pixels . Sets the dimensions of each individual sprite in the sheet. All sprites must be the same size and arranged in a regular grid. Image Count . Type: Horizontal slider (0.0 - 1.0) Default: 0.0 . Controls which sprite to display as a percentage through the total sprite count: . | 0.0 = First sprite (top-left) | 0.5 = Middle sprite | 1.0 = Last sprite (bottom-right) | . ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#parameters",
    "relUrl": "/processes/sprite-reader.html#parameters"
  },"842": {
    "doc": "Sprite Reader",
    "title": "Output",
    "content": "Out . Type: Texture output Content: Current selected sprite as GPU texture . Provides the extracted sprite as a texture ready for use in the graphics pipeline. ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#output",
    "relUrl": "/processes/sprite-reader.html#output"
  },"843": {
    "doc": "Sprite Reader",
    "title": "How It Works",
    "content": "The Sprite Reader automatically calculates the sprite grid layout: . | Grid Detection: Divides the image by sprite size to determine rows and columns | Sprite Indexing: Numbers sprites from left-to-right, top-to-bottom | Percentage Mapping: Maps the 0.0-1.0 input range to sprite indices | Extraction: Copies the selected sprite region to output texture | . Example Grid Layout . Sprite Sheet (128x64, 32x32 sprites): ┌──────┬──────┬──────┬──────┐ │ 0 │ 1 │ 2 │ 3 │ ├──────┼──────┼──────┼──────┤ │ 4 │ 5 │ 6 │ 7 │ └──────┴──────┴──────┴──────┘ Percentage → Sprite: 0.0 → 0, 0.125 → 1, 0.25 → 2, etc. For instance, you can create tempo-synchronized pixel art animations for music visualization. ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#how-it-works",
    "relUrl": "/processes/sprite-reader.html#how-it-works"
  },"844": {
    "doc": "Sprite Reader",
    "title": "Sprite Sheet Preparation",
    "content": "Best Practices . | Uniform sizing: All sprites must be exactly the same dimensions | Grid alignment: Sprites should align perfectly to a regular grid | No spacing: Avoid gaps between sprites (0-pixel spacing) | Power-of-2 dimensions: Use 32x32, 64x64, 128x128 for optimal GPU performance | Consistent style: Maintain visual consistency across all sprites | . Common Sprite Sizes . | 8x8: Tiny icons, simple pixel art | 16x16: Classic retro game sprites | 32x32: Standard indie game characters | 64x64: Detailed character sprites | 128x128: High-resolution sprites | . File Format Tips . | PNG: Best for pixel art with transparency | JPEG: Acceptable for photos but avoid for pixel art | Use transparency: PNG alpha channel for transparent backgrounds | . ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#sprite-sheet-preparation",
    "relUrl": "/processes/sprite-reader.html#sprite-sheet-preparation"
  },"845": {
    "doc": "Sprite Reader",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/sprite-reader.html#try-it",
    "relUrl": "/processes/sprite-reader.html#try-it"
  },"846": {
    "doc": "States & automations in practice",
    "title": "States &amp; automations in practice",
    "content": "In previous sections of this quick start guide, we saw two elementary methods to write scenarios for your project: saving &amp; recalling some device’s state as well as writing simple automations for its parameters. While elementary, these two very features still offer a lot of flexibility to author advanced scenarios for your creations project. This is made even more flexible given a handful of score’s practice-based workflow features. Rather than separating cue-like execution of messages toward your devices and time evolving processes such as automations, score offer a number of ways to easily mix two approaches in a unified workflow. ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html#states--automations-in-practice",
    "relUrl": "/quick-start/states-and-automations-in-practice.html#states--automations-in-practice"
  },"847": {
    "doc": "States & automations in practice",
    "title": "Sequence mode",
    "content": "Setting up auto-sequence mode . A workflow you might find useful is the auto-sequence mode. As of score 3, auto-sequence is an option that needs to be activated from the software preferences. To do so, bring up the Settings window. In the Settings window, select the User interface tab then make sure the auto-sequence option is toggled. Using auto-sequence . In previous sections, we saw how to drag parameters from the Device explorer to easily store your device’s state on the timeline as well as drag some processes (in this case automation). Auto-sequence kind of allows us to do both in one go. In the example below, we will start by storing an initial state for our device. Then after making some changes to our device, rather than dropping the parameters from the Device explorer to the timeline again, we will instead use the blue + icon next to the state icon and drag the link to a later point in the timeline. What’s happening here is twofold: . | storing a new state using that blue + button will store the device’s state using the namespace selection defined in the previous stored state | using the auto-sequence option, score will automatically create some automations for the parameter that changed between initial state and newly created state | . You may also store a new state by dragging from the blue + icon without auto-sequence mode activated. In that case, score will still use the previous namespace selection to store parameters values but no automation will get created for changed parameters. Of course, once these automations get auto-magically created, you can still edit their behavior over time and make any pleasing changes to their curve. You may also remove an automation should you want not to include a parameter continuous change. Note on multiple automations editing . In the example above, you can see multiple automation slots actually got superposed. You can bring to front any of the automations in background to edit it. To do so, click on the address bar at the top of the slot to open up the list of superposed parameters ‘automation. Select in the contextual menu the one to edit. Once to front (displayed in red), it can be edited. When multiple automations are stacked, the frontmost one is drawn with a red line, while the ones behind are drawn with a greyed out line . You can also remove an automation from the stack by clicking on a slot background. Bring up the contextual menu using right-click and select remove. ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html#sequence-mode",
    "relUrl": "/quick-start/states-and-automations-in-practice.html#sequence-mode"
  },"848": {
    "doc": "States & automations in practice",
    "title": "States & automations in practice",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/states-and-automations-in-practice.html",
    "relUrl": "/quick-start/states-and-automations-in-practice.html"
  },"849": {
    "doc": "Step sequencer",
    "title": "Step Sequencer",
    "content": ". Score has a separate step sequencer where you can edit the number of rows and the duration of each step. If the window is stretched beyond the last row, the sequencer will be automatically repeated. ",
    "url": "https://ossia.io/score-docs/processes/step.html#step-sequencer",
    "relUrl": "/processes/step.html#step-sequencer"
  },"850": {
    "doc": "Step sequencer",
    "title": "Step sequencer",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/step.html",
    "relUrl": "/processes/step.html"
  },"851": {
    "doc": "Structure Synth",
    "title": "Structure Synth",
    "content": ". Generate complex 3D geometry using rule-based procedural algorithms. Write programs in EisenScript (a simple domain-specific language) and watch as recursive rules create intricate 3D structures, organic forms, and architectural patterns. Perfect for procedural art, architectural visualization, generative design, or any project where you need complex 3D geometry that would be tedious to model by hand. This is based on the code from the original Structure Synth software, which was ported to ossia. ",
    "url": "https://ossia.io/score-docs/processes/structure-synth.html",
    "relUrl": "/processes/structure-synth.html"
  },"852": {
    "doc": "Structure Synth",
    "title": "How it works",
    "content": "Structure Synth interprets EisenScript programs that define recursive rules for generating 3D geometry. You write rules that describe how shapes should transform, combine, and multiply, then the system executes these rules to build complex 3D meshes. Be careful about having too much recursion: this will cause the mesh generation to take sometimes multiple seconds. ",
    "url": "https://ossia.io/score-docs/processes/structure-synth.html#how-it-works",
    "relUrl": "/processes/structure-synth.html#how-it-works"
  },"853": {
    "doc": "Structure Synth",
    "title": "EisenScript basics",
    "content": "EisenScript is a straightforward language focused on geometric transformations and rule-based generation: . set maxdepth 200 { a 0.9 hue 30 } R1 rule R1 w 10 { { x 1 rz 3 ry 5 } R1 { s 1 1 0.1 sat 0.9 } box } rule R1 w 10 { { x 1 rz -3 ry 5 } R1 { s 1 1 0.1 } box } . ",
    "url": "https://ossia.io/score-docs/processes/structure-synth.html#eisenscript-basics",
    "relUrl": "/processes/structure-synth.html#eisenscript-basics"
  },"854": {
    "doc": "Structure Synth",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/structure-synth.html#try-it",
    "relUrl": "/processes/structure-synth.html#try-it"
  },"855": {
    "doc": "Sweeper",
    "title": "Sweeper",
    "content": ". Given an input value, this process periodically sends it to all the OSC addresses matching an address pattern expression. For instance: given the addresses: . arduinos:/led.1 arduinos:/led.2 arduinos:/led.3 arduinos:/led.4 . which are the brightness of some LEDs, then the Sweeper process receiving an LFO signal as input will periodically distribute it across the LEDs, to create a sweeping motion, with the pattern: arduinos:/led.*. ",
    "url": "https://ossia.io/score-docs/processes/sweeper.html",
    "relUrl": "/processes/sweeper.html"
  },"856": {
    "doc": "Syphon devices",
    "title": "Syphon",
    "content": "Syphon is a macOS-only protocol and library for sharing video textures across applications. ",
    "url": "https://ossia.io/score-docs/devices/syphon-device.html#syphon",
    "relUrl": "/devices/syphon-device.html#syphon"
  },"857": {
    "doc": "Syphon devices",
    "title": "Syphon input device",
    "content": "This device allows receiving a video stream directly from a Syphon-compatible input. Simply choose the wanted input in the list, and put the output at the end of the video chain. ",
    "url": "https://ossia.io/score-docs/devices/syphon-device.html#syphon-input-device",
    "relUrl": "/devices/syphon-device.html#syphon-input-device"
  },"858": {
    "doc": "Syphon devices",
    "title": "Syphon output device",
    "content": "This device allows to create a Syphon stream that other Syphon-compatible software will be able to display or modify. Simply choose the viewport options, a rendering rate, and a name for the output. You can then use the device as input to video filters. ",
    "url": "https://ossia.io/score-docs/devices/syphon-device.html#syphon-output-device",
    "relUrl": "/devices/syphon-device.html#syphon-output-device"
  },"859": {
    "doc": "Syphon devices",
    "title": "Syphon devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/devices/syphon-device.html",
    "relUrl": "/devices/syphon-device.html"
  },"860": {
    "doc": "Teleplot",
    "title": "Teleplot",
    "content": ". Send data to remote plotting applications for real-time visualization and analysis. Teleplot streams parameter data over network connections, allowing you to monitor and analyze your score project’s behavior using external visualization tools. Perfect for system monitoring, performance analysis, debugging complex control systems, or creating real-time data visualizations for presentations and installations. ",
    "url": "https://ossia.io/score-docs/processes/teleplot.html",
    "relUrl": "/processes/teleplot.html"
  },"861": {
    "doc": "Teleplot",
    "title": "Using the teleplot process",
    "content": ". | Open the Teleplot website or a Teleplot-compatible client, for instance the VSCode extension. | Create a Teleplot object in score. | Set the hostname and port from your teleplot instance: for instance, teleplot.fr:45603. | Set the list of addresses you want to plot through the OSC pattern syntax. For instance, my_device:/main/foo.* would send all the nodes such as /main/foo.1, /main/foo.bar, etc. | . ",
    "url": "https://ossia.io/score-docs/processes/teleplot.html#using-the-teleplot-process",
    "relUrl": "/processes/teleplot.html#using-the-teleplot-process"
  },"862": {
    "doc": "Teleplot",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/teleplot.html#try-it",
    "relUrl": "/processes/teleplot.html#try-it"
  },"863": {
    "doc": "Tempo",
    "title": "Tempo",
    "content": "This process allows to add a tempo curve to an interval, and to control its speed programmatically through the dataflow system. When a tempo process is assigned to an interval, its speed behaviour is taken out of the parent hierarchy: the tempo is absolute and not impacted by the parent hierarchy’s speed: a tempo of 120 will always mean 120 in relation to the human referential. All the child intervals of this interval will however use this interval’s tempo, unless them theyselve get a tempo curve. This allows to write poly-tempo scores. If values are sent to the tempo process’s input port, then the curve is not used and the port instead is used as source for the parent interval’s tempo. ",
    "url": "https://ossia.io/score-docs/processes/tempo.html",
    "relUrl": "/processes/tempo.html"
  },"864": {
    "doc": "Tempo",
    "title": "Example",
    "content": ". ",
    "url": "https://ossia.io/score-docs/processes/tempo.html#example",
    "relUrl": "/processes/tempo.html#example"
  },"865": {
    "doc": "Texture generator",
    "title": "C++ Texture generator",
    "content": "This process allows to live-code a texture generator for live visuals. It is ideal for retro pixel texture effects with a DOS or Amiga vibe. The code is written in C++ (23). The function score_rgba will be called at every frame with the pixels of the texture to write into. The texture’s data is retained across frames. Be careful and save often: invalid memory accesses will make score crash as the C++ code is executed directly in-process! . Since the rendering is done on CPU, it is important to be mindful of the texture size: adjust the size of the render target in which the Texgen object is rendering to a smaller fixed size if the rendering is too slow. ",
    "url": "https://ossia.io/score-docs/processes/texgen.html#c-texture-generator",
    "relUrl": "/processes/texgen.html#c-texture-generator"
  },"866": {
    "doc": "Texture generator",
    "title": "Example",
    "content": "extern \"C\" void score_rgba(unsigned char* rgba, int width, int height, int t) { int k = 0; for(int j = 0; j &lt; height; j++) { for(int i = 0; i &lt; width; i++) { rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); rgba[k++] = 255 * t * k / (width * height); } } } . Here are some examples from the presets that are part of the user library: . | | . | | . ",
    "url": "https://ossia.io/score-docs/processes/texgen.html#example",
    "relUrl": "/processes/texgen.html#example"
  },"867": {
    "doc": "Texture generator",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/texgen.html#try-it",
    "relUrl": "/processes/texgen.html#try-it"
  },"868": {
    "doc": "Texture generator",
    "title": "Texture generator",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/texgen.html",
    "relUrl": "/processes/texgen.html"
  },"869": {
    "doc": "Text process",
    "title": "Text",
    "content": "TODO . ",
    "url": "https://ossia.io/score-docs/processes/text.html#text",
    "relUrl": "/processes/text.html#text"
  },"870": {
    "doc": "Text process",
    "title": "Text process",
    "content": " ",
    "url": "https://ossia.io/score-docs/processes/text.html",
    "relUrl": "/processes/text.html"
  },"871": {
    "doc": "Trigger",
    "title": "Trigger",
    "content": ". This object sends trigger messages when the incoming values enter or leave the input range. Example: if the input messages are: . 5 3.6 3.4 3.8 1457 -50000 . then given a min of 2 and max of 4, there will be: . | An “enter” trigger when the 3.6 message is received (we entered the range) | A “leave” trigger when the 1457 message is received (we left the range). | . The second operation mode, “Outside/Inside” instead sends messages whenever the values enter or exit the range. ",
    "url": "https://ossia.io/score-docs/processes/trigger.html",
    "relUrl": "/processes/trigger.html"
  },"872": {
    "doc": "Trigger",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/trigger.html#try-it",
    "relUrl": "/processes/trigger.html#try-it"
  },"873": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting score issues",
    "content": " ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#troubleshooting-score-issues",
    "relUrl": "/troubleshooting.html#troubleshooting-score-issues"
  },"874": {
    "doc": "Troubleshooting",
    "title": "score just crashed",
    "content": "Please send us a detailed bug report of what you were doing at the moment of the crash, along with any crashlog, in either the forum, the chat or the Github issues (preferably). Thanks ! . ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-just-crashed",
    "relUrl": "/troubleshooting.html#score-just-crashed"
  },"875": {
    "doc": "Troubleshooting",
    "title": "score crashes immediately on first start-up on Windows",
    "content": "Check that you do not have the JACK2 ASIO driver installed. It is known to cause crashes on startup on Windows for many software. You can check the following registry key in the Windows registry editor: HKEY_LOCAL_MACHINE\\SOFTWARE\\ASIO. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-windows",
    "relUrl": "/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-windows"
  },"876": {
    "doc": "Troubleshooting",
    "title": "score crashes immediately on first start-up on Linux",
    "content": "If you get an error from the terminal which looks like: . The program 'ossia-score' received an X Window System error. This probably reflects a bug in the program. The error was 'BadMatch (invalid parameter attributes)'. (Details: serial 363 error_code 8 request_code 154 minor_code 34) (Note to programmers: normally, X errors are reported asynchronously; that is, you will receive the error a while after causing it. To debug your program, run it with the --sync command line option to change this behavior. You can then get a meaningful backtrace from your debugger if you break on the gdk_x_error() function.) . Then this is likely an OpenGL driver issue. Try running score with the --no-opengl command-line flag. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-linux",
    "relUrl": "/troubleshooting.html#score-crashes-immediately-on-first-start-up-on-linux"
  },"877": {
    "doc": "Troubleshooting",
    "title": "The playback does not start",
    "content": "Most of the time, this is due to incorrect sound settings. Go to the settings and check that you have a valid sound card set. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-playback-does-not-start",
    "relUrl": "/troubleshooting.html#the-playback-does-not-start"
  },"878": {
    "doc": "Troubleshooting",
    "title": "The score runs but there is no sound",
    "content": "Most of the time, this is due to incorrect sound settings. Check that you are not using the Dummy driver which does not uses the soundcard. Go to the settings and check that the correct sound-card is selected for audio output (for instance, it happens that the sound card chosen is the HDMI output of the computer monitor, which may not have loudspeakers). ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-score-runs-but-there-is-no-sound",
    "relUrl": "/troubleshooting.html#the-score-runs-but-there-is-no-sound"
  },"879": {
    "doc": "Troubleshooting",
    "title": "Playback seems to hang at random times on Linux",
    "content": "This is due to a PortAudio bug. Use the JACK backend instead. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#playback-seems-to-hang-at-random-times-on-linux",
    "relUrl": "/troubleshooting.html#playback-seems-to-hang-at-random-times-on-linux"
  },"880": {
    "doc": "Troubleshooting",
    "title": "Some VST plug-ins and virtual cameras do not work on Mac",
    "content": "You are likely encountering security-related macOS issues. As a workaround, you can follow the steps given in the above link to remove the code signing of the score binary, which will in turn make macOS allow score to open virtual webcams and any audio plug-ins. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#some-vst-plug-ins-and-virtual-cameras-do-not-work-on-mac",
    "relUrl": "/troubleshooting.html#some-vst-plug-ins-and-virtual-cameras-do-not-work-on-mac"
  },"881": {
    "doc": "Troubleshooting",
    "title": "The minimap is hard to use on Mac",
    "content": "You are likely encountering this macOS issue. A possible solution if score cannot be added to the Accessibility settings panel, is to remove the file /Library/Application Support/com.apple.TCC/TCC.db and then reboot, according to this link. As a workaround, you can try to open score by right-clicking on Score.app, selection “Open contents”, navigating to “Score.app/Contents/MacOS” and running the “score” binary from there. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#the-minimap-is-hard-to-use-on-mac",
    "relUrl": "/troubleshooting.html#the-minimap-is-hard-to-use-on-mac"
  },"882": {
    "doc": "Troubleshooting",
    "title": "I don’t receive OSC / DMX / … messages",
    "content": "Check that your operating system does not have a firewall running. For instance, in some Linux distributions such as CachyOS, default configurations of firewalls block incoming UDP messages fairly indiscriminately. ",
    "url": "https://ossia.io/score-docs/troubleshooting.html#i-dont-receive-osc--dmx---messages",
    "relUrl": "/troubleshooting.html#i-dont-receive-osc--dmx---messages"
  },"883": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": " ",
    "url": "https://ossia.io/score-docs/troubleshooting.html",
    "relUrl": "/troubleshooting.html"
  },"884": {
    "doc": "Tweener",
    "title": "Tweener",
    "content": ". Create smooth transitions between values with professional easing curves. Instead of abrupt parameter changes, Tweener provides fluid, organic movement that feels natural and polished. Essential for creating smooth animations, gentle parameter transitions, or any time you need to interpolate between different values with precise timing control. It uses the duration of the parent interval as temporal reference: the tween will start at the beginning of the interval and will end at its end. ",
    "url": "https://ossia.io/score-docs/processes/tweener.html",
    "relUrl": "/processes/tweener.html"
  },"885": {
    "doc": "Tweener",
    "title": "Related processes",
    "content": "Easetanbul is the temporal alter-ego of Tweener: while Tweener tweens between its two inlets, Easetanbul tweens between incoming values. Automation allows to tween but only between one value known in advance and one unknown, Tweener instead allows to tween between two unknown values. ",
    "url": "https://ossia.io/score-docs/processes/tweener.html#related-processes",
    "relUrl": "/processes/tweener.html#related-processes"
  },"886": {
    "doc": "Tweener",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! . ",
    "url": "https://ossia.io/score-docs/processes/tweener.html#try-it",
    "relUrl": "/processes/tweener.html#try-it"
  },"887": {
    "doc": "Address system",
    "title": "Unit system",
    "content": "score provides various features to ease the management of parameters. These are specially useful when writing complex processes (e.g automations). ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#unit-system",
    "relUrl": "/in-depth/unit-system.html#unit-system"
  },"888": {
    "doc": "Address system",
    "title": "Addressing items in arrays",
    "content": "When a parameter of a declared device defines a set of values (e.g parameters defining an XYZ position or an RGB color), items in this array can accessed independently using a special syntax: a parameter address may be followed by an integer (starting from zero) in brackets, which will select a given member. For example, using aDevice:/anAddress@[1] as a destination address of an automation will send the automation value to the second element in the array. If the array contains sub-arrays (for instance for a matrix), it is possible to address sub-elements like this: . aDevice:/anAddress@[1][0] . For instance, given . aDevice:/anAddress == [ [a, b], [c, d] ] . the above address will change the value of c. Note that without specifying an index, messages and automations sent to array parameters (i.e. vec2f, vec3f, list) will affect all items in the array. ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#addressing-items-in-arrays",
    "relUrl": "/in-depth/unit-system.html#addressing-items-in-arrays"
  },"889": {
    "doc": "Address system",
    "title": "Using unit conversion",
    "content": "Parameters of a device may be declared with a specific unit (for instance, parameters defining a position in space or a color). score embeds an automatic unit conversion mechanism for advanced automations. When using these parameters in ports of processes, it is also possible to set an unit set on them, with the same syntax than for array indexing: using aDevice:/anAddress@[angle.radian] as a destination address of an automation will send the value in this unit (ie. radian). The value will be converted back to the address’s original unit when sent over the network protocol, which may be for instance degrees. The complete list of supported units is available in the libossia documentation. In the case of multi-dimensional quantities (for instance, colors, 3D positions), it is also possible to select a single component: . aDevice:/anAddress[color.rgb.r] . as the output of an automation will only update the red component. This also works with different units: for instance, if the device has a parameter declared with the color.rgb unit, it is possible to control its hue with parameter@[color.hsv.h]. ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html#using-unit-conversion",
    "relUrl": "/in-depth/unit-system.html#using-unit-conversion"
  },"890": {
    "doc": "Address system",
    "title": "Address system",
    "content": " ",
    "url": "https://ossia.io/score-docs/in-depth/unit-system.html",
    "relUrl": "/in-depth/unit-system.html"
  },"891": {
    "doc": "Value Display",
    "title": "Value Display",
    "content": ". Visualize control signals in real-time for monitoring, debugging, and performance feedback. Value Display shows you the current value being ouput from a given node, or an input OSC or network message. Simply connect it to an output and watch the result. The inspector allows to select how many recent values are retained. ",
    "url": "https://ossia.io/score-docs/processes/value-display.html",
    "relUrl": "/processes/value-display.html"
  },"892": {
    "doc": "Value Display",
    "title": "Related processes",
    "content": "score comes with multiple processes for monitoring input data Signal Display, LED View, Point2D View. ",
    "url": "https://ossia.io/score-docs/processes/value-display.html#related-processes",
    "relUrl": "/processes/value-display.html#related-processes"
  },"893": {
    "doc": "Value Filter",
    "title": "Value Filter",
    "content": ". Value filter is a toolkit for letting incoming values go through according to multiple parameters: . | Is the value repeating or close to the last incoming value? (Noise gate) | . For instance, to turn the following input: . 0 1 1 1 0 1 0 0 1 . Into . 0 1 0 1 0 1 . or, with some margin: . 0.1 0.8 1.1 -0.1 -0.08 1.02 . into . 0.1 0.8 -0.1 1.02 . | Is the value close in time to another value? . | Do we want to clamp this value ? . | If clamped, do we want to filter the repetition of the clamped values too? (Repetition filter) . | . ",
    "url": "https://ossia.io/score-docs/processes/value-filter.html",
    "relUrl": "/processes/value-filter.html"
  },"894": {
    "doc": "Video",
    "title": "Video",
    "content": "The video process allows to play a video. Video decoding is done with the help of the GPU as far as possible, e.g. for YUV420P or HAP data. Most common codecs and pixel formats are supported ; we use FFMPEG for decoding plus the HAP library by Vidvox for HAP videos. ",
    "url": "https://ossia.io/score-docs/processes/video.html",
    "relUrl": "/processes/video.html"
  },"895": {
    "doc": "Video",
    "title": "Usage",
    "content": "To add a video to a score, the simplest is to drag’n’drop it from the user library to the score. Videos loop by default to facilitate VJ use-cases. Otherwise a black screen would be shown when reaching the end. Do not forget to set a trigger at the end, though ! . The simplest way to play a video is as follows: . | Add a window device | Drop the video | Select the output port of the video process and assign it to the window device. | . See the example: . Note that for now the sound tracks contained in video files are not handled; this will be done in a later version. As a workaround, audio content can be extracted from the video and dropped on the same interval to preserve synchronization. The following ffmpeg command can be used to extract audio track from a given input file : . $ ffmpeg -i &lt;input_file&gt; extracted_audio.wav . ",
    "url": "https://ossia.io/score-docs/processes/video.html#usage",
    "relUrl": "/processes/video.html#usage"
  },"896": {
    "doc": "Video",
    "title": "Inspector controls",
    "content": "The video inspector allows to set a stretch mode and the timing behaviour: . | Stretch modes can be the usual stretch / fill / keep original. | Tempo is used to map the video to the score tempo, and to enable time-stretching with the Tempo process. If Use tempo is not set, then the video will play at its internal rate. Otherwise, it will assume that the video is at the given tempo, and play it faster / slower depending on the difference between that tempo and the score’s actual playback speed: a video set at 120 will play twice as slow if the score tempo is at 60. | . ",
    "url": "https://ossia.io/score-docs/processes/video.html#inspector-controls",
    "relUrl": "/processes/video.html#inspector-controls"
  },"897": {
    "doc": "Video",
    "title": "Limitations",
    "content": "While for simple playback any video format should work, we recommend using a seek-optimized format such as HAP or MJPEG when working on a score. This is because usual video formats for playback, such as H.264 or HEVC (H.265) make tradeoffs for better compression that make seeking much more complicated: in the theoretical worst case, the decoder needs to decode the entire video from the beginning when seeking which of course takes too long. To reencode a video into HAP, you can use ffmpeg from the command-line (or the Handbrake GUI). $ ffmpeg -i source.mov -c:v hap &lt;OPTIONS&gt; output.mov $ ffmpeg -i source.mov -c:v hap -format hap_alpha outputName.mov $ ffmpeg -i source.mov -c:v hap -format hap_q outputName.mov $ ffmpeg -i source.mov -c:v hap -compressor none outputName.mov $ ffmpeg -i source.mov -c:v hap -format hap_q -chunks 4 outputName.mov . The (optional) HAP-related options can be: . | -format hap_alpha for alpha-channel support | -format hap_q for HAP Q codec support | -compressor none slightly reduces playback CPU usage at the cost of larger file sizes. | -chunks &lt;N&gt; with N a number between 1 and 64: optimizes the file for a specific multi-core decoding configuration. | . ",
    "url": "https://ossia.io/score-docs/processes/video.html#limitations",
    "relUrl": "/processes/video.html#limitations"
  },"898": {
    "doc": "Vertex Shader Art",
    "title": "Vertex Shader Art",
    "content": ". The VSA shader process allow you to add and live-code your own shader to an image or video. A shader is a visual effect or generator program, which is processed with the graphics card for maximum performance. They are based on the Vertex Shader Art spec. Unlike traditional ISF shaders, VSA shaders operate on the vertex shader, while the fragment shader is unchanged. The goal of a VSA shader is to indicate the position and the color of a given vertice; then, the shader will be invoked for each point specified, which is extremely fast even on small GPUs. They can be drag’n’dropped from the library, or from the file explorer ; controls and inputs will be created automatically. ",
    "url": "https://ossia.io/score-docs/processes/vertex-shader-art.html",
    "relUrl": "/processes/vertex-shader-art.html"
  },"899": {
    "doc": "Vertex Shader Art",
    "title": "Writing a VSA shader",
    "content": "VSA shaders are very similar to ISF shaders. The differences are: . | We are in a vertex shader instead of a fragment shader: we operate on vertices, not on pixels. | The JSON header must contain the key: | . \"MODE\": \"VERTEX_SHADER_ART\", . | The goal of the shader is to write a value to the following variables: | . gl_Position = vec4(...); // Position of the vertice gl_PointSize = 1./pos.z; // If using point rendering, size of a given point v_color = vec4(abs(ofs/max(length(ofs),1e-9))*.3+.7,1); // Color with which the vertice will be displayed . ",
    "url": "https://ossia.io/score-docs/processes/vertex-shader-art.html#writing-a-vsa-shader",
    "relUrl": "/processes/vertex-shader-art.html#writing-a-vsa-shader"
  },"900": {
    "doc": "Vertex Shader Art",
    "title": "Example",
    "content": "/*{ \"DESCRIPTION\": \"point cloud vs spheres rmx\", \"CREDIT\": \"macro (ported from https://www.vertexshaderart.com/art/nKrw8457n4cFANsJu)\", \"ISFVSN\": \"2\", \"MODE\": \"VERTEX_SHADER_ART\", \"CATEGORIES\": [ \"Geometry\", \"Math\", \"Animated\", \"Particles\", \"Nature\" ], \"POINT_COUNT\": 99999, \"PRIMITIVE_MODE\": \"POINTS\", \"LINE_SIZE\": \"NATIVE\", \"BACKGROUND_COLOR\": [ 0, 0, 0, 1 ], \"INPUTS\": [], \"METADATA\": { \"ORIGINAL_VIEWS\": 50, \"ORIGINAL_DATE\": { \"$date\": 1510363843048 } } }*/ /* point cloud vs spheres by Kabuto Recreated this well-known demo effect. A bit tricky without being able to store history for points, so it's just computed again and again for each render pass */ #define RATE 7.0 vec3 posf2(float t, float i) { return vec3( sin(t+i*.18293) + sin(t*1.311+i) + sin(t*1.4+i*1.53) + sin(t*1.844+i*.76), sin(t+i*.74553+2.1) + sin(t*1.311+i*1.1311+2.1) + sin(t*1.4+i*1.353-2.1) + sin(t*1.84+i*.476-2.1), sin(t+i*1.5553-2.1) + sin(t*1.311+i*1.1-2.1) + sin(t*1.4+i*1.23+2.1) + sin(t*1.84+i*.36+2.1) )*0.1492; } vec3 posf0(float t) { return posf2(t,-1.)*RATE;} vec3 posf(float t, float i) { return posf2(t*.3,i) + posf0(t);} vec3 push(float t, float i, vec3 ofs, float lerpEnd) { vec3 pos = posf(t,i)+ofs; vec3 posf = fract(pos+0.5)-0.5; float l = length(posf)*2.; return (- posf + posf/l)*(1.-smoothstep(lerpEnd,1.,l)); } void main() { // more or less random movement float t = time*.20; float i = vertexId+sin(vertexId)*100.0; vec3 pos = posf(t,i); vec3 ofs = vec3(0); for (float f = -10.; f &lt; 0.; f++) { ofs += push(t+f*.105,i,ofs,2.-exp(-f*.1)); } ofs += push(t,i,ofs,.999); pos -= posf0(t); pos += ofs; pos.yz *= mat2(.8,.6,-.6,.8); pos.xz *= mat2(.8,.6,-.6,.8); pos *= 1.; pos.z += .7; pos.xy *= .6/pos.z; gl_Position = vec4(pos.x, pos.y*resolution.x/resolution.y, pos.z*.1, 1); gl_PointSize = 1./pos.z; v_color = vec4(abs(ofs/max(length(ofs),1e-9))*.3+.7,1); } . ",
    "url": "https://ossia.io/score-docs/processes/vertex-shader-art.html#example",
    "relUrl": "/processes/vertex-shader-art.html#example"
  },"901": {
    "doc": "Vertex Shader Art",
    "title": "Related Processes",
    "content": ". | ISF Shader: Classic ISF fragment shaders. | Compute Shader: Similar to ISF and VSA shaders but for compute instead of fragment shaders. | Model Display: To apply the shader onto a 3D surface. | Lightness Computer: To convert texture data into pixel arrays, for instance for LED design. | . ",
    "url": "https://ossia.io/score-docs/processes/vertex-shader-art.html#related-processes",
    "relUrl": "/processes/vertex-shader-art.html#related-processes"
  },"902": {
    "doc": "Vertex Shader Art",
    "title": "Try it!",
    "content": "Try it by downloading this simple example! Note that the example requires gzdoom to work. ",
    "url": "https://ossia.io/score-docs/processes/vertex-shader-art.html#try-it",
    "relUrl": "/processes/vertex-shader-art.html#try-it"
  },"903": {
    "doc": "Wavecycle",
    "title": "Wavecycle",
    "content": ". Draw your own waveforms and hear them immediately. Wavecycle turns hand-drawn curves into audio oscillators, letting you sculpt sound by sculpting waves. Perfect for creating custom timbres, experimental synthesis, or when you want total control over your oscillator’s harmonic content. Draw harsh sawtooths, smooth sines, or impossible shapes that only exist in your imagination. ",
    "url": "https://ossia.io/score-docs/processes/wavecycle.html",
    "relUrl": "/processes/wavecycle.html"
  },"904": {
    "doc": "Wavecycle",
    "title": "How it works",
    "content": "Wavecycle reads the curve you draw and uses it as a wavetable - cycling through your waveform at audio rate to generate sound. The faster the frequency, the higher the pitch. The curve inlet allows to click and drag to draw any shape you want. The horizontal axis is one complete cycle, the vertical axis is amplitude. Sharp corners create harsh harmonics, smooth curves sound gentle. The frequency inlet is how fast to cycle through your waveform. Low frequencies for bass tones, high frequencies for piercing leads. The frequency parameter includes smoothing to prevent clicks when adjusting. To plug for instance MIDI notes, one needs to take the MIDI pitch and convert it to frequency values: . Try it ! . ",
    "url": "https://ossia.io/score-docs/processes/wavecycle.html#how-it-works",
    "relUrl": "/processes/wavecycle.html#how-it-works"
  },"905": {
    "doc": "What is score ?",
    "title": "What is score ?",
    "content": "ossia score offers advanced tools to ease the authoring of time exigent projects involving medias: flexible score for a live performance, interactive scenario for an intermedia installation, game-like state machine scenarios, etc. It thus provides a unified place to write automations for the parameters of the devices involved in the project, provides means to author efficient mappings from device A to device B or to modulate some devices parameters using generative processes and so on. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html",
    "relUrl": "/quick-start/what-is-score.html"
  },"906": {
    "doc": "What is score ?",
    "title": "Advanced time sequencing environment",
    "content": "When having to author scenarios for interactive art, music and sound performances, one often has to rely on two approaches: . | DAW / timeline-based software offering tools for fine time editing and parameters automation | cue-based software offering great flexibility in live situation | . While both approaches have numerous advantages, they also draw some limits in some advanced media-based productions: First type hardly offers (if any) flexibility in live situation regarding how events actually evolve in time. Second type makes it hard if possible at all to control precisely processes evolving over time. score thus aims at bridging the gap between these two models in a unified environment. By combining a flexible timeline with a patch-like authoring process, it allows to write precisely timed processes such as automations or more fancy parameters control and modulation while still maintaining some variations as the scenario is executed. But it also allows authoring open and non-linear scenarios yet still including some time-dependent processes. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html#advanced-time-sequencing-environment",
    "relUrl": "/quick-start/what-is-score.html#advanced-time-sequencing-environment"
  },"907": {
    "doc": "What is score ?",
    "title": "Interoperability-based",
    "content": "ossia score aims to fully integrate with the favorite tools of artists and musicians involved in advanced media authoring. It allows to remotely control various commercial or custom software and hardware as well as to work with audio or video medias right from the app. While score itself offers some audio and video features, it does not aim at being an “All in one” super software (hence forcing intermedia authors to give up their personal toolset expertise). On the contrary, score was built from the ground up to be as interoperable as possible. Users remain thus free to use their tools of choice, be it their favorite VJing software, custom audio synthesis app or any specialized toolset. score 3.0.0 supports a number of protocols such as MIDI, Open Sound Control, OSCQuery or serial port making it easy to use score as the central hub of a project and thus author fine relationships between medias. ",
    "url": "https://ossia.io/score-docs/quick-start/what-is-score.html#interoperability-based",
    "relUrl": "/quick-start/what-is-score.html#interoperability-based"
  },"908": {
    "doc": "Wiimote device",
    "title": "Wiimote device",
    "content": ". Turn Nintendo Wii Remotes into expressive wireless controllers for your score projects. Get 3D motion sensing, IR pointing, button input, and extension support through Bluetooth connectivity. Perfect for gestural control, spatial audio manipulation, interactive installations, or any project where you want natural, wireless interaction without complex sensor setups. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html",
    "relUrl": "/devices/wiimote-device.html"
  },"909": {
    "doc": "Wiimote device",
    "title": "Setting up a Wiimote device",
    "content": ". | Put your Wiimote in pairing mode - Press and hold the 1 and 2 buttons simultaneously until the LEDs flash | Add device in the Device explorer and choose “Wiimote” | Wait for connection - The device will automatically discover and pair with available Wiimotes | Test the connection - Press buttons and move the remote to see parameter updates | . For IR pointer functionality, set up an IR sensor bar or use candles as IR reference points. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#setting-up-a-wiimote-device",
    "relUrl": "/devices/wiimote-device.html#setting-up-a-wiimote-device"
  },"910": {
    "doc": "Wiimote device",
    "title": "Available inputs",
    "content": "Motion sensing . Accelerometer - 3-axis tilt and motion detection X, Y, Z axes - Raw acceleration values for gesture recognition Tilt angles - Processed roll and pitch for precise orientation control Shake detection - Built-in gesture recognition for sudden movements . Button interface . D-pad - Four-way directional control A and B buttons - Primary action buttons 1 and 2 buttons - Secondary controls Plus and Minus - Menu/settings buttons Home button - Special function button . IR camera . IR pointing - 10-point infrared tracking with sensor bar X/Y coordinates - Screen-relative pointing position Distance sensing - Rough distance estimation from IR sources Multi-point tracking - Track up to 4 IR sources simultaneously . Extension support . Nunchuk - Additional analog stick and motion sensing Classic Controller - Traditional gamepad layout Motion Plus - Enhanced gyroscope for precise rotation Other extensions - Guitar Hero controllers, balance boards, etc. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#available-inputs",
    "relUrl": "/devices/wiimote-device.html#available-inputs"
  },"911": {
    "doc": "Wiimote device",
    "title": "Creative applications",
    "content": "Gestural composition: Map Wiimote movements to musical parameters - tilt for pitch bend, shake for rhythm triggers, pointing for spatial audio control. 3D spatial control: Use accelerometer data for positioning sounds in 3D space with DBAP or GBAP spatialization. Interactive performances: Wireless freedom lets performers move naturally while controlling audio, video, or lighting parameters. Installation interaction: Provide intuitive, game-like interfaces for gallery visitors - everyone knows how to use a Wiimote. Multi-user systems: Connect multiple Wiimotes for collaborative control or performance systems. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#creative-applications",
    "relUrl": "/devices/wiimote-device.html#creative-applications"
  },"912": {
    "doc": "Wiimote device",
    "title": "Integration with score processes",
    "content": "Mapping Tool: Shape accelerometer data into musical curves - add dead zones for steady holding, create response curves for natural gesture feel. Spatial audio: Connect motion data directly to DBAP positioning for sound that follows your movements through 3D space. Audio Effects: Map tilt and rotation to effect parameters - shake the remote to add distortion, tilt for filter sweeps. Video processing: Control visual effects with gesture - point to control projection mapping, shake for visual intensity. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#integration-with-score-processes",
    "relUrl": "/devices/wiimote-device.html#integration-with-score-processes"
  },"913": {
    "doc": "Wiimote device",
    "title": "Advanced techniques",
    "content": "Gesture recognition: Combine multiple axis data to recognize complex gestures - figure-8 movements, specific pointing patterns, or choreographed sequences. Sensor fusion: Use accelerometer and IR data together for more robust tracking and control. Distance-based interaction: Use IR distance sensing for proximity-based effects - sounds that change as you approach or move away from reference points. Multi-controller orchestration: Create ensemble pieces where multiple performers with Wiimotes contribute to a unified musical or visual experience. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#advanced-techniques",
    "relUrl": "/devices/wiimote-device.html#advanced-techniques"
  },"914": {
    "doc": "Wiimote device",
    "title": "Technical considerations",
    "content": "Bluetooth connectivity: Wiimotes use Bluetooth HID protocol - ensure your system supports Bluetooth connections and proper pairing. Battery life: Wiimotes use AA batteries - expect 30-60 hours of use depending on rumble and speaker usage. Consider rechargeable batteries for installation use. IR setup: For pointer functionality, position IR sources (sensor bar, candles, IR LEDs) appropriately for your space and interaction design. Range limitations: Bluetooth range is typically 10 meters - plan your performance or installation space accordingly. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#technical-considerations",
    "relUrl": "/devices/wiimote-device.html#technical-considerations"
  },"915": {
    "doc": "Wiimote device",
    "title": "Troubleshooting",
    "content": "Connection issues: Try re-pairing by pressing 1+2 buttons, ensure Bluetooth is enabled and working, check that the Wiimote isn’t paired to another device. Poor motion tracking: Check battery levels, ensure the remote isn’t in a case or cover that blocks sensors, recalibrate if necessary. IR problems: Ensure IR sources are visible to the Wiimote camera, check for interference from other IR sources, verify sensor bar positioning. Lag or dropouts: Move closer to reduce Bluetooth distance, minimize interference from other wireless devices, check for low battery conditions. The Wiimote device works beautifully with OSC for networking gesture data, MIDI for musical applications, or Joystick devices for hybrid control setups that combine different input methods. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#troubleshooting",
    "relUrl": "/devices/wiimote-device.html#troubleshooting"
  },"916": {
    "doc": "Wiimote device",
    "title": "Related devices",
    "content": "Combine with Joystick devices for comprehensive controller setups, use OSC to network Wiimote data to other systems, or integrate with Kinect for full-body plus handheld gesture control. ",
    "url": "https://ossia.io/score-docs/devices/wiimote-device.html#related-devices",
    "relUrl": "/devices/wiimote-device.html#related-devices"
  },"917": {
    "doc": "Window device",
    "title": "Window properties",
    "content": ". | /screen: on which screen the window must be shown. | /position: absolute position of the window on the user’s viewport. | /size: window size in pixels. | /rendersize: the resolution at which rendering is done. If it is [0, 0] then the renderer is rescaled to follow the window resolution. | /fullscreen: show as fullscreen. Double-clicking on the window will also trigger this. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#window-properties",
    "relUrl": "/devices/window-device.html#window-properties"
  },"918": {
    "doc": "Window device",
    "title": "Mouse input",
    "content": ". | /cursor/scaled: mouse cursor position in the window scaled to [0;1] bounds. | /cursor/absolute: mouse cursor position in the window in pixels. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#mouse-input",
    "relUrl": "/devices/window-device.html#mouse-input"
  },"919": {
    "doc": "Window device",
    "title": "Tablet input",
    "content": ". | /tablet/scaled: tablet pen position in the window scaled to [0;1] bounds. | /tablet/absolute: tablet pen position in the window in pixels. | /tablet/z: tablet pen height. | /tablet/pressure: tablet pen pressure. | /tablet/rotation: tablet pen rotation. | /tablet/tangential: tablet pen tangential pressure. | /tablet/tilt_x and /tablet/tilt_y: tablet pen tilt. | . The values are extracted directly from Qt’s QTabletEvent. ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#tablet-input",
    "relUrl": "/devices/window-device.html#tablet-input"
  },"920": {
    "doc": "Window device",
    "title": "Keyboard input",
    "content": ". | /key/code: low-level key code corresponding to the current user input. One per keystroke. | /key/text: high-level combined result of the user’s keystrokes. For instance, a user pressing “Shift + G” will yield a capital “G” text here. | . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html#keyboard-input",
    "relUrl": "/devices/window-device.html#keyboard-input"
  },"921": {
    "doc": "Window device",
    "title": "Window device",
    "content": ". The Window device allows to show a window in which visuals will be rendered. Its device tree contains the following parameters: . ",
    "url": "https://ossia.io/score-docs/devices/window-device.html",
    "relUrl": "/devices/window-device.html"
  },"922": {
    "doc": "Working with audio",
    "title": "Working with audio in score\n",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#working-with-audio-in-score",
    "relUrl": "/quick-start/working-with-audio.html#working-with-audio-in-score"
  },"923": {
    "doc": "Working with audio",
    "title": "Audio setup",
    "content": "Before playing with audio sound files or synthesis in score you may want to ensure audio settings are properly set up. To do so, open the Preferences window from the score menu and select the “Audio” tab on the left side of the Preferences window. Then select the Driver you want to use as well as the desired audio interface and related options (Buffer size and sample rate). Make sure the audio switch is properly lit on. When done, you’re ready to go! . ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#audio-setup",
    "relUrl": "/quick-start/working-with-audio.html#audio-setup"
  },"924": {
    "doc": "Working with audio",
    "title": "Playing audio file",
    "content": "Audio files can easily be integrated to your scenario. Just grab your file on your disk and drop it at the desired place on the timeline. Click the play button (or use spacebar shortcut) and that’s it. By default, score will use the main stereo output of your audio interface. Be sure to read the audio routing section for more information. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#playing-audio-file",
    "relUrl": "/quick-start/working-with-audio.html#playing-audio-file"
  },"925": {
    "doc": "Working with audio",
    "title": "Combining audio medias and devices control",
    "content": "Audio files (and more generally medias) can be fully combined with device’s automations or other processes in the scenario. Thus you can write medias playing and distant devices remote control at a single place. In the example below, we just want to play one audio file synchronously with some automations already in place. Rather than dropping our audio file on the timeline and align things by hand, we can just drop it on the automation’s slot top bar so it sticks to it. In this particular case, you may notice though that the dropped sound file is shorter than the full length of the automation. Just bring the audio file inspector and toggle the loop mode. Now when playing the scenario, the audio file will loop as long as the automation is playing. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#combining-audio-medias-and-devices-control",
    "relUrl": "/quick-start/working-with-audio.html#combining-audio-medias-and-devices-control"
  },"926": {
    "doc": "Working with audio",
    "title": "Adding audio effects",
    "content": "Contrary to some other software, score does not rely so much on the studio recording metaphor involving the usual mixing desk, per track FX, fixed busses and so on. Rather, it relies much more on a time-based modular approach. Without going too much into details of score engine for now, let’s just say that it offers to have a unique sound chain (audio source, FX or modulators) for each block of the scenario involving audio. As illustrated below, you can easily add some FX, either from the built-in library or some VST effects installed on your computer to some audio file in your scenario. When dropped, a patch-like workspace is created. For demonstration purpose here, we will just add a simple gain controller. Below the sound file waveform, you can note a red dot. This actually is the audio output. We can just drag a cable from this red dot down to the red circle (its input) at the left of the gain FX. When playing the scenario, audio file will now play through this simple FX and go out to the main output. Again, when the play-head gets beyond the automation’s slot, audio will get fully bypassed (hence preventing from any CPU drain). Feel free to get familiar with this patch workspace using other audio FX or VST of your own collection. You may also note some yellow circle and frames. These are respectively control input and output of some processes parameter. Should you feel adventurous, have fun checking the Control folder in the Process library to add modulation to your FX’s parameters. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html#adding-audio-effects",
    "relUrl": "/quick-start/working-with-audio.html#adding-audio-effects"
  },"927": {
    "doc": "Working with audio",
    "title": "Working with audio",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-audio.html",
    "relUrl": "/quick-start/working-with-audio.html"
  },"928": {
    "doc": "Working with devices",
    "title": "Working with your devices",
    "content": "score is built from the ground up to be as interoperable as possible with other devices involved in a creative project, whether they are software or hardware. When starting a project in score you will most likely want to start by setting up the devices score will be used with. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#working-with-your-devices",
    "relUrl": "/quick-start/working-with-devices.html#working-with-your-devices"
  },"929": {
    "doc": "Working with devices",
    "title": "Setting up your devices network",
    "content": "These devices can be freely added to your current score project from the Device explorer panel. Bring up the Device explorer panel using Ctrl+Shift+D(Win / Linux) or⌘+Shift+D(Mac) shortcut or click on the bottom left icon. Right click on the Device explorer panel and setup the desired communication protocol between score and your device. Remember you can at any time edit the settings of your device using right-click, then selecting Edit from the contextual menu . Score currently supports the following devices types: . | Network | Utilities | Hardware | Web | Lights | Audio | Video | . | OSCQuery | Mapper | Midi in | HTTP | Artnet | Audio | Window | . | OSC | Local | Midi out | WS |   |   | Camera | . | Minuit |   | Serial |   |   |   | Spout | . | CoAP |   | Joystick |   |   |   | Syphon | . | MQTT |   | Wiimote |   |   |   | Shmdata | . |   |   | GPS |   |   |   | NDI | . |   |   | Leapmotion |   |   |   |   | . |   |   | Raw I/O |   |   |   |   | . |   |   | BLE |   |   |   |   | . Detailed explanations on these various device types and corresponding setup options can be found in the Reference pages. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#setting-up-your-devices-network",
    "relUrl": "/quick-start/working-with-devices.html#setting-up-your-devices-network"
  },"930": {
    "doc": "Working with devices",
    "title": "Devices’ namespace browsing",
    "content": "The Device explorer provides a unified view of your device’s parameters as a tree-like structure. Devices are exposed as a number of nodes (some key parts of your device) and their related parameters. From there you can freely browse your distant devices for monitoring or more importantly to select the parameters you want to control from score, as detailed in the next topic of this Quick start. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#devices-namespace-browsing",
    "relUrl": "/quick-start/working-with-devices.html#devices-namespace-browsing"
  },"931": {
    "doc": "Working with devices",
    "title": "Monitor &amp; remote control of parameters",
    "content": "The Device explorer also provides detailed information about your device parameters. Clicking a parameter from the namespace brings a dedicated inspector at the bottom displaying it’s various attributes, such as its current value (assuming your device echoes back its parameters value to score). You may also use this inspector to remotely change the value of a parameter (e.g. for testing purpose). ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html#monitor--remote-control-of-parameters",
    "relUrl": "/quick-start/working-with-devices.html#monitor--remote-control-of-parameters"
  },"932": {
    "doc": "Working with devices",
    "title": "Working with devices",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-devices.html",
    "relUrl": "/quick-start/working-with-devices.html"
  },"933": {
    "doc": "Working with video",
    "title": "Working with video in score\n",
    "content": "score embeds a number of video related features: media playing and processing, GPU-based processing or synthesis. Just like with audio files, video files can be thus fully integrated to your scenario along with other processes and distant devices controls. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#working-with-video-in-score",
    "relUrl": "/quick-start/working-with-video.html#working-with-video-in-score"
  },"934": {
    "doc": "Working with video",
    "title": "Supported formats",
    "content": "Score supports all video files formats supported by the FFMPEG library. More info on supported files can be found on the FFMPEG website. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#supported-formats",
    "relUrl": "/quick-start/working-with-video.html#supported-formats"
  },"935": {
    "doc": "Working with video",
    "title": "Video setup",
    "content": "First, we need to setup our video output. To do so, we need to add a video window device to our project by right-clicking in the Device explorer pane and choose Add device from the contextual menu. In the device setup window, mouse over to the video category and choose the Window device. You may define a name for the video window or use the default name and click Add. When done, score creates a black video window. You can see in the Device explorer a device with the defined name. You will note that contrary to other devices used so far, this one has no parameters under its root node. This device basically only creates a video output window and rendering context. If the window is closed, it’s possible to open it again with a right-click on the device’s name and then click on show . ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#video-setup",
    "relUrl": "/quick-start/working-with-video.html#video-setup"
  },"936": {
    "doc": "Working with video",
    "title": "Playing a video file",
    "content": "To add a video file to the timeline, just grab your file on disk or in the project library and drop it where you want on the timeline. As seen in the previous section, you may as well drop it on top of some already existing automation’s slot so your video file is aligned. When done, a slot containing the video file gets created on the timeline. This creates a Video process. You can adjust the length of the slot to fit the part of the video file to play following the different key frames of the video. We now need to route our video file to our video window so it gets displayed when execution the scenario. Just as with other processes used so far (automation as well as audio), the video slot has an output port at the bottom: the white filled circle. Click on the output port to bring its inspector. From there, select your window video device in the dedicated menu. Now when executing your scenario, video file will get properly displayed in window. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#playing-a-video-file",
    "relUrl": "/quick-start/working-with-video.html#playing-a-video-file"
  },"937": {
    "doc": "Working with video",
    "title": "Adding video effects",
    "content": "Again, similarly to audio files, you can easily drag some effects. From the Processes Library pane or from the User library pane, select one of the processes in the GFX category. In the example below, we will use the Shader filter provided in score default library. We now need to route our video file to the video effect rather than from the window. To do so, drag a cable from the video file output port (the white filled circle) to the effect input port (the white framed circle) as shown below. Then from the shader output port inspector, choose GFX as output. You may now play with the shader parameters using its UI as the scenario is executed or write some automations. ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html#adding-video-effects",
    "relUrl": "/quick-start/working-with-video.html#adding-video-effects"
  },"938": {
    "doc": "Working with video",
    "title": "Working with video",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/working-with-video.html",
    "relUrl": "/quick-start/working-with-video.html"
  },"939": {
    "doc": "Writing automations",
    "title": "Writing continuous parameter control",
    "content": "Score provides numerous features to control continuously your devices’ parameters over time. These are provided through the Process library available by clicking on the icon at the bottom left of score window (or using Ctrl+Shift+P(Win / Linux) or⌘+Shift+P(Mac) shortcut). In the example below, we will just create a basic breakpoint function-based automation for one of our device’s parameters by selecting the automation (float) in the Process library, then dragging &amp; dropping it where we want it on the timeline. When done, you will see on the timeline a simple 1 segment linear default automation. Let’s now assign our device parameter as a destination for this simple automation process. Click on the automation’s slot top bar to bring its inspector. Now from the Device explorer drag the desired parameter on the address field. The automation is now assigned to our parameter. When playing the scenario, our device’s parameter will get driven by an ascending ramp as the playhead goes across the automation slot. Of course, you may refine your automation function by double-clicking in the automation slot to add more points or select a segment and use Shift+Drag to add curvature to the segment as well as using other advanced features as detailed in the Automation reference page. You can extend your automation slot by dragging along the timeline its top right corner (the blue dot). By default, slot will get extended will preserving the automation length so you can further write your automation. You may also drag it using Cmd+Drag to scale the automation as the slot gets extended along the timeline . Full size edit . When further precision is required to edit your automation, you can double-click the name above the automation slot (here “automation (float)” to zoom in the slot and edit the automation in full size. When done editing, you can go back to your scenario full view using Cmd+↑ or clicking on your scenario name beneath the time ruler. ",
    "url": "https://ossia.io/score-docs/quick-start/writing-automations.html#writing-continuous-parameter-control",
    "relUrl": "/quick-start/writing-automations.html#writing-continuous-parameter-control"
  },"940": {
    "doc": "Writing automations",
    "title": "Writing automations",
    "content": " ",
    "url": "https://ossia.io/score-docs/quick-start/writing-automations.html",
    "relUrl": "/quick-start/writing-automations.html"
  },"941": {
    "doc": "WebSocket device",
    "title": "WebSocket device",
    "content": ". This device allows to connect to an existing WebSocket server, and exchange messages bidirectionally. Since such servers can have arbitrarily complex APIs, we have to map these APIs to score’s tree-based parameter model. This is done with a QML script, just like for the Serial and HTTP devices. ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html",
    "relUrl": "/devices/ws-device.html"
  },"942": {
    "doc": "WebSocket device",
    "title": "Sample code",
    "content": "Consider a WebSockets server which notifies about road traffic (available in the user library): . /** * To try: * - Install node.js * - npm install ws * - node RoadTrafficServer.js * * This server has the following API: * - It will regularly send the message to its clients: * { * sensorValue: { * name: \"Some place\", * value: 123 // the sensor reading, some dummy number which increments * } * } * * - It reacts to the following message: * { sensor: X } // X can be between 0 and 3 * * and will change the sensor being updated appropriately. * */ const ws = require(\"ws\"); const wss = new ws.WebSocketServer({ port: 8080 }); const clamp = (num, min, max) =&gt; Math.min(Math.max(num, min), max); let sensors = [ { name: \"Hôtel de ville\", value: 0 }, { name: \"St. Catherine\", value: 140 }, { name: \"Place de la Bourse\", value: 7 }, { name: \"Cours de la Libération\", value: 15 }, ]; let currentSensor = { sensorValue: sensors[0] }; let index = 0; wss.on('connection', function connection(ws) { ws.on('message', function message(data) { console.log('received: %s', data); const rq = JSON.parse(data); const idx = parseInt(rq.sensor); console.log(rq, clamp(idx, 0, 3)); currentSensor = { sensorValue: sensors[clamp(idx, 0, 3)] }; ws.send(JSON.stringify(currentSensor)); }); setInterval(() =&gt; { currentSensor.sensorValue.value ++; ws.send(JSON.stringify(currentSensor)); }, 100); }); . The following QML code is able to interact with it: . import Ossia 1.0 as Ossia // Note: to run this example you need to run the RoadTrafficServer.js // available in the library Ossia.WebSockets { property string host: \"ws://127.0.0.1:8080\" // Called whenever the Websocket gets connected function onConnected() { console.log(\"Connected !\") return [ ]; // Return type: see onMessage } // Called whenever the Websocket gets disconnected function onDisonnected() { console.log(\"Connected !\") return [ ]; // Return type: see onMessage } // Called whenever the Websocket server sends us a message function onMessage(message) { // The message has the format: // { // sensorValue: { // name: \"Some place\", // value: 123 // the sensor reading, some dummy number which increments // } // } // // We want to convert it into the following ossia address space // and apply a simple mapping: // // /traffic/name: \"Some place\" // /traffic/value: 1.23 // 1. Parse the json var res = JSON.parse(message); // 2. For each address to update in the tree, return a message: // { address: \"/foo/bar\", value: ... } return [ { address: \"/traffic/sensor\", value: res[\"sensorValue\"][\"value\"] / 100. }, { address: \"/traffic/name\", value: res[\"sensorValue\"][\"name\"] } ]; } // This is used to set-up the device tree with the relevant functions function createTree() { return [ { name: \"traffic\", children: [ // These two will just display the value from onMessage { name: \"sensor\", type: Ossia.Type.Float }, { name: \"name\", type: Ossia.Type.String }, // This one is a request to be made to the server { name: \"change_sensor\", type: Ossia.Type.Int, // For the three following functions, // the return value is sent to the WS server if not undefined: // 1. When a message is sent from score request: function (value) { // value is: // { // type: \"some_type\" // value: ... the actual value ... // } // e.g. { type: Ossia.Type.Int, value: 123 } // in order to differentiate between ints, floats, etc return JSON.stringify({ sensor: value.value }); }, // 2. When score listens on a node openListening: function () { console.log(\"open listening\"); }, // 3. When score stops listening on a node closeListening: function () { console.log(\"open listening\"); } } ] } ]; } } . ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html#sample-code",
    "relUrl": "/devices/ws-device.html#sample-code"
  },"943": {
    "doc": "WebSocket device",
    "title": "Creating a device from existing JSON",
    "content": "Consider an API which regularly updates its clients with the following JSON: . { \"widget\": { \"debug\": \"on\", \"window\": { \"title\": \"Sample Konfabulator Widget\", \"name\": \"main_window\", \"width\": 500, \"height\": 500 }, \"image\": { \"src\": \"Images/Sun.png\", \"name\": \"sun1\", \"hOffset\": 250, \"vOffset\": 250, \"alignment\": \"center\" }, \"text\": { \"data\": \"Click Here\", \"size\": 36, \"style\": \"bold\", \"name\": \"text1\", \"hOffset\": 250, \"vOffset\": 100, \"alignment\": \"center\", \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\" } } } . This is a tree structure that maps very cleanly to score’s model. To facilitate this simple case, an user script is provided as part of the user library: it will take a sample JSON and create the relevant QML code. It is accessible in the Scripts/Protocols/Websockets/Device from JSON menu option. The processFromJson property on the root Ossia.WebSocket will enable automatic processing of incoming JSON: it will as far as possible be matched to the structure of the tree in order to update the parameters. Note that this is much more efficient than doing it manually through onMessage as this is implemented directly in C++. ",
    "url": "https://ossia.io/score-docs/devices/ws-device.html#creating-a-device-from-existing-json",
    "relUrl": "/devices/ws-device.html#creating-a-device-from-existing-json"
  }
}
